#include "config.h"

open Ast
open Astcommon
open Abi

type coqgen_env = {
  filename : string;
  project_name : string;

  coq_DataTypes : out_channel;
  coq_DataTypeOps : out_channel;
  coq_DataTypeProofs : out_channel;
  coq_LinkSource : out_channel;
  coq_Symbols : out_channel;

  arg_ret_idents : (ident, string) Hashtbl.t;
  cstruct_idents : (ident, unit) Hashtbl.t;
  global_idents : (ident, unit) Hashtbl.t;

  files : string list ref;

  external_verbatim : (string * int) list;
  folded_external_symbol_string : string;
  partial_external_symbols : (ident, unit) Hashtbl.t;

  folded_symbols : string ref
}

(* This a topological sort for the dependency DAG.
   For example, when annotating an external import with [[except DataTypes]],
   it will be imported into the files that come after DataTypes. *)
let file_class_NoDefaultImports = 0
let file_class_EdsgerIdents = 0  (* nominal *)
let file_class_DataTypes = 1
let file_class_DataTypeOps = 2  (* including DataTypeProofs *)
let file_class_Layers = 3
let file_class_ObjAux = 4
let file_class_Refinements = 5
let file_class_Code = 6

let classify_file = function
  | "Idents" -> file_class_EdsgerIdents
  | "NoDefaultImports" -> file_class_NoDefaultImports
  | "DataTypes" -> file_class_DataTypes
  | "DataTypeOps" | "DataTypeProofs" -> file_class_DataTypeOps
  | "Layers" -> file_class_Layers
  | "ObjAux" -> file_class_ObjAux
  | "Refinements" -> file_class_Refinements
  | "CodeProofs" -> file_class_Code
  | _ -> file_class_NoDefaultImports

let catch_not_found f v = try Some (f v) with Not_found -> None
let string_of_ident n = string_of_int n ^ "%positive"

(* This regular expression defines the names that can be used as Coq module names.
   If the user specifies something else, we take the longest prefix that satsifies the regexp. *)
let module_name_regexp = Str.regexp "[a-zA-Z_][a-zA-Z0-9_']*"
let default_module_name = "EdsgerGen"
let builtin_base_layer_name = "BuiltinBase"

let arg_ret_instance_regexp = Str.regexp "\\bHyperArgRet[ \t]+\\(t[a-zA-Z0-9_']*\\)"

(* Print the boilerplate at the top of a generated file. *)
let new_file_imports env out extra_requires classify =
  if classify > file_class_NoDefaultImports then
    output_string out
      ("Require Import BinPos.\n" ^
       "Require Import DeepSpec.Runtime.\n");
  if classify > file_class_ObjAux then
    output_string out
      ("Require Import DeepSpec.Linking.\n");
  if classify > file_class_NoDefaultImports then
    output_string out
      ("Require Import " ^ env.project_name ^ ".EdsgerIdents.\n");
  if classify > file_class_DataTypes then
    output_string out ("Require Import " ^ env.project_name ^ ".DataTypes.\n");
  if classify > file_class_DataTypeOps then
    output_string out
      ("Require Import " ^ env.project_name ^ ".DataTypeOps.\n" ^
       "Require Import " ^ env.project_name ^ ".DataTypeProofs.\n");
  output_string out extra_requires;
  if classify > file_class_EdsgerIdents then
    output_string out "\nSection EdsgerGen.\n\n";
  List.iter (fun (s, except) ->
    if classify > except then output_string out s
  ) env.external_verbatim

let new_file env module_name
	         extra_requires  (* These will be printed directly after the above set of requires. *)
                 classify (* the topologial order number *) =
  let file_name = env.project_name ^ "/" ^ module_name ^ ".v" in
  let out = open_out file_name in
  env.files := file_name :: !(env.files);
  output_string out (
"(* WARNING: This file is generated by Edsger, the DeepSEA compiler.
            All modification will be lost when regenerating. *)
(* Module " ^ env.project_name ^ "." ^  module_name ^ " for " ^ env.filename ^ " *)\n");
  new_file_imports env out extra_requires classify;
  out

let end_edsger_section_regexp = Str.regexp ".*\\bEnd +EdsgerGen *\\.\\( \\|$\\)"

let new_incremental_file env module_name extra_requires output_in_section
                             entry_regexp classify =
  let file_marker = "(* Skeleton by Edgser for " ^ env.filename ^ " *)" in
  let file_name = env.project_name ^ "/" ^ module_name ^ ".v" in
  let _ = env.files := file_name :: !(env.files) in
  if Sys.file_exists file_name then begin
    print_endline ("File " ^ file_name ^ " already exists; will append to it.");

    let tmp_name = env.project_name ^ "/." ^ module_name ^ ".v" in
    begin try Sys.remove tmp_name with Sys_error _ -> () end;
    Sys.rename file_name tmp_name;

    let old = open_in tmp_name in
    let out = open_out file_name in
    let entrytbl = Hashtbl.create 100 in

    let search line =
      let rec f from =
        let at = Str.search_forward entry_regexp line from
        in Hashtbl.add entrytbl (Str.matched_group 1 line) (Str.matched_string line);
           f (at + 1)
      in try f 0 with Not_found (* Str.search_forward *) -> () in

    let rec process first lastline =
      search lastline;
      if Str.string_match end_edsger_section_regexp lastline 0 then
        ()
      else begin
        if not first then
          output_char out '\n';
        output_string out lastline;
        process false (input_line old)
      end in

    let firstline = input_line old in
    if firstline <> file_marker then
      print_endline " ** Seems from a different project; remove and then recompile to avoid unpredictable behaviors. **";

    begin try process true firstline
         with End_of_file (* input_line *) -> () end;

    close_in old;
    Sys.remove tmp_name;

    out, entrytbl
  end else  (* [if] Sys.file_exists file_name *)
    let out = open_out file_name in
    output_string out (file_marker ^ "\n");
    new_file_imports env out extra_requires classify;
    output_in_section out;
    out, Hashtbl.create 100

let new_coqgen_env filename  ast =
  let project_name =
    let basename = Filename.basename filename in
    if Str.string_match module_name_regexp basename 0 then
      Str.matched_string basename
    else begin
      print_endline ("Cannot use prefix of file name '" ^ basename ^
        "' as Coq module name: default to '" ^ default_module_name ^ "'");
      default_module_name
    end in
  let _ = try Unix.mkdir project_name 0o777
          with Unix.Unix_error (Unix.EEXIST, _, _) -> () in
  (*make the extract dir*)
#ifndef REDACTED
  let __ = try Unix.mkdir (project_name ^ "/" ^ "extraction") 0o777
          with Unix.Unix_error (Unix.EEXIST, _, _) -> () in
#endif

  let env0 = {
    filename = filename;
    project_name = project_name;

    coq_DataTypes = stderr;
    coq_DataTypeOps = stderr;
    coq_DataTypeProofs = stderr;
    coq_LinkSource = stderr;
    coq_Symbols = stderr;

    arg_ret_idents = Hashtbl.create 100;
    cstruct_idents = Hashtbl.create 100;
    global_idents = Hashtbl.create 1000;

    files = ref [];

    external_verbatim = List.map (fun (s, excepts) ->
        s, List.fold_left (fun c except -> max c (classify_file except))
                          0 excepts
      ) ast.aFileExternalVerbatim;
    folded_external_symbol_string =
      String.concat " " (List.map (fun e -> e.aExtConstName)
				  (List.filter (fun e -> not e.aExtConstUnfolding)
					       ast.aFileExternalSymbols));
    partial_external_symbols =
      (let tbl = Hashtbl.create 0 in
       let _ = List.map (fun e ->if e.aExtConstPartial
				then Hashtbl.add tbl e.aExtConstName ())
		       ast.aFileExternalSymbols in
       tbl);

    folded_symbols = ref "" } in

  let file_DataTypeProofs, arg_ret_idents =
    new_incremental_file env0 "DataTypeProofs"
      ("Require Import " ^ project_name ^ ".DataTypeOps.\n") (fun _ -> ())
      arg_ret_instance_regexp file_class_DataTypeOps in
  let _ = List.iter
    (fun builtin_tpair -> Hashtbl.add arg_ret_idents builtin_tpair "")
    [ "tint_bool"; "tint_Z32";
      "tvoid_unit" (* doesn't really exist, but ignoring is safe *) ] in

  let coq_DataTypes = new_file env0 "DataTypes" "" file_class_DataTypes in
  let coq_DataTypeOps = new_file env0 "DataTypeOps" "" file_class_DataTypeOps in
  let coq_LinkSource =
#ifdef REDACTED
    open_out "/dev/null" in
#else
    new_file env0 "CertiKOS" "" file_class_ObjAux in
#endif
  let coq_Symbols =
#ifdef REDACTED
    open_out "/dev/null" in
#else
    new_file env0 "Symbols" "Require Import String.\nRequire Import List.\nRequire Import compcert.common.AST." file_class_DataTypes in
#endif

  { env0 with
    coq_DataTypes = coq_DataTypes;
    coq_DataTypeOps = coq_DataTypeOps;
    coq_DataTypeProofs = file_DataTypeProofs;
    coq_LinkSource = coq_LinkSource;
    coq_Symbols = coq_Symbols;
    arg_ret_idents = arg_ret_idents
  }

let delete_coqgen_env env =
  let close_coq ch = output_string ch "\nEnd EdsgerGen.\n"; close_out ch in
  close_coq env.coq_DataTypes;
  close_out env.coq_DataTypeOps;
  close_coq env.coq_DataTypeProofs;
  close_coq env.coq_LinkSource;
  close_coq env.coq_Symbols;

  let output_hashtbl out tbl start_num =
    let arr = Array.make (Hashtbl.length tbl) "" in
    let i = ref 0 in
    let _ = Hashtbl.iter (fun x _ -> arr.(!i) <- x; incr i) tbl in
    let _ = Array.sort compare arr in
    if !i > 0 then
      let _ = output_char out '\n' in
      let num = ref start_num in
      let _ = Array.iter (fun x ->
          output_string out ("Definition " ^ x ^ " : ident  := " ^ string_of_ident !num ^ ".\n");
          incr num
        ) arr
      in !num
    else
      start_num in

  let file_EdsgerIdents = new_file env "EdsgerIdents"
        "Require Import BinPos.  (* positive_scope *)\nRequire Import backend.AST. (* for ident *)\n" 
        file_class_EdsgerIdents in
  let n = output_hashtbl file_EdsgerIdents env.cstruct_idents 550 in
  let _ = output_hashtbl file_EdsgerIdents env.global_idents n in
                         (* ((n / 500 + 1) * 500) in *)
  close_out file_EdsgerIdents;

  let files = List.sort compare !(env.files) in
  let file_subdir_mk =
#ifdef REDACTED
    open_out "/dev/null" in
#else
    open_out (env.project_name ^ "/subdir.mk") in
#endif
  output_string file_subdir_mk (
"# WARNING: This file is generated by Edsger, the DeepSEA compiler.
#          All modification will be lost when regenerating.
" ^ env.project_name ^ "_FILES =");
  List.iter (fun s -> output_string file_subdir_mk (" \\\n" ^ s)) files;
  output_char file_subdir_mk '\n';
  close_out file_subdir_mk

let output_cstruct_ident env i =
  if not (Hashtbl.mem env.cstruct_idents i) then
    Hashtbl.add env.cstruct_idents i ()

let output_global_ident env i =
  if not (Hashtbl.mem env.global_idents i) then
    Hashtbl.add env.global_idents i ()

let add_folded_symbols env syms =
  env.folded_symbols :=
    String.concat " " syms ^
    if !(env.folded_symbols) = "" then
      ""
    else
      " " ^ !(env.folded_symbols)

let coqgen_warning  msg =
  print_endline ("CoqGen warning: " ^ msg)

let coqgen_fatal_error loc func msg =
  print_endline ("CoqGen error at " ^ loc ^ " (" ^ func ^ "): " ^ msg);
  assert false

let rec output_type_expr out ind t = match t.aTypeDesc with
  | ATprod (t1, t2) ->
    output_string out "(prod ";
    output_type_expr out ind t1;
    output_char out ' ';
    output_type_expr out ind t2;
    output_char out ')'
  | ATarray (_, t') ->
    output_string out "(ZMap.t ";
    output_type_expr out ind t';
    output_char out ')'
  | ATmapping ({ aTypeDesc = ATbuiltin t_index}, t')
     when t_index = Tuint || t_index = Taddress ->
    output_string out "(Int256Tree.t ";
    output_type_expr out ind t';
    output_char out ')'
  | ATmapping _ ->
     coqgen_fatal_error __LOC__ "output_type_expr" "mapping keys of types other than 'uint' and 'address' are currently unsupported."
  | ATlist t' ->
    output_string out "(list ";
    output_type_expr out ind t';
    output_char out ')'
  | d -> output_string out (match d with
    | ATbuiltin Tint -> "Z32"
    | ATbuiltin Tuint -> "int256"
    | ATbuiltin Thashvalue -> "hashvalue"
    | ATbuiltin Tbool -> "bool"
    | ATbuiltin Taddress -> "int256"
    | ATbuiltin Tunit -> "unit"
    | ATbuiltin Tglobalpointer -> "globalpointer"
    (*
    | ATbuiltin Tval -> "val"
    | ATbuiltin Tflatmem -> "flatmem"
    *)
    | ATdata (i, _) -> i
    | ATexternal extype -> extype.aEXTypeString
    | _ -> coqgen_fatal_error __LOC__ "output_type_expr" "inconsistent rematch")

(* Output the Coq type of a method, e.g. "Z -> bool -> DS bool" *)		       
let output_method_type_expr out mt =
  (match mt.aMethodArgumentTypes with
  | [t] when t.aTypeDesc = ATbuiltin Tunit -> ()
  | params -> List.iter (fun t -> output_type_expr out "" t; output_string out " -> ") params);
  output_string out " machine_env GetHighData -> DS ";
  output_type_expr out "" mt.aMethodReturnType

let gen_struct_type env i c =
  let out = env.coq_DataTypes in
  let record_field_leftover = ref "\n" in
  output_string out ("Record " ^ i ^ " := {");
  List.iter (fun (fld, t) ->
    output_string out (!record_field_leftover ^ "  " ^ fld ^ " : ");
    output_type_expr out "    " t;
    record_field_leftover := ";\n"
  ) c.aTypeConstrArgs;
  output_string out "\n}.\n"

let gen_data_type env i cs =
  let out = env.coq_DataTypes in
  output_string out ("Inductive " ^ i ^ " :=\n");
  List.iter (fun c ->
    output_string out ("| " ^ c.aTypeConstrName);
    List.iter (fun (fld, t) ->
      output_string out (" (" ^ fld ^ " : ");
      output_type_expr out "    " t;
      output_char out ')'
    ) c.aTypeConstrArgs;
    output_string out (" : " ^ i ^ "\n")
  ) cs;
  output_string out ".\n"

let struct_name_to_ident name = name ^ "_struct_ident"
let struct_field_name_to_ident sname fname = sname ^ "_struct_" ^ fname ^ "_ident"

(* "prepare" is not quite the right name. You should call output_prepare_ctype and output_ctype
   for each type. They write different things to different files. *)
let rec output_prepare_ctype env out = function
  | ACtpointer ct | ACtarray (_, ct) -> output_prepare_ctype env out ct
  | ACtstruct (name, lst) ->
    output_cstruct_ident env (struct_name_to_ident name);
    List.iter (fun (fld, ct) ->
      output_cstruct_ident env (struct_field_name_to_ident name fld);
      output_prepare_ctype env out ct;
    ) lst;
  | _ -> ()

let rec output_ctype out ind = function
  | ACtint -> output_string out "tint"
  | ACtchar -> output_string out "tchar"
  | ACtvoid -> output_string out "Tvoid"
  | ACtpointer ct ->
    output_string out "(Tpointer ";
    output_ctype out ind ct;
    output_string out ")"
  | ACtarray (n, ct) ->
    output_string out "(Tarray ";
    output_ctype out ind ct;
    output_string out (" " ^ string_of_int n ^ ")")
  | ACtmapping (t1, t2) -> 
     output_string out "(Thashmap ";
     output_ctype out ind t1;
     output_string out " ";
     output_ctype out ind t2;
     output_string out ")"
  | ACtstruct (name, lst) ->
    output_string out ("(Tstruct " ^ struct_name_to_ident name ^ "\n");
    List.iter (fun (fld, ct) ->
      output_string out (ind ^ "(Fcons " ^
        struct_field_name_to_ident name fld ^ " ");
      output_ctype out ("  " ^ ind) ct;
      output_char out '\n'
    ) lst;
    output_string out (ind ^ " Fnil" ^ String.make (List.length lst) ')' ^
      ")")

let type_pair_to_hyper_pair_name i =
  if i.[0] <> 't'
    then
      let _ = print_endline ("Warning: " ^ i ^ " is a type pair but not begin in t")
      in i ^ "_pair"
    else String.sub i 1 (String.length i - 1) ^ "_pair"

let rec get_coq_val_cimpl ind get_var =
  let rec get impl = match impl.aImplDesc with
    | ACdefault -> coqgen_fatal_error __LOC__ "get_coq_val_cimpl"
                     "ACdefault under computation constructs"
    | ACint n -> string_of_int n
    | ACvar v -> get_var ind v
    | ACplus (i1, i2) -> "(" ^ get i1 ^ " + " ^ get i2 ^ ")"
    | ACtimes (i1, i2) -> "(" ^ get i1 ^ " * " ^ get i2 ^ ")"
    | ACcond (b, i1, i2) ->
      "(if " ^ get b ^ " then " ^ get i1 ^ " else " ^ get i2 ^ ")"
    | ACarray _ -> coqgen_fatal_error __LOC__ "get_coq_val_cimpl"
                   "ACarray under computation constructs"
    | ACstruct _ -> coqgen_fatal_error __LOC__ "get_coq_val_cimpl"
                      "ACarray under computation constructs"
  in get

let cimpl_struct_name impl =
 match impl.aImplType with
   | ACtstruct (i, _) -> i
   | _ -> coqgen_fatal_error __LOC__ "output_cval_cimpl"
                 "Structure a_cimpl with non-structural a_ctype"

(* Takes a_cimpl, and outputs a Coq expression which builds an extended C value. *)
let rec output_cval_cimpl out ind out_var get_var =
  let rec output impl = match impl.aImplDesc with
    | ACdefault -> output_string out "CVany"
    | ACint n ->
      output_string out ("(CVval (Values.Vint (Int256.repr " ^ string_of_int n ^ ")))")
    | ACvar v -> out_var out ind v
    | ACplus _ ->
      output_string out ("(CVval (Values.Vint (Int256.repr " ^
        get_coq_val_cimpl ind get_var impl ^ ")))")
    | ACtimes _ ->
      output_string out ("(CVval (Values.Vint (Int256.repr " ^
        get_coq_val_cimpl ind get_var impl ^ ")))")
    | ACcond (b, i1, i2) ->
      output_string out ("(if " ^ get_coq_val_cimpl ind get_var b ^ " then ");
      output i1;
      output_string out " else ";
      output i2;
      output_char out ')'
    | ACarray _ -> output_string out "CVany (* not yet implemented *)" (* ???: how? *)
    | ACstruct ls ->
        match impl.aImplType with
	| ACtstruct (ci, cls) ->
	  output_string out ("\n" ^ ind ^ "(CVstruct (CSmap");
	  List.iter2 (fun (f, i) (cf, _cfTy) ->
	    output_string out ("\n  " ^ ind ^ "(PTree.set  " ^
	      struct_field_name_to_ident ci cf ^ " ");
	    output_char out ' ';
	    output i;
	  ) ls cls;
	  output_string out ("\n  " ^ ind ^ "(@PTree.empty cval)))" ^ String.make (List.length ls) ')')
	| _ -> coqgen_fatal_error __LOC__ "output_cval_cimpl"
                 "Structure a_cimpl with non-structural a_ctype"
  in output

let rec get_coq_val ind f t = match t.aTypeDesc with
  | ATbuiltin _ -> f
  (*
  | ATdata (_, ATsingleton { aTypeConstrImpl = None }) ->
    coqgen_fatal_error __LOC__ "get_coq_val"
      "Provable structure type but constructor with no implementation"
  *)
  | ATdata (_, ATsingleton _) -> f
  | ATdata (_, ATbranches cs) ->
    "(match " ^ f ^ " with\n" ^ ind ^ "| " ^
      String.concat ("\n" ^ ind ^ "| ") (List.map (fun c ->
        let impl = match c.aTypeConstrImpl with
          | Some impl -> impl
          | None -> coqgen_fatal_error __LOC__ "get_coq_val"
                      ("Provable data type with constructor " ^
                       c.aTypeConstrName ^ " with no implementation")
        in c.aTypeConstrName ^ " " ^
             String.concat " " (List.map fst c.aTypeConstrArgs) ^ " => " ^
           get_coq_val_cimpl ind
             (fun ind v -> get_coq_val ind v (List.assoc v c.aTypeConstrArgs))
             impl
      ) cs) ^
    "\n" ^ ind ^ " end)"
  | ATprod (t1, t2) ->
    coqgen_fatal_error __LOC__ "get_coq_val"
      "Requesting encapsulated Coq value for a product type"
  | ATarray (_, t') ->
    coqgen_fatal_error __LOC__ "get_coq_val"
      "Requesting encapsulated Coq value for an array type"
  | ATmapping (_, _) ->
    coqgen_fatal_error __LOC__ "get_coq_val"
      "Requesting encapsulated Coq value for a mapping type"
  | ATlist t' ->
    coqgen_fatal_error __LOC__ "get_coq_val"
      "Requesting encapsulated Coq value for a list type"
  | ATexternal extype ->
    coqgen_fatal_error __LOC__ "get_coq_val"
      ("External type " ^ extype.aEXTypeName ^ " (" ^ extype.aEXTypeString ^
       ") marked as provable")

(* Outputs a coq expression which constructs an extended C value. *)
let output_cval out ind f t = match t.aTypeDesc with
  | ATbuiltin _ ->
    output_string out ("(@ht_cval " ^ t.aTypePairIdent ^ " _ " ^ f ^ ")")
  | ATdata (_, ATsingleton { aTypeConstrImpl = None }) ->
    coqgen_fatal_error __LOC__ "output_cval"
      "Provable structure type but constructor with no implementation"
  | ATdata (_, ATsingleton { aTypeConstrImpl = Some impl; aTypeConstrArgs = args }) ->
    output_cval_cimpl out ind
      (fun out ind v ->
       output_string out ("(@ht_cval " ^ (List.assoc v args).aTypePairIdent ^
         " _ (" ^ v ^ " " ^ f ^ "))"))
      (fun ind v -> get_coq_val ind ("(" ^ v ^ " " ^ f ^ ")") (List.assoc v args))
      impl
  | ATdata (_, ATbranches cs) ->
    output_string out ("(match " ^ f ^ " with");
    List.iter (fun c ->
      let impl = match c.aTypeConstrImpl with
        | Some impl -> impl
        | None -> coqgen_fatal_error __LOC__ "output_cval"
                    ("Provable data type with constructor " ^
                     c.aTypeConstrName ^ " with no implementation") in
      output_string out ("\n" ^ ind ^ "| " ^ c.aTypeConstrName ^ " " ^
        String.concat " " (List.map fst c.aTypeConstrArgs) ^ " => ");
      output_cval_cimpl out ("  " ^ ind)
        (fun out ind v ->
         output_string out ("(@ht_cval " ^
           (List.assoc v c.aTypeConstrArgs).aTypePairIdent ^ " _ " ^ v ^ ")"))
        (fun ind v -> get_coq_val ind v (List.assoc v c.aTypeConstrArgs))
        impl
    ) cs;
    output_string out ("\n" ^ ind ^ "end)")
  | ATprod (t1, t2) as d ->
    let prod_ident = "struct_" ^ a_type_desc_to_ident d in
    output_string out ("(CVstruct\n" ^ ind ^
      "(CFcons " ^ struct_field_name_to_ident prod_ident "fst" ^ " ");
    output_ctype out ("    " ^ ind) t1.aTypeCtype;
    output_char out ' ';
    output_string out ("(@ht_cval " ^ t1.aTypePairIdent ^ " _ (fst " ^ f ^ "))");
    output_string out ("\n  " ^ ind ^
      "(CFcons " ^ struct_field_name_to_ident prod_ident "snd" ^ " ");
    output_ctype out ("    " ^ ind) t2.aTypeCtype;
    output_char out ' ';
    output_string out ("(@ht_cval " ^ t2.aTypePairIdent ^ " _ (snd " ^ f ^ "))");
    output_string out ("\n    " ^ ind ^ "CFnil)))")
  | ATarray (n, t') ->
    output_string out ("(array_cval " ^ t'.aTypePairIdent ^ " " ^ f ^ " " ^
      string_of_int n ^ ")")
  | ATmapping _ ->
     coqgen_warning "Don't know how to output_cval of a mapping";
     output_string out "(* TODO: implement this in output_cval. *)"
  | ATlist t' ->
    coqgen_fatal_error __LOC__ "output_cval"
      ("List type " ^ string_of_a_type false t ^ " marked as provable.")
  | ATexternal extype ->
    coqgen_fatal_error __LOC__ "output_cval"
      ("External type " ^ extype.aEXTypeName ^ " (" ^ extype.aEXTypeString ^
       ") marked as provable")

(* Given f (a string containing the name of a coq variable) and t (a type),
   output a Coq expression saying that f satisfies the ft_cond.
 *)
let output_ft_cond out ind f t =
  let rec output ind f t lvl = match t.aTypeDesc with
    | ATbuiltin _ ->
      output_string out ("(@ht_ft_cond " ^ t.aTypePairIdent ^ " _ " ^ f ^ ")")
    | ATdata (_, _) | ATprod (_, _) | ATarray (_, _) when lvl <> 0 ->
      output_string out ("(@ht_ft_cond " ^ t.aTypePairIdent ^ " _ " ^ f ^ ")")

    | ATdata (_, ATsingleton c) ->
      output_constr ind (fun fld -> "(" ^ fld ^ " " ^ f ^ ")") c lvl
    | ATdata (_, ATbranches cs) ->
      output_string out ("match " ^ f ^ " with");
      List.iter (fun c ->
        output_string out ("\n" ^ ind ^ "| " ^ c.aTypeConstrName ^ " " ^
          String.concat " " (List.map fst c.aTypeConstrArgs) ^ " => ");
        output_constr ("  " ^ ind) (fun fld -> fld) c lvl
      ) cs;
      output_string out ("\n" ^ ind ^ "end")
    | ATprod (t1, t2) ->
      (*output_char out '(';*)
      output ind ("(fst " ^ f ^ ")") t1 (lvl + 1);
      output_string out " /\\ ";
      output ind ("(snd " ^ f ^ ")") t2 (lvl + 1);
      (*output_char out ')'*)
    | ATarray (n, t') ->
      let var = "n" ^ string_of_int lvl in
      output_string out ("(forall " ^ var ^ ", 0 <= " ^ var ^ " < " ^
        string_of_int n ^ " ->\n" ^ ind);
      output ("  " ^ ind) ("(ZMap.get " ^ var ^ " " ^ f ^ ")") t' (lvl + 1);
      output_char out ')'
    | ATmapping _ ->
       coqgen_warning "Don't know how to output_ft_cond of a mapping";
       output_string out "True (* TODO: implement this in output_ft_cond. *)"
    | ATlist _ ->
      coqgen_fatal_error __LOC__ "output_ft_cond"
        ("External type " ^ string_of_a_type false t ^ " marked as provable")
    | ATexternal extype ->
      coqgen_fatal_error __LOC__ "output_ft_cond"
        ("External type " ^ extype.aEXTypeName ^ " (" ^ extype.aEXTypeString ^
         ") marked as provable")
  and output_constr ind get_field c lvl = match c.aTypeConstrArgs with
    | [] -> output_string out "True"
    | args ->
      let first = ref true in
      List.iter (fun (i, t') ->
        if !first
          then first := false
          else output_string out ("\n" ^ ind ^ "/\\ ");
        output ("  " ^ ind) (get_field i) t' (lvl + 1)
      ) args
  in output ind f t 0

(* Outputs a desugared value of type t. *)
let output_default out ind t =
  let rec output ind t lvl =  match t.aTypeDesc with
    | ATbuiltin _ ->
      output_string out ("(@ht_default " ^ t.aTypePairIdent ^ " _)")
    | ATdata (_, _) | ATprod (_, _) | ATarray (_, _) when lvl <> 0 ->
      output_string out ("(@ht_default " ^ t.aTypePairIdent ^ " _)")

    | ATdata (_, ATsingleton c) ->
      let record_field_leftover = ref "{| " in
      List.iter (fun (i, t') ->
        output_string out (!record_field_leftover ^ i ^ " := ");
        record_field_leftover := ";\n   " ^ ind;
        output ("     " ^ ind) t' (lvl + 1);
      ) c.aTypeConstrArgs;
      output_string out ("\n" ^ ind ^ "|}")
    | ATdata (_, ATbranches ls) ->
      let c = try
          (* 1. find a constructor with [a_cimpl] being [ACdefault] *)
          List.find (function
              { aTypeConstrImpl = Some { aImplDesc = ACdefault } } -> true
            | _ -> false) ls
        with Not_found -> try
          (* 2. find a constructor with no arguments *)
          List.find (function { aTypeConstrArgs = [] } -> true | _ -> false) ls
        with Not_found ->
          (* 3. we tried our best, now just use an arbitrary one *)
          List.hd ls
      in if c.aTypeConstrArgs <> [] then output_char out '(';
         output_string out c.aTypeConstrName;
         List.iter (fun (_, t') ->
           output_char out ' ';
           output ("  " ^ ind) t' (lvl + 1)) c.aTypeConstrArgs;
         if c.aTypeConstrArgs <> [] then output_char out ')'
    | ATprod (t1, t2) ->
      output_char out '(';
      output ind t1 (lvl + 1);
      output_string out ", ";
      output ind t2 (lvl + 1);
      output_char out ')';
    | ATarray (_, t') ->
      output_string out "(ZMap.init ";
      output ind t' (lvl + 1);
      output_char out ')'
    | ATmapping _ -> 
      output_string out ("(@ht_default " ^ t.aTypePairIdent ^ " _)")
    | ATlist _ ->
       output_string out "nil"
    | ATexternal ({ aEXTypeDefault = None } as extype) ->
      coqgen_fatal_error __LOC__ "output_default"
        ("External type " ^ extype.aEXTypeName ^ " (" ^ extype.aEXTypeString ^
         ") has no default value")
    | ATexternal { aEXTypeDefault = Some (s, _) } ->
      output_string out s
  in output ind t 0

(* note: the "valid_ft_cond" intuitively says that a value is not the default value. *)
let output_valid_ft_cond out ind f t =
  let rec output ind f t lvl = match t.aTypeDesc with
    | ATbuiltin _ ->
      output_string out ("@ht_valid_ft_cond " ^ t.aTypePairIdent ^ " _ " ^ f ^ "")
    | ATdata (_, _) | ATprod (_, _) | ATarray (_, _) when lvl <> 0 ->
      output_string out ("@ht_valid_ft_cond " ^ t.aTypePairIdent ^ " _ " ^ f ^ "")

    | ATdata (_, ATsingleton c) ->
      output_constr ind (fun fld -> "(" ^ fld ^ " " ^ f ^ ")") c lvl
    | ATdata (_, ATbranches cs) ->
      output_string out ("match " ^ f ^ " with");
      List.iter (fun c ->
        output_string out ("\n" ^ ind ^ "| " ^ c.aTypeConstrName ^ " " ^
          String.concat " " (List.map fst c.aTypeConstrArgs) ^ " => ");
        match c.aTypeConstrImpl with
        | Some { aImplDesc = ACdefault } -> output_string out "False"
        | Some _ -> output_constr ("  " ^ ind) (fun fld -> fld) c lvl
        | None -> coqgen_fatal_error __LOC__ "output_valid_ft_cond"
                    ("Provable data type with constructor " ^
                     c.aTypeConstrName ^ " with no implementation")
      ) cs;
      output_string out ("\n" ^ ind ^ "end")
    | ATprod (t1, t2) ->
      (*output_char out '(';*)
      output ind ("(fst " ^ f ^ ")") t1 (lvl + 1);
      output_string out " /\\ ";
      output ind ("(snd " ^ f ^ ")") t2 (lvl + 1);
      (*output_char out ')'*)
    | ATarray (n, t') ->
      let var = "n" ^ string_of_int lvl in
      output_string out ("(forall " ^ var ^ ", 0 <= " ^ var ^ " < " ^
        string_of_int n ^ " ->\n" ^ ind);
      output ("  " ^ ind) ("(ZMap.get " ^ var ^ " " ^ f ^ ")") t' (lvl + 1);
      output_char out ')'
    | ATmapping _ ->
       coqgen_warning "Don't know how to output_valid_ft_cond of a mapping";
       output_string out "True (* TODO: implement this in output_ft_cond. *)"
    | ATlist t' ->
      coqgen_fatal_error __LOC__ "output_valid_ft_cond"
        ("List type " ^ string_of_a_type false t  ^ " marked as provable")
    | ATexternal extype ->
      coqgen_fatal_error __LOC__ "output_valid_ft_cond"
        ("External type " ^ extype.aEXTypeName ^ " (" ^ extype.aEXTypeString ^
         ") marked as provable")
  and output_constr ind get_field c lvl = match c.aTypeConstrArgs with
    | [] -> output_string out "True"
    | args ->
      let first = ref true in
      List.iter (fun (i, t') ->
        if !first
          then first := false
          else output_string out ("\n" ^ ind ^ "/\\ ");
        output ("  " ^ ind) (get_field i) t' (lvl + 1)
      ) args
  in output ind f t 0

(* A type needs an injection if it contains a an imported external type which has a nontrivial injection.
   (Concretely, we need an injection if the type contains a pointer somewhere. Flatmem and val (raw compcert values)
   are the most important examples.)
   *)
let need_injection =
  let rec type_f t = match t.aTypeDesc with
    | ATbuiltin _ -> false
    | ATdata (_, ATsingleton c) -> constr_f c
    | ATdata (_, ATbranches cs) -> List.exists constr_f cs
    | ATprod (t1, t2) -> type_f t1 || type_f t2
    | ATarray (_, t') -> type_f t'
    | ATmapping (_, t') -> type_f t'
    | ATlist t -> type_f t
    | ATexternal { aEXTypeLowLevelInv = None } -> false
    | ATexternal { aEXTypeLowLevelInv = Some _ } -> true
  and constr_f c =
    List.exists (fun (_, t) -> type_f t) c.aTypeConstrArgs
  in type_f

(* If the type needs an injection, output one. Otherwise, use Coq equality. *)
let output_ht_inject out ind a b t =
  let output a b t = output_string out
        ("@ht_inject " ^ t.aTypePairIdent ^ " _ j " ^ a ^ " " ^ b) in
  let output_constr ind get_field a b c = match c.aTypeConstrArgs with
    | [] -> output_string out "True"
    | args ->
      let first = ref true in
      List.iter (fun (i, t') ->
        if !first
          then first := false
          else output_string out ("\n" ^ ind ^ "/\\ ");
        output (get_field a i) (get_field b i) t'
      ) args in

  if not (need_injection t) then
    output_string out (a ^ " = " ^ b)
  else match t.aTypeDesc with
  | ATdata (_, ATsingleton c) ->
    output_constr ind (fun f fld -> "(" ^ fld ^ " " ^ f ^ ")") a b c
  | ATdata (_, ATbranches cs) ->
    output_string out ("match " ^ a ^ ", " ^ b ^ " with");
    List.iter (fun c ->
      output_string out ("\n" ^ ind ^ "| " ^ c.aTypeConstrName ^ " " ^
        String.concat " " (List.map (fun (i, _) -> a ^ "_" ^ i) c.aTypeConstrArgs) ^
        ", " ^ c.aTypeConstrName ^ " " ^
        String.concat " " (List.map (fun (i, _) -> b ^ "_" ^ i) c.aTypeConstrArgs) ^
        " => ");
      output_constr ("  " ^ ind) (fun f fld -> f ^ "_" ^ fld) a b c
    ) cs;
    if List.length cs > 0 then
      output_string out ("\n" ^ ind ^ "| _, _ => False");
    output_string out ("\n" ^ ind ^ "end")
  | ATprod (t1, t2) ->
    output ("(fst " ^ a ^ ")") ("(fst " ^ b ^ ")") t1;
    output_string out " /\\ ";
    output ("(snd " ^ a ^ ")") ("(snd " ^ b ^ ")") t2;
  | ATarray (n, t') ->
    output_string out ("forall n, (* 0 <= n < " ^ string_of_int n ^ " -> *)\n" ^ ind);
    output ("(ZMap.get n " ^ a ^ ")") ("(ZMap.get n " ^ b ^ ")") t';
  | ATexternal { aEXTypeLowLevelInv = None } ->
    output_string out (a ^ " = " ^ b)
  | ATexternal { aEXTypeLowLevelInv = Some s } ->
    output_string out (s ^ " j " ^ a ^ " " ^ b)

  | _ -> output a b t

let output_valid_ft_ocond out ind t =
  let output t = output_string out
        ("(@ht_valid_ft_ocond " ^ t.aTypePairIdent ^ " _)") in
  let output_constr ind c = match c.aTypeConstrArgs with
    | [] -> output_string out "otrue1"
    | args ->
      let first = ref true in
      List.iter (fun (i, t') ->
        if !first
          then first := false
          else output_string out ("\n" ^ ind ^ "/\\ ");
        output t';
        output_string out (" m{ " ^ i ^ " }")
      ) args in

  match t.aTypeDesc with
  | ATdata (_, ATsingleton c) ->
    output_string out ("(\n" ^ ind);
    output_constr ind c;
    output_string out ")%oprop1";
  | ATdata (_, ATbranches cs) ->
    output_string out "oprop1 (fun f => ";
    output_valid_ft_cond out ("  " ^ ind) "f" t;
    output_char out ')'
    (*
    output_string out "(*XXX*) otrue1"
    *)
    (*
    output_string out ("match " ^ a ^ ", " ^ b ^ " with");
    List.iter (fun c ->
      output_string out ("\n" ^ ind ^ "| " ^ c.aTypeConstrName ^ " " ^
        String.concat " " (List.map (fun (i, _) -> a ^ "_" ^ i) c.aTypeConstrArgs) ^
        ", " ^ c.aTypeConstrName ^ " " ^
        String.concat " " (List.map (fun (i, _) -> b ^ "_" ^ i) c.aTypeConstrArgs) ^
        " => ");
      output_constr ("  " ^ ind) (fun f fld -> f ^ "_" ^ fld) a b c
    ) cs;
    if List.length cs > 0 then
      output_string out ("\n" ^ ind ^ "| _, _ => False");
    output_string out ("\n" ^ ind ^ "end")
    *)
  | ATprod (t1, t2) ->
    output_char out '(';
    output t1;
    output_string out " m{ fst } /\\ ";
    output t2;
    output_string out " m{ snd })%oprop1"
  | ATarray (n, t') ->
    output_string out ("omap1 (fun p f => forall n, 0 <= n < " ^
        string_of_int n ^ " -> p (ZMap.get n f))\n" ^ ind);
    output t'
  | ATexternal _ ->
    output_string out "otrue1"

  | _ -> output t
(*
let output_valid_opt out ind f t =
  let rec output ind f t lvl = match t.aTypeDesc with
    | ATbuiltin _ ->
      output_string out ("(@ht_valid_opt " ^ t.aTypePairIdent ^ " _ " ^ f ^ ")")
    | ATdata (_, _) when lvl <> 0 ->
      output_string out ("(@ht_valid_opt " ^ t.aTypePairIdent ^ " _ " ^ f ^ ")")

    | ATdata (_, ATsingleton c) ->
      output_string out "fun r k => ";
      output_constr ind (fun fld -> "(" ^ fld ^ " " ^ f ^ ")") c lvl
    | ATdata (_, ATbranches cs) ->
      output_string out ("fun r k => match " ^ f ^ " with");
      List.iter (fun c ->
        output_string out ("\n" ^ ind ^ "| " ^ c.aTypeConstrName ^ " " ^
          String.concat " " (List.map fst c.aTypeConstrArgs) ^ " => ");
        match c.aTypeConstrImpl with
        | Some { aImplDesc = ACdefault } -> output_string out "None"
        | Some _ -> output_constr ("  " ^ ind) (fun fld -> fld) c lvl
        | None -> coqgen_fatal_error __LOC__ "output_valid_opt"
                    ("Provable data type with constructor " ^
                     c.aTypeConstrName ^ " with no implementation")
      ) cs;
      output_string out ("\n" ^ ind ^ "end")
    | ATprod (t1, t2) ->
      output_string out "(Cbind ";
      output ind ("(fst " ^ f ^ ")") t1 (lvl + 1);
      output_string out ("\n" ^ ind ^ "(fun _ => ");
      output ind ("(snd " ^ f ^ ")") t2 (lvl + 1);
      output_string out "))"
    | ATarray (n, t') ->
      let var = "n" ^ string_of_int lvl in
      output_string out ("Citer " ^ string_of_int n ^
        " (fun " ^ var ^ " => ");
      output ("  " ^ ind) ("(ZMap.get " ^ var ^ " " ^ f ^ ")") t' (lvl + 1);
      output_char out ')'
  and output_constr ind get_field c lvl = match c.aTypeConstrArgs with
    | [] -> output_string out "k tt"
    | args ->
      let first = ref true in
      List.iter (fun (i, t') ->
        if !first
          then first := false
          else output_string out ("\n" ^ ind ^ "_ (fun _ => ");
        output ("  " ^ ind) (get_field i) t' (lvl + 1)
      ) args;
      output_string out ("\n" ^ ind ^ "_ k" ^ String.make (List.length args - 1) ')')
  in output ind f t 0
*)

(* A "path" is a list of numbers which identifies a particular subexpression of a top-level method definition.
  (The numbers correspond to e.g. the different clauses in a match-expression.)
  We print such a path as e.g. "0_0_12", for use in names of definitions. *)
let rec string_of_path path = match path with
  | []     -> ""
  | [x]    -> string_of_int x
  | (x::p) -> string_of_int x ^ "_" ^ string_of_path p

(* Create a gallina expression of a given type. *)
let rec dummy_value_gallina t =
  match t.aTypeDesc with
  | ATbuiltin Tint -> "0"
  | ATbuiltin Tuint -> "Int256.zero"
  | ATbuiltin Tbool -> "true"
  | ATbuiltin Tunit ->  "tt"
  | ATdata (_, ATsingleton c)
  | ATdata (_, ATbranches (c::_)) ->
     (* If we start supporting properly recursive datatypes this could lead to infinite loops. *)
     "(" ^ c.aTypeConstrName ^ " " ^ (String.concat " " (List.map (fun (_,t') -> dummy_value_gallina t') c.aTypeConstrArgs)) ^ ")"
  | ATprod (t1, t2) -> "(" ^ dummy_value_gallina t1 ^ ", " ^ dummy_value_gallina t2 ^ ")"
  | _ -> "tt (*xxx dummy value not implemented*)"

let output_hyper_type_impl out t =
  let _ = output_string out ("Global Instance " ^ t.aTypePairIdent ^
    "_hyper_type_impl : HyperTypeImpl "  ^ t.aTypePairIdent ^ " :=") in
  let _ = match t.aTypeDesc, t.aTypeProvable with
    | ATarray (n, t'), _ ->       
        output_string out ("
  ZMap_based_array_hyper_type_impl " ^ t'.aTypePairIdent ^ " " ^ string_of_int n ^ ".\n")
    | ATmapping ({aTypeDesc = ATbuiltin t_index}, t'), _
      when t_index = Tuint || t_index = Taddress ->
        output_string out ("
   Int256Tree_based_hashmap_hyper_type_impl " ^ t'.aTypePairIdent ^ ".\n")
    | ATmapping _, _ ->
            coqgen_fatal_error __LOC__ "output_hyper_type_impl" "mapping keys of types other than 'uint' or 'address' are currently unsupported."
    | _, false ->
      output_string out " {
  ht_cval := fun _ => CVany;
  ht_ft_cond := fun _ => True;
  ht_default := ";
      output_default out "    " t;
      output_string out ";
  ht_valid_ft_cond := fun _ => True;
  ht_valid_ft_ocond := otrue1;";
      output_string out "\n}.\n"
    | _, true ->
      output_string out " {\n";
      (* XXX refactor the five calls? *)
      output_string out "  ht_cval f := ";
      output_cval out "    " "f" t;
      output_string out ";\n  ht_ft_cond f := ";
      output_ft_cond out "    " "f" t;
      output_string out ";\n  ht_default := ";
      output_default out "    " t;
      output_string out ";\n  ht_valid_ft_cond f := ";
      output_valid_ft_cond out "    " "f" t;
      output_string out ";\n  ht_valid_ft_ocond := ";
      output_valid_ft_ocond out "    " t;
      (*
      output_string out ";\n  ht_inject j a b := ";
      output_ht_inject out "    " "a" "b" t;
      output_string out ";\n  ht_valid_opt f := ";
      output_valid_opt out "    " "f" t
      *)
      output_string out "\n}.\n"
  in output_string out ("Definition " ^
       type_pair_to_hyper_pair_name t.aTypePairIdent ^
       " := mk_hyper_type_pair " ^ t.aTypePairIdent ^ ".\n")

let output_hyper_type out t =
  if t.aTypeProvable then begin
    output_string out ( "Global Instance " ^ t.aTypePairIdent ^
      "_hyper_type : HyperType "  ^ t.aTypePairIdent);
    match t.aTypeDesc with
    | ATbuiltin _ -> output_string out " := _.\n"
    | ATdata _ | ATprod _ ->
      output_string out (".
Proof. solve_algebraic_record_data_type_hyper_type " ^ t.aTypePairIdent ^
        "_hyper_type_impl. Qed.\n")
    | ATarray (n, t') ->
        output_string out (" :=
  ZMap_based_array_hyper_type " ^ t'.aTypePairIdent ^ " " ^ string_of_int n ^ ".\n")
    | ATmapping (t1, t2)  ->
       if not (t1.aTypeDesc = ATbuiltin Tuint || t1.aTypeDesc = ATbuiltin Taddress) then
       coqgen_fatal_error __LOC__ "output_hyper_type"
			    ("Currently only mappings keyed on uintegers or addresses are supported, but this mapping is keyed on " ^ (string_of_a_type false t1) ^ ".")	 
       else
         output_string out (" :=
  Int256Tree_based_hashmap_hyper_type " ^ t2.aTypePairIdent ^ ".\n")
    | ATlist t' ->
      coqgen_fatal_error __LOC__ "output_hyper_type"
        ("list type " ^ string_of_a_type false t ^ " marked as provable")
    | ATexternal extype ->
      coqgen_fatal_error __LOC__ "output_hyper_type"
        ("External type " ^ extype.aEXTypeName ^ " (" ^ extype.aEXTypeString ^
         ") marked as provable")
  end  (* [if] t.aTypeProvable *)

let output_type_naturally_aligned out t =
  match t.aTypeDesc with
      | ATdata (i, _) ->
         output_string out ("Lemma  " ^ t.aTypePairIdent
				    ^ "_naturally_aligned : naturally_aligned (unpair_ty "
				    ^ t.aTypePairIdent ^").\n"
				    ^ "Proof. reflexivity. Qed.\n")
      | _ -> ()


let output_hyper_binary_impl_eq out t =
  let output_eq_expression t a b tt ff =
#ifdef REDACTED
    () in
#else
    output_string out
    ("(* XXX(output_hyper_binary_impl_eq:output_eq_expression) *) " ^ ff) in
    (*
    match a, b with
  | MMUsable, MMUsable => k true
  | MMResv, MMResv => k true
  | _, _ => k false
  end

match a, b with
  | MMUsable, MMUsable => true
  | MMResv, MMResv => true
  | _, _ => false
  end;
  *)
#endif

  match t.aTypeCtype with
  | ACtstruct _ | ACtarray _ | ACtmapping _ -> ()
  | _ ->
    output_string out ("Global Instance " ^ t.aTypePairIdent ^
      "_hyper_binary_impl_eq : HyperBinaryImpl Oeq "  ^ t.aTypePairIdent ^
      " " ^ t.aTypePairIdent ^ " tint_bool := {
  Hbinary_cond := fun _ _ => True;
  Hbinary_ocond := otrue2;
  Hbinary a b := ");
    output_eq_expression t "a" "b" "true" "false";
    output_string out "\n}.\n"

let output_record_hyper_field_impl out struct_type_pair_ident s f ft
                            offset output_get output_set =
  output_string out ("Global Instance " ^ struct_type_pair_ident ^
    "_" ^ f ^ "_field_impl : HyperFieldImpl " ^ struct_type_pair_ident ^ " " ^
    ft.aTypePairIdent ^ " " ^ struct_field_name_to_ident s f ^ " := {
  Hfield_get s := ");
  output_get out "s"; (* fst s *)
  output_string out ";\n  Hfield_set v s := ";
  output_set out "v" "s"; (* (v, snd s) *)
  (*
  output_string out ";\n  Hfield_get_opt s := Csome (";
  output_get out "s"; (* fst s *)
  output_string out ");\n  Hfield_set_opt v s := Csome (";
  output_set out "v" "s"; (* (v, snd s) *)
  output_string out ")
}.\n"
  *)
  output_string out "
}.\n"

let output_twobranch_hyper_field_impl out t s cs f ft cf
                                      offset valid_branch default_branch  =
  output_string out ("Global Instance " ^ t.aTypePairIdent ^
    "_" ^ f ^ "_field_impl : HyperFieldImpl " ^ t.aTypePairIdent ^ " " ^
    ft.aTypePairIdent ^ " " ^ struct_field_name_to_ident cs cf ^ " := {
  Hfield_get s := match s with \n");   (* TODO: generate fresh names instead of just "s" and "v". *)
  output_string out ("                    | "
		     ^ valid_branch.aTypeConstrName ^ " ");
  List.iter (fun (f', _) ->
	       output_string out (f' ^ " "))
	    valid_branch.aTypeConstrArgs;
  output_string out (" => " ^ f ^ "\n");
  output_string out ("                    | "
		     ^ default_branch.aTypeConstrName ^ " => "
		     ^ dummy_value_gallina ft ^"\n");
  output_string out "                  end";
  output_string out ";\n  Hfield_set v s := match s with \n";
  output_string out ("                      | "
		     ^ valid_branch.aTypeConstrName ^ " ");
  List.iter (fun (f', _) ->
	       output_string out (f' ^ " "))
	    valid_branch.aTypeConstrArgs;
  output_string out (" => " ^ valid_branch.aTypeConstrName ^ " ");
  List.iter (fun (f', _) ->
	     if (f'<>f)
	       then output_string out (f' ^ " ")
	       else output_string out ("v "))
	    valid_branch.aTypeConstrArgs;
  output_string out ("\n                      | "
		     ^ default_branch.aTypeConstrName ^ " => "
		     ^ default_branch.aTypeConstrName ^"\n");
  output_string out ("                    end\n");
  output_string out "
}.\n"

let output_record_hyper_field out struct_t s  f t =
  if struct_t.aTypeProvable then
    output_string out ("Global Instance " ^ struct_t.aTypePairIdent ^
      "_" ^ f ^ "_field : HyperField " ^
      struct_t.aTypePairIdent ^ " " ^
      t.aTypePairIdent ^ " " ^ struct_field_name_to_ident s f ^ ".
Proof. Admitted. \n")

let output_twobranch_hyper_field out struct_t s cs f cf t =
  if struct_t.aTypeProvable then
    output_string out ("Global Instance " ^ struct_t.aTypePairIdent ^
      "_" ^ f ^ "_field : HyperField " ^
      struct_t.aTypePairIdent ^ " " ^
      t.aTypePairIdent ^ " " ^ struct_field_name_to_ident cs cf ^ ".
Proof. solve_twobranch_type_hyper_field. Admitted.\n")

(*		  
let output_record_hyper_field_passthrough out t s f ft =
  output_string out ("Global Instance " ^ t.aTypePairIdent ^
    "_" ^ f ^ "_field_passthrough : HyperFieldPassthrough " ^
    t.aTypePairIdent ^ " " ^
    ft.aTypePairIdent ^ " " ^ struct_field_name_to_ident s f ^ ".
Proof. esplit; simpl;
  solve [
    intros; subst; congruence
  | intros ? ? ? ? ? ? []; auto
  | intros ? ? ? []; auto ].
Qed.\n")

let output_twobranch_hyper_field_passthrough out t s cs f cf ft =
  output_string out ("Global Instance " ^ t.aTypePairIdent ^
    "_" ^ f ^ "_field_passthrough : HyperFieldPassthrough " ^
    t.aTypePairIdent ^ " " ^
    ft.aTypePairIdent ^ " " ^ struct_field_name_to_ident cs cf ^ ".
Proof. esplit; [intros j a b | intros j av a bv b]; destruct a, b; congruence. Qed.
")
 *)

let output_hyper_index_impl out array_type_pair_ident n t' =
  output_string out ("Global Instance " ^ array_type_pair_ident ^
    "_index_impl : HyperIndexImpl " ^ array_type_pair_ident ^ " " ^ t'.aTypePairIdent ^ " :=");
    output_string out ("
  ZMap_based_array_hyper_index_impl " ^ t'.aTypePairIdent ^ " " ^ string_of_int n ^ ".\n")
  (*
  output_string out ("Global Instance " ^ array_type_pair_ident ^
    "_index_impl : HyperIndexImpl " ^ array_type_pair_ident ^ " " ^
    t'.aTypePairIdent ^ " := {
  Hindex_size := " ^ string_of_int n ^ ";
  Hindex_get idx ar := ZMap.get idx ar;
  Hindex_set idx elem ar := ZMap.set idx elem ar
}.\n")
  *)
  (*;
  Hindex_get_opt idx ar := Csome (ZMap.get idx ar);
  Hindex_set_opt idx elem ar := fun r k =>
    if zle 0 idx && zlt idx " ^ string_of_int n ^ " then k (ZMap.set idx elem ar) else None
  *)

let output_hyper_index out array_t n t' =
  if array_t.aTypeProvable then begin
    output_string out ("Global Instance " ^ array_t.aTypePairIdent ^
      "_index : HyperIndex " ^ array_t.aTypePairIdent ^ " " ^ t'.aTypePairIdent ^ " :=");
      output_string out ("
  ZMap_based_array_hyper_index " ^ t'.aTypePairIdent ^ " " ^ string_of_int n ^ ".\n")
  end  (* [if] array_t.aTypeProvable *)

let output_hyper_hash_impl out type_pair_ident t1 t2 =
  output_string out ("Global Instance " ^ type_pair_ident ^
		       "_index_impl : HyperIntHashImpl " ^ type_pair_ident ^ " " ^ t2.aTypePairIdent ^ " :=");
  if not (t1.aTypeDesc = ATbuiltin Tuint || t1.aTypeDesc = ATbuiltin Taddress) then
       coqgen_fatal_error __LOC__ "output_hyper_type"
			    ("Currently only mappings keyed on uintegers or addresses are supported.")  
  else
        output_string out ("
  Int256Tree_based_hashmap_hash_impl " ^ t2.aTypePairIdent ^ ".\n")

let output_hyper_hash out type_pair_ident t1 t2 =
  output_string out ("Global Instance " ^ type_pair_ident ^
		       "_hash : HyperIntHash " ^ type_pair_ident ^ " " ^ t2.aTypePairIdent ^ " :=");
  if not(t1.aTypeDesc = ATbuiltin Tuint || t1.aTypeDesc = ATbuiltin Taddress) then
       coqgen_fatal_error __LOC__ "output_hyper_type"
			    ("Currently only mappings keyed on uintegers or addresses are supported.")  
  else
        output_string out ("
  Int256Tree_based_hashmap_hash " ^ t2.aTypePairIdent ^ ".\n")
		  
let output_hyper_index_passthrough out array_type_pair_ident n t' =
  output_string out ("Global Instance " ^ array_type_pair_ident ^
    "_index_passthrough : HyperIndexPassthrough " ^ array_type_pair_ident ^ " " ^
    t'.aTypePairIdent ^ " :=
  ZMap_based_array_hyper_index_passthrough " ^ t'.aTypePairIdent ^ " " ^ string_of_int n ^ ".\n")
  (*
  output_string out ("Global Instance " ^ array_type_pair_ident ^
    "_index_passthrough : HyperIndexPassthrough " ^ array_type_pair_ident ^ " " ^
    t'.aTypePairIdent ^ ".
Proof. esplit; simpl; congruence. Qed.\n")
  *)

(* Take an environment env, a name of a type i, and the description of the type t, output all necessary definitions for the type.
   (Naming convention: This function opens the output channels itself, so it's called gen_ instead of output_.)
 *)
let gen_type env i t =
  let type_out = env.coq_DataTypes in
  let ops_out = env.coq_DataTypeOps in
  match t.aTypeDesc with
  | ATdata (i', _) when i <> i' ->
    output_string type_out ("\nDefinition " ^ i ^ " := " ^ i' ^ ".\n")
  | _ as d when i <> a_type_desc_to_ident d ->
    output_string type_out ("\nDefinition " ^ i ^ " := ");
    output_type_expr type_out "  " t;
    output_string type_out (".\n")
  | _ ->
    let _ = (* (Coq) data type definition *)
      output_char type_out '\n';
      match t.aTypeDesc with
      | ATdata (_, ATsingleton c) -> gen_struct_type env i c
      | ATdata (_, ATbranches cs) -> gen_data_type env i cs
      | _ ->
        output_string type_out ("Definition " ^ i ^ " := ");
        output_type_expr type_out "  " t;
        output_string type_out (".\n") in
    let _ = (* Type pair notation *)
      output_prepare_ctype env ops_out t.aTypeCtype;
      output_string ops_out ("Definition " ^ t.aTypePairIdent ^
        " := (Tpair " ^ i ^ " ");
      output_ctype ops_out "  " t.aTypeCtype;
      output_string ops_out ").\n" in
    let _ = (* [HyperTypeImpl] and [HyperBinaryImpl Oeq] *)
      output_hyper_type_impl ops_out t;
      output_hyper_type ops_out t;
      output_hyper_binary_impl_eq ops_out t in
    (* let _ = (* naturally_aligned *)
      output_type_naturally_aligned ops_out t in *)
    let _ = (* [HyperFieldImpl] and [HyperIndexImpl] *)
      match t.aTypeDesc with
      | ATprod (t1, t2) as d ->
        output_cstruct_ident env
          (struct_field_name_to_ident ("struct_" ^ a_type_desc_to_ident d) "fst");
        output_record_hyper_field_impl
          ops_out t.aTypePairIdent
          ("struct_" ^ a_type_desc_to_ident d) "fst" t1 0
          (fun out s -> output_string out ("fst " ^ s))
          (fun out v s -> output_string out ("(" ^ v ^ ", snd " ^ s ^ ")"));
        output_record_hyper_field
          ops_out t ("struct_" ^ a_type_desc_to_ident d) "fst" t1;
(*        output_record_hyper_field_passthrough
          ops_out t
          ("struct_" ^ a_type_desc_to_ident d) "fst" t1; *)
        output_cstruct_ident env
          (struct_field_name_to_ident ("struct_" ^ a_type_desc_to_ident d) "snd");
        output_record_hyper_field_impl
          ops_out t.aTypePairIdent
          ("struct_" ^ a_type_desc_to_ident d) "snd" t2
          1 (* (calign (csizeof t1.aTypeCtype) (calignof t2.aTypeCtype)) *)
          (fun out s -> output_string out ("snd " ^ s))
          (fun out v s -> output_string out ("(fst " ^ s ^ ", " ^ v ^ ")"));
        output_record_hyper_field
          ops_out t ("struct_" ^ a_type_desc_to_ident d) "snd" t2;
(*        output_record_hyper_field_passthrough
          ops_out t
          ("struct_" ^ a_type_desc_to_ident d) "snd" t2 *)
      | ATdata (i, ATsingleton c) ->
        let pos = ref 0 in
        List.iter (fun (f, ft) ->
            (*let offset = calign !pos (calignof ft.aTypeCtype) in *)
          output_cstruct_ident env (struct_field_name_to_ident i f);
          output_record_hyper_field_impl ops_out t.aTypePairIdent i f ft !pos(*offset*)
            (fun out s -> output_string out (f ^ " " ^ s))
            (fun out v s ->
              output_string out c.aTypeConstrName;
              List.iter (fun (f', _) ->
                if f' = f
                  then output_string out (" " ^ v)
                  else output_string out (" (" ^ f' ^ " " ^ s ^ ")")
              ) c.aTypeConstrArgs);
          output_record_hyper_field ops_out t i f ft;
          (* output_record_hyper_field_passthrough ops_out t i f ft; *)
          pos := !pos + 1 (*offset + csizeof ft.aTypeCtype*)
        ) c.aTypeConstrArgs
      | ATdata (i, ATbranches [{ aTypeConstrImpl = Some {aImplDesc= ACdefault}} as cd;
			       { aTypeConstrImpl = Some ({aImplDesc=ACstruct cs} as impl)} as c])
      | ATdata (i, ATbranches [{ aTypeConstrImpl = Some ({aImplDesc=ACstruct cs}  as impl)} as c ;
			       { aTypeConstrImpl = Some {aImplDesc = ACdefault}} as cd]) ->
        let pos = ref 0 in
        List.iter2 (fun (f, ft) (cf, _cfimpl) ->
	  let offset = calign !pos (calignof ft.aTypeCtype) in
	  let ci = cimpl_struct_name impl in
          output_cstruct_ident env (struct_field_name_to_ident ci cf);
          output_twobranch_hyper_field_impl ops_out t i ci f ft cf offset c cd;
          output_twobranch_hyper_field ops_out t i ci f cf ft;
          (* output_twobranch_hyper_field_passthrough ops_out t i ci f cf ft; *)
          pos := offset + csizeof ft.aTypeCtype
        ) c.aTypeConstrArgs cs
      | ATarray (n, t') ->
        output_hyper_index_impl ops_out t.aTypePairIdent n t';
        output_hyper_index ops_out t n t';
      | ATmapping (t1, t2) ->
         output_hyper_hash_impl ops_out t.aTypePairIdent t1 t2;
         output_hyper_hash ops_out t.aTypePairIdent t1 t2;
      | _ -> ()
    in ()

let gen_type_arg_ret env t =
  (* Note: this is an example of how incremental files are used. If it already contained a definition, we don't write a new one. *)
  if not (Hashtbl.mem env.arg_ret_idents t.aTypePairIdent) then begin
    Hashtbl.add env.arg_ret_idents t.aTypePairIdent ("HyperArgRet " ^ t.aTypePairIdent);
    output_string env.coq_DataTypeProofs (
#ifdef REDACTED
      "")
#else
    "
(* (* commented out because the Ethereum backend doesn't do any proofs. *)
Global Instance " ^ t.aTypePairIdent ^ "_hyper_arg_ret : HyperArgRet " ^ t.aTypePairIdent ^ ".
Proof. esplit.
  - (* ht_basic *) admit.
  - (* ht_cast_ident *) admit.
  - (* ht_injective *) admit.
  - (* ht_inject_refl *) admit.
  - (* ht_has_type *) admit.
Qed.\n*)\n")
#endif
  end

let compcert_string_of_unop = function
  | OPneg -> "Oneg"
  | OPnot -> "Onotbool"
  | OPbitnot -> "Onotint"
  | OPbitneg -> "Onotint"
  | OPsha_1 -> "Osha_1"

let compcert_string_of_binop = function
  | OPplus -> "Oadd"
  | OPminus -> "Osub"
  | OPtimes -> "Omul"
  | OPdivide -> "Odiv"
  | OPremainder -> "Omod"
  | OPand -> "Oand"
  | OPor -> "Oor"
  | OPeq -> "Oeq"
  | OPne -> "One"
  | OPlt -> "Olt"
  | OPle -> "Ole"
  | OPgt -> "Ogt"
  | OPge -> "Oge"
  | OPshl -> "Oshl"
  | OPshr -> "Oshr"
  | OPxor -> "Oxor"
  | OPbitand -> "Oand"
  | OPbitor -> "Oor"
  | OPsha_2 -> "Osha_2"

let gallina_string_of_unop = function
  | OPneg -> "-"
  | OPnot -> "negb"
  | OPbitnot -> "Z.lnot"
  | OPbitneg -> "4294967296 -"
  | OPsha_1 -> "hashval_hash1"

let gallina_string_of_binop_prefix = function
  | OPplus -> "Z.add"
  | OPminus -> "Z.sub"
  | OPtimes -> "Z.mul"
  | OPdivide -> "Z.div"
  | OPremainder -> "Z.modulo"
  | OPand -> "andb"
  | OPor -> "orb"
  | OPeq -> "Z.eqb"
  | OPne -> "(fun x y => negb (Z.eqb x y))"
  | OPlt -> "Z.ltb"
  | OPle -> "Z.leb"
  | OPgt -> "Z.gtb"
  | OPge -> "Z.geb"
  | OPshl -> "Z.shiftl"
  | OPshr -> "Z.shiftr"
  | OPxor -> "Z.lxor"
  | OPbitand -> "Z.land"
  | OPbitor -> "Z.lor"
  | OPsha_2 -> "hashval_hash2"

let rec output_rexpr out ind e = match e.aRexprDesc with
  | AEconst (CONint n) ->
    output_string out ("(ECconst_int256 " ^ e.aRexprType.aTypePairIdent ^ " " ^
      string_of_int n ^ " (Int256.repr " ^ string_of_int n ^ "))")
  | AEconst (CONuint n) ->
    output_string out ("(ECconst_int256 " ^ e.aRexprType.aTypePairIdent ^ " " ^
      "(Int256.repr " ^ string_of_int n ^ ")" ^ " (Int256.repr " ^ string_of_int n ^ "))")
  | AEconst (CONbool true) ->
    output_string out "(ECconst_int256 tint_bool true Int256.one)"
  | AEconst (CONbool false) ->
    output_string out "(ECconst_int256 tint_bool false Int256.zero)"
  | AEconst CONunit ->
    output_string out "(ECconst_int256 tvoid_unit tt Int256.zero)"
  | AEconst (CONaddress addr) -> 
    output_string out ("(ECconst_int256 " ^ e.aRexprType.aTypePairIdent ^ " " ^
      "(Int256.repr " ^  (Backend.BinNumsExt.numstring2decimalstring addr) ^ ")" ^ " (Int256.repr " ^ (Backend.BinNumsExt.numstring2decimalstring addr) ^ "))")
  | AEconst CONhashvalue ->
    output_string out ("(ECconst_int256 " ^ e.aRexprType.aTypePairIdent ^ " " ^
      "(Int256.repr " ^ string_of_int 0 ^ ")" ^ " (Int256.repr " ^ string_of_int 0 ^ "))"
#ifdef REDACTED
      )
#else
      ^ "(* todo, need to handle hashvalues correctly*)")
#endif
  | AEconst CONglobalpointer_undef ->
    output_string out "(ECconst_int256 tchar_pointer_globalpointer GLOBUndef Int256.zero)"
  (*
  | AEconst CONval_undef ->
    output_string out "(ECconst_int256 tint_val Vundef Int256.zero)"
  | AEconst CONflatmem_empty ->
    output_string out "(ECconst_int256 tint_flatmem empty_flatmem Int256.zero)"
  *)
  | AEconstr_val (c, args) -> (* XXX: should be [], non-empty list need different treatment *)
    let rec output c = function
      | [] -> output_string out c.aTypeConstrName
      | args -> output_string out ("(" ^ c.aTypeConstrName);
        List.iter (fun (_, e) -> match e.aRexprDesc with
          | AEconst (CONint n) -> output_string out (" " ^ string_of_int n)
          | AEconst (CONbool b) -> output_string out (" " ^ string_of_bool b)
          | AEconst CONunit -> output_string out " tt"
          | AEconst CONhashvalue -> output_string out (" (hashval_int256 Int256.zero)")
          | AEconst CONglobalpointer_undef -> output_string out " GLOBUndef"
          (*
          | AEconst CONval_undef -> output_string out " Vundef"
          | AEconst CONflatmem_empty -> output_string out " empty_flatmem"
          *)
          | AEconstr_val (c', args') -> output_char out ' '; output c' args'
          | _ -> output_string out (" tt"
           ^ "(*XXX(output_rexpr | ACconstr_val | complex arg)*)");
                 output_string out "(* (Did you forget C synthesis annotations on the type declaration?) *)"
        ) args;
        output_char out ')' in
    output_string out ("(ECconst_int256 " ^ e.aRexprType.aTypePairIdent ^ " ");
    output c args;
    output_string out (" " ^ begin match c.aTypeConstrImpl with
      | None | Some { aImplDesc = ACdefault } -> "Int256.zero"
      | Some { aImplDesc = ACint n } -> "(Int256.repr " ^ string_of_int n ^ ")"
      | _ -> "Int256.zero (*XXX(output_rexpr | ACconstr_val | unrecog. cimpl)*)"
      end ^ ")")
  | AEtemp (n, i) ->
    output_string out ("(ECtempvar " ^ e.aRexprType.aTypePairIdent ^ " " ^ string_of_ident n ^ " (* " ^ i ^ " *))")
  | AEunop (op, e') ->
    output_string out ("(ECunop " ^ e.aRexprType.aTypePairIdent ^ " " ^
      compcert_string_of_unop op ^ " ");
    output_rexpr out ind e';
    output_char out ')'
  | AEbinop (op, e1, e2) ->
    output_string out ("(ECbinop " ^ e.aRexprType.aTypePairIdent ^ " " ^
      compcert_string_of_binop op ^ "\n" ^ ind);
    output_rexpr out ("  " ^ ind) e1;
    output_string out ("\n" ^ ind);
    output_rexpr out ("  " ^ ind) e2;
    output_char out ')'
  | AEbuiltin ("address",[]) ->
     output_string out "(@ECbuiltin0 _ _  _ builtin0_address_impl)"
  | AEbuiltin ("origin",[]) ->
     output_string out "(@ECbuiltin0 _ _  _ builtin0_origin_impl)"
  | AEbuiltin ("caller",[]) ->
     output_string out "(@ECbuiltin0 _ _  _ builtin0_caller_impl)"
  | AEbuiltin ("callvalue",[]) ->
     output_string out "(@ECbuiltin0 _ _  _ builtin0_callvalue_impl)"
  | AEbuiltin ("coinbase",[]) ->
     output_string out "(@ECbuiltin0 _ _  _ builtin0_coinbase_impl)"
  | AEbuiltin ("timestamp",[]) ->
     output_string out "(@ECbuiltin0 _ _  _ builtin0_timestamp_impl)"
  | AEbuiltin ("number",[]) ->
     output_string out "(@ECbuiltin0 _ _  _ builtin0_number_impl)"
  | AEbuiltin ("chainid",[]) ->
     output_string out "(@ECbuiltin0 _ _  _ builtin0_chainid_impl)"
  | AEbuiltin ("selfbalance",[]) ->
     output_string out "(@ECbuiltin0 _ _  _ builtin0_selfbalance_impl)"
  | AEbuiltin ("balance",[e1]) ->
     output_string out "(@ECbuiltin1 _ _ _ _ _ builtin1_balance_impl \n";
     output_rexpr out ("  " ^ ind) e1;
     output_char out ')'
  | AEbuiltin ("blockhash",[e1]) ->
     output_string out "(@ECbuiltin1 _ _ _ _ _ builtin1_blockhash_impl \n";
     output_rexpr out ("  " ^ ind) e1;
     output_char out ')'     
  | AEbuiltin (other,args) -> coqgen_fatal_error __LOC__ "output_rexpr"
               ("Internal error, encountered unknown builtin \""^other^"\".")
		
let rec output_lexpr out obj ind e = match e.aLexprDesc with
  | AEglob i -> output_string out ("(LCvar " ^ obj ^ "_" ^ i ^ "_var)")
  | AEfield (e', f) ->
    output_string out ("(LCfield " ^ e.aLexprType.aTypePairIdent ^ " " ^
      begin match e'.aLexprType.aTypeDesc with
      | ATdata (i, _) -> struct_field_name_to_ident i f
      | ATprod _ as d ->
        struct_field_name_to_ident ("struct_" ^ a_type_desc_to_ident d) f
      | _ -> coqgen_fatal_error __LOC__ "output_lexpr"
               "Only ATdata and ATprod can be accessed through structure field selector"
      end ^ "\n" ^ ind);
    output_lexpr out obj ("  " ^ ind) e';
    output_char out ')'
  | AEindex (e', idx) ->
    (* print_endline (string_of_a_type true e'.aLexprType); *)
    let lc_type = match e'.aLexprType.aTypeDesc with
    | ATmapping _ -> "LChash"
    | _ -> "LCindex" in
    output_string out ("(" ^ lc_type ^ " " ^ e.aLexprType.aTypePairIdent ^ "\n" ^ ind);
    output_lexpr out obj ("  " ^ ind) e';
    output_string out ("\n" ^ ind);
    output_rexpr out ("  " ^ ind) idx;
    output_char out ')'

let output_rexpr_gallina out se =
  let rec output ind e = match e.aRexprDesc with
    | AEconst (CONint n) -> output_string out (string_of_int n)
    | AEconst (CONuint n) -> output_string out (string_of_int n)
    | AEconst (CONaddress addr) -> output_string out (Backend.BinNumsExt.numstring2decimalstring addr)
    | AEconst (CONbool b) -> output_string out (string_of_bool b)
    | AEconst CONunit -> output_string out "tt"
    | AEconst CONhashvalue -> output_string out "(hashval_int256 Int256.zero)"
    | AEconst CONglobalpointer_undef -> output_string out "GLOBUndef"
    (*
    | AEconst CONval_undef -> output_string out "Vundef"
    *)
    | AEconstr_val (c, []) -> output_string out c.aTypeConstrName
    | AEconstr_val (c, es) ->
      output_char out '(';
      output_string out c.aTypeConstrName;
      List.iter (fun p -> output_char out ' '; output ("  " ^ ind) (snd p)) es;
      output_char out ')'
    | AEtemp (n, i) ->
      output_string out ("(SpecTree.get " ^
        string_of_ident n ^ " (* " ^ i ^ " *) " ^ se ^ ")")
    | AEunop (op, e) ->
      output_string out ("(" ^ gallina_string_of_unop op ^ " ");
      output ("  " ^ ind) e;
      output_char out ')'
    | AEbinop (op, e1, e2) ->
      output_string out ("(" ^ gallina_string_of_binop_prefix op ^ " ");
      output ("  " ^ ind) e1;
      output_char out ' ';
      output ("  " ^ ind) e2;
      output_char out ')'
    | AEbuiltin ("address",[]) ->
        output_string out "(me_address me)"
    | AEbuiltin ("origin",[]) ->
        output_string out "(me_origin me)"
    | AEbuiltin ("caller",[]) ->
        output_string out "(me_caller me)"
    | AEbuiltin ("callvalue",[]) ->
        output_string out "(me_callvalue me)"
    | AEbuiltin ("coinbase",[]) ->
        output_string out "(me_coinbase me)"
    | AEbuiltin ("timestamp",[]) ->
        output_string out "(me_timestamp me)"
    | AEbuiltin ("number",[]) ->
        output_string out "(me_number me)"
    | AEbuiltin ("balance",[e1]) ->
        output_string out "(me_balance me)"
    | AEbuiltin ("blockhash",[e1]) ->
        output_string out "(me_blockhash me)"
    | AEbuiltin (other,args) -> coqgen_fatal_error __LOC__ "output_rexpr_gallina"
                  ("Internal error, encountered unknown builtin \""^other^"\".")
      
  in output

let output_lexpr_get_gallina out obj se d =
  let rec output ind (e : Ast.a_lexpr) = match e.aLexprDesc with
    | AEglob v ->
      output_string out ("(" ^ obj ^ "_" ^ v ^ "_global.(ltype_get) " ^ d ^ ")")
    | AEfield (e', fld) ->
      output_string out ("(Hfield_get (id := " ^
        begin match e'.aLexprType.aTypeDesc with
        | ATdata (i, _) -> struct_field_name_to_ident i fld
        | ATprod _ as d ->
          struct_field_name_to_ident ("struct_" ^ a_type_desc_to_ident d) fld
        | _ -> coqgen_fatal_error __LOC__ "output_lexpr"
                 "Only ATdata and ATprod can be accessed through structure field selector"
        end ^ ") ");
      output ("  " ^ ind) e';
      output_char out ')'
  | AEindex (e', idx) ->
    output_string out "(Hindex_get ";
    output_rexpr_gallina out se ("    " ^ ind) idx;
    output_char out ' ';
    output ("  " ^ ind) e';
    output_char out ')'
  in output

let output_lexpr_set_gallina out obj se v d =
  let rec output out_v ind e = match e.aLexprDesc with
    | AEglob var ->
      output_string out (obj ^ "_" ^ var ^ "_global.(ltype_set) ");
      out_v ();
      output_string out (" " ^ d);
    | AEfield (e', fld) ->
      let field_id = match e'.aLexprType.aTypeDesc with
        | ATdata (i, _) -> struct_field_name_to_ident i fld
        | ATprod _ as d ->
          struct_field_name_to_ident ("struct_" ^ a_type_desc_to_ident d) fld
        | _ -> coqgen_fatal_error __LOC__ "output_lexpr"
                 "Only ATdata and ATprod can be accessed through structure field selector" in
      output
        (fun _ ->
          output_string out ("(Hfield_set (id := " ^ field_id ^ ") ");
          out_v ();
          output_char out ' ';
          output_lexpr_get_gallina out obj se d ind e';
          output_char out ')')
        ("  " ^ ind)
        e'
    | AEindex (e', idx) ->
      output
        (fun _ ->
          output_string out ("(@Hindex_set _ _ " ^
            e'.aLexprType.aTypePairIdent ^ "_index_impl ");
          output_rexpr_gallina out se ("    " ^ ind) idx;
          output_char out ' ';
          out_v ();
          output_char out ' ';
          output_lexpr_get_gallina out obj se d ind e';
          output_char out ')')
        ("  " ^ ind)
        e'
  in output (fun _ -> output_string out v)

let rec output_compile_time_constant out ind = function
  | ACONconst c -> output_string out (string_of_constant c)
  | ACONstruct lst ->
    let record_field_leftover = ref "\n  "
    in output_string out "{|";
       List.iter (fun (i, c) ->
         output_string out (!record_field_leftover ^ ind ^ i ^ " := ");
         output_compile_time_constant out ("  " ^ ind) c;
         record_field_leftover := ";\n  "
       ) lst;
       output_string out ("\n" ^ ind ^ "|}")
  | ACONconstr ({ aTypeConstrName = "array_init"; aTypeConstrArgs = [_, t] }, []) ->
    output_string out "(ZMap.init ";
    output_default out ("  " ^ ind) t;
    output_char out ')'
  | ACONconstr ({ aTypeConstrName = "array_sets"; aTypeConstrArgs = [_, t] }, ll) ->
    let rec output_array_sets index l =
      match l with
      | (_,hd)::tl ->
              output_string out ("(ZMap.set " ^ (string_of_int index) ^ " ");
              output_compile_time_constant out ind hd;
              output_char out ' ';
              output_array_sets (index-1) tl;
              output_char out ')'
      | [] ->
              output_string out "(ZMap.init ";
              output_default out ("  " ^ ind) t;
              output_char out ')'
    in
    output_array_sets ((List.length ll)-1) (List.rev ll)
  | ACONconstr ({ aTypeConstrName = "mapping_init"; aTypeConstrArgs = [_, t] }, []) ->
     output_string out "(Int256Tree.empty ";
     output_type_expr out "" t;
     output_char out ')'		      
  | ACONconstr (cstr, []) -> output_string out cstr.aTypeConstrName
  | ACONconstr (cstr, lst) ->
    output_string out ("(" ^ cstr.aTypeConstrName);
    List.iter (fun (_, c) ->
      output_char out ' ';
      output_compile_time_constant out ("  " ^ ind) c
    ) lst;
    output_char out ')'
  | ACONexternal_const (s, _) -> output_string out s

let rec output_hyper_pair_list out = function
  | _, [] -> output_string out "nil"
  | varnames, t :: res ->
    let v, varres = match varnames with
      | [] -> "", []
      | v :: res -> "(* " ^ v ^ " : *) ",
      res in
    output_string out ("(cons " ^ v ^
      type_pair_to_hyper_pair_name t.aTypePairIdent ^ " ");
    output_hyper_pair_list out (varres, res);
    output_char out ')'
let output_params out varnames = function
  | [t] when t.aTypeDesc = ATbuiltin Tunit -> output_string out "nil"
  | params -> output_hyper_pair_list out (varnames, params)

let rec output_tmp_env out ind depth = function
  | [] -> output_string out ("(@AList.empty hyper_type_pair)" ^ String.make depth ')')
  | (_, (n, t)) :: res ->
    output_string out ("(AList.set " ^ string_of_ident n ^ " " ^
      type_pair_to_hyper_pair_name t.aTypePairIdent ^ " ");
    output_tmp_env out ind (depth + 1) res

exception PrimitiveNotFound of string

(* When calling a primitive from a lower layer, we need to look up
     which object it is defined in. *)
let ident_of_primitive underlay slotname funcname =
     let o = try (List.assoc slotname underlay.aLayerAllObjects)
             with Not_found -> raise (PrimitiveNotFound slotname) in
     (o.aObjectName ^"_"^ funcname ^"_prim")

let output_command env out base_layer obj method_full_name =
  let rec output_HList ind get_hyper_pair_name output_x = function
    | [] -> output_string out "HNil"
    | x :: xs ->
      output_string out ("(HCons " ^ get_hyper_pair_name x ^ " _\n" ^ ind);
      output_x out ("  " ^ ind) x;
      output_string out ("\n" ^ ind);
      output_HList ("  " ^ ind) get_hyper_pair_name output_x xs;
      output_char out ')' in
  let output_args ind = function
    | [e] when e.aRexprType.aTypeDesc = ATbuiltin Tunit ->
      output_string out "HNil"
    | args ->
      output_HList ind
        (fun e -> type_pair_to_hyper_pair_name e.aRexprType.aTypePairIdent)
        output_rexpr
        args in

  (* XXX: the code before did something differently based on if "real_field_idents" is true or not.
     (See the commented out code in the method below.) We might need to restore that functionality? *)
  let rec output_struct_fieldname_list i real_field_idents fields = match fields with
    | [] -> output_string out "nil"
    | (f :: fs) -> output_string out ("(cons " ^ struct_field_name_to_ident i f ^ " ");
		   output_struct_fieldname_list i real_field_idents fs;
		   output_string out ")"
   in

  let output_constr_command ind el er =
    let c, ls, cfieldnames, i, real_field_idents =
      match er.aBigExprDesc, er.aBigExprType.aTypeDesc with
      | AEstruct (c, ls), ATdata (i, _) 
      | AEconstr (c, ls), ATdata (i, _) ->
        begin match er.aBigExprType.aTypeCtype with
        | ACtstruct (cname,cfields) -> c, ls, List.map fst cfields, cname, er.aBigExprType.aTypeProvable
        | _                         -> c, ls, List.map fst ls,      i,     false
        end
      | _, (ATprod _ as d) -> ignore d;
        coqgen_fatal_error __LOC__ "output_constr_command"
          "???: can we have pairs for data construction?"
      | _ -> coqgen_fatal_error __LOC__ "output_constr_command"
               "Only true big expression can be on the RHS of a data construction"
    in (* XXX: won't work on [PTPerm] or if data type field name differ from
                C struct field name.

                Need to make use of [c.aTypeConstrImpl] in such cases. *)
        output_string out ("(CCconstr\n" ^ ind);
	output_struct_fieldname_list  i real_field_idents cfieldnames ;
	output_string out ("\n" ^ ind);
        output_hyper_pair_list out (List.split c.aTypeConstrArgs);
        output_string out ("\n" ^ ind);
        output_lexpr out obj ("  " ^ ind) el;
        output_string out ("\n" ^ ind);
        output_HList ("  " ^ ind)
          (fun (_, e) -> type_pair_to_hyper_pair_name e.aBigExprType.aTypePairIdent)
          (fun out ind (f, e) -> match e.aBigExprDesc with
           | AErexpr e ->
(*             if real_field_idents then
               output_string out ("(" ^ struct_field_name_to_ident i f ^ ", ")
             else
               output_string out ("(" ^ string_of_ident 1 ^ ", "); *)
             output_rexpr out ind e;
(*             output_char out ')' *)
           | AEexternal_const (s, _) ->
(*             if real_field_idents then
               output_string out ("(" ^ struct_field_name_to_ident i f ^ ", ")
             else
               output_string out ("(" ^ string_of_ident 1 ^ ", "); *)
             output_string out ("(ECconst_int256 " ^ e.aBigExprType.aTypePairIdent ^
                                " " ^ s ^ " Int256.zero)");
           | _ -> coqgen_fatal_error __LOC__ "output_constr_command"
                    "Nested data type construction not supported yet")
          ls;
        output_string out ("\n" ^ ind ^ c.aTypeConstrName ^ ")") in

  let rec output_matchable_as_lexpr out obj (* se d *) ind m = match m.aMatchableDesc with
    | AMtemp (id,ident) ->  output_string out "XXX: don't know how to handle tempvar"  (* note, this should probably be a lexpr_constr *)
    | AMlexpr lexpr -> output_lexpr out obj (" " ^ ind) lexpr
  in

  let rec output_matchable_as_rexpr out obj (* se d *) m = match m.aMatchableDesc with
    | AMtemp (id,ident) ->  output_string out ("(ECtempvar " ^ m.aMatchableType.aTypePairIdent
			                       ^ " " ^ string_of_int id ^ "%positive)")
    | AMlexpr lexpr -> output_string out "XXX: don't know how to handle lexpr"
  in

  let rec output_matchable_gallina out obj se d ind m = match m.aMatchableDesc with
    | AMtemp (n, i) ->
      output_string out ("(SpecTree.get " ^
        string_of_ident n ^ " (* " ^ i ^ " *) " ^ se ^ ")")
    | AMlexpr lexpr -> output_lexpr_get_gallina out obj se d (" " ^ ind) lexpr
  in

  let output_matchable_pattern_gallina out ind pat tenv =
    if pat.aTypeConstrName="CONS" then
      match pat.aTypeConstrArgs with
      | [ (hd,_); (tl,_)] -> output_string out (hd ^ " :: " ^ tl)
      | _ ->  coqgen_fatal_error __LOC__ "output_matchable_pattern_gallina" "internal error, malformed cons pattern"
    else if pat.aTypeConstrName="NIL" then
      output_string out "nil"
    else begin
	output_string out ("(" ^ (pat.aTypeConstrName));
	List.iter (fun (ident, _) -> output_string out " ";
	        	             output_string out ident)
		  (List.rev tenv); 
	output_string out ")"
      end
  in


  let output_spec_env tmp_env tail_se =
    let ind = ref "\n             " in
    List.iter (fun (ident, (tmp_id, tmp_typ)) ->
	       if (ident <> "_") then begin
		 output_string out (!ind ^
				    "(SpecTree.set " ^ string_of_ident tmp_id ^ " " ^
				      type_pair_to_hyper_pair_name tmp_typ.aTypePairIdent ^ " " ^ ident);
                 ind := !ind ^ "  "
	       end else
		 output_string out " ("
	      ) tmp_env;
    output_string out (!ind ^ tail_se ^ " " ^
      String.make (List.length tmp_env) ')') in

  let rec output_matchable_clause_gallina out ind pure path (cls : a_clause) =
   let body_name = method_full_name ^ "_match_body_" ^ string_of_path path in
   match cls with
    | (Some pat, tenv, cmd) ->
	 output_string out (ind ^ "| ");
	 output_matchable_pattern_gallina out ind pat tenv;
	 output_string out " =>\n";
	 output_string out (ind ^ "  " ^ body_name ^ "_spec");
         output_spec_env tenv "se\n";
         (* output_string out ("\n" ^ ind ^ "   d r k\n"); *)
    (* The typechecker enforces that the body of a wildcard branch is just "fail". *)
    | (None, tenv, cmd) ->
	 output_string out (ind ^ "| _ => mzero\n");

  (* There are a few pattern-matching idioms that can be rendered into C code, so we recognize those,
     and for the other ones we just give up.

     First, if there is just a single constructor of a big type, and then a default type (which fails), then
     we can translate the case-expression as a projection function. *)
  and output_projection_style_match scrutinee tenv struct_name fields body = 
    List.iter2 (fun (ident,(tmp_id, tmp_typ)) (fieldname, _) ->
		if (ident <> "_")
		then begin
		 output_string out ("
          (CClet " ^ string_of_int tmp_id ^ "%positive
                  (CCload (LCfield " ^ tmp_typ.aTypePairIdent);
		 output_string out (" "^ struct_field_name_to_ident struct_name fieldname 
					 ^"\n                            ");
		 output_matchable_as_lexpr out obj "                            " scrutinee;
                 output_string out "))"
	         end
                else
		  output_string out "(")
		  (List.rev tenv)
		  fields;
        output_string out ("\n            " ^ body
			   ^ String.make (List.length tenv) ')')

  (* Second, if all the matched constructors are realized as distinct constant integers, and none of them bind any varaibles,
     then we can translate the match into a series of if-statements. *)
  and output_case_style_match scrutinee clss bodyname_stem path ind =
    let lastclause = List.length clss - 1 in
    List.iteri (fun i cls ->
		match cls with
		| (Some c,_,_) when (i<>lastclause) ->
		   output_string out (ind ^ "(CCifthenelse\n" ^
			              ind ^ "  (ECbinop tint_bool Oeq\n" ^ ind ^ "     ");
		   output_matchable_as_rexpr out obj scrutinee;
                   output_string out ("\n"^ ind ^ "     ");
		   output_rexpr out ("\n"^  ind ^ "     ") { aRexprDesc = AEconstr_val(c, []); aRexprType = scrutinee.aMatchableType};
                   output_string out (")\n" ^ ind ^ "       "
				      ^ bodyname_stem ^ (string_of_path (i::path)) ^ "\n")
		| _ -> output_string out (ind ^ "       " ^  bodyname_stem ^ (string_of_path (i::path))
					  ^ String.make (List.length clss - 1) ')' ^"\n") (* last, maybe catch-all, branch *)
	       )
               clss

  and output ind pure path c = match c.aCmdDesc with
    | ACskip -> output_string out "CCskip"
    | ACyield e ->
      output_string out "(CCyield ";
      output_rexpr out ind e;
      output_char out ')'

    | AClet (n, i, c1, c2) ->
      output_string out ("(CClet " ^ "(* " ^ i ^ " := *) " ^
      string_of_ident n ^
        "\n" ^ ind);
      output ("  " ^ ind) pure (1::path) c1;
      output_string out ("\n" ^ ind);
      output ("  " ^ ind) pure (2::path) c2;
      output_char out ')'
    | ACsequence (c1, c2) ->
      output_string out ("(CCsequence\n" ^ ind);
      output ("  " ^ ind) pure (1::path) c1;
      output_string out ("\n" ^ ind);
      output ("  " ^ ind) pure (2::path) c2;
      output_char out ')'
    | ACcall (s, f, es, _, _) ->
      let o = (try (List.assoc s base_layer.aLayerAllObjects)
      with Not_found -> raise (PrimitiveNotFound s); Typecheck.dummy_object s) in
      (match o.aObjectAddress with
      (* also need to print the addresses in DatatypeOps for easier proof *)
      | Some addr -> 
        (* this should be CCrespec *)

        (* (CCrespec_opt (@AList.empty hyper_type_pair) (CCpanic tint_Z32)
        (fun me se =>
        (FixedSupplyToken_balanceOf_opt (me_address me) (ext_call_me me (Int256.repr 65587))))). *)
        
        output_string out ("(CCrespec_opt\n" ^ ind);
        output_tmp_env out ind 0 c.aCmdEnv;
        output_string out ("\n" ^ ind);
        (try 
        output_string out ("(CCpanic " ^ (List.find (fun m -> m.aMethodName = f) o.aObjectMethods).aMethodType.aMethodReturnType.aTypePairIdent ^ ")")
        with Not_found -> ());
        output_string out ("\n" ^ ind);
        output_string out ("(fun me se => (");
        (* output_string out "(@bind _ (@Monad_DS GlobalLayerSpec) _ _ get (fun d => put (execStateT ("; *)
        let o = try (List.assoc s base_layer.aLayerAllObjects)
                with Not_found -> raise (PrimitiveNotFound s) in
        output_string out (o.aObjectName ^"_"^ f ^"_opt ");
        
        let rec output_args_gallina args = match args with
          | [] -> output_string out " "
          | x :: xs -> 
            match x.aRexprDesc with
            | AEconst CONunit -> output_string out " "
            | _ -> 
              output_string out "(";
              (match x.aRexprDesc with 
              | AEconst (CONuint n) -> output_string out "Int256.repr "
              | AEconst (CONaddress addr) -> output_string out "Int256.repr "
              | _ -> output_string out "");
              output_rexpr_gallina out "se" ("    " ^ ind) x;
              output_string out ") ";
              output_args_gallina xs
        in
        output_args_gallina es;

        output_string out "(ext_call_me me ";
        output_string out ("(Int256.repr " ^  (Backend.BinNumsExt.numstring2decimalstring addr) ^ ")");
        output_string out "))))"
      | None -> 
        output_string out ("(CCcall " ^ ident_of_primitive base_layer s f ^ "\n" ^ ind);
        output_args ("  " ^ ind) es;
        output_char out ')')
    | ACcond (e, c_then, c_else) ->
      output_string out "(CCifthenelse ";
      output_rexpr out ("  " ^ ind) e;
      output_string out ("\n" ^ ind);
      output ("  " ^ ind) pure (1::path) c_then;
      output_string out ("\n" ^ ind);
      output ("  " ^ ind) pure (2::path) c_else;
      output_char out ')'
    | ACfor (n_iter, i, e_start, n_end, e_end, c, None) ->
      output_string out ("(CCfor (* " ^ i ^ " := *) " ^ string_of_ident n_iter ^  (* XXX: probably need to adjust the path here somewhere? *)
        " " ^ string_of_ident n_end ^ " ");
      output_rexpr out ("  " ^ ind) e_start;
      output_char out ' ';
      output_rexpr out ("  " ^ ind) e_end;
      output_string out ("\n" ^ ind);
      output ("  " ^ ind) pure path c;
      output_char out ')';
    | ACfor (n_iter, i, e_start, n_end, e_end, c0, Some cc) ->
      if pure then
        coqgen_fatal_error __LOC__ "output_command"
          "for command under pure context";
      output_string out ("(CCrespec_opt\n" ^ ind);
      output_tmp_env out ind 0 c.aCmdEnv;
      output_string out ("\n" ^ ind ^
        method_full_name ^ "_slice_" ^ cc.aCapturedName ^ "\n" ^ ind ^
        "(fun se d r k =>\n" ^ ind ^
        " match " ^ cc.aCapturedName);
      List.iter (fun (_, (tmp_id, _)) ->
        output_string out (" (SpecTree.get " ^ string_of_ident tmp_id ^ " se)")
      ) cc.aCapturedTemp;
      output_string out (" d with\n" ^ ind ^
        " | Some a => k (a, tt)\n" ^ ind ^
        " | None => None\n" ^ ind ^
        " end))")
    | ACmatch (e, cls) when pure ->
      output_string out ("(CCrespec\n" ^ ind);
      output_tmp_env out ind 0 c.aCmdEnv;
      output_string out ("\n" ^ ind);
      output_string out ("(CCpanic " ^ c.aCmdType.aTypePairIdent ^ ")");
      output_string out ("\n" ^ ind);
      output_string out "(fun se => @ret _ (@Monad_DS GlobalLayerSpec) _ ht_default (*XXX(output_command | ACmatch when pure)*))";
      output_char out ')'

    | ACmatch (e, clss) (* when not pure *)->
      output_string out ("(CCrespec_opt\n" ^ ind);
      output_tmp_env out ind 0 c.aCmdEnv;
      let is_simple_int c =  match c with
	| (Some { aTypeConstrImpl = Some {aImplDesc = ACint _}}, [], _) -> true
	| (None, _, _) -> true
	| _ -> false
      in
      begin match clss with
	    | [(Some { aTypeConstrImpl = Some {aImplDesc = ACstruct fields; aImplType = ACtstruct (struct_name,_)} }, tenv, cmd); (None,_,_)]
	    | [(Some { aTypeConstrImpl = Some {aImplDesc = ACstruct fields; aImplType = ACtstruct (struct_name,_)} }, tenv, cmd)]
               -> output_string out ("\n" ^ ind);
		  output_projection_style_match e tenv struct_name fields (method_full_name ^ "_match_body_" ^ string_of_path (0::path) )
	    | _ when List.for_all is_simple_int clss
	       -> output_string out ("\n");
		  output_case_style_match e clss (method_full_name ^ "_match_body_") path ind 
	    | _ -> coqgen_warning ("Don't know how to synthesise C code for the pattern match on " ^ string_of_a_matchable e);
		   output_string out ("(CCpanic " ^ c.aCmdType.aTypePairIdent ^ ")")
      end;
      output_string out ("\n" ^ ind);
      output_string out ("(fun se => @bind _ (@Monad_DS GlobalLayerSpec) _ _ get (fun d =>\n" ^ ind);   (* todo: pick fresh names for these vars? *)
      output_string out "  match ";
      output_matchable_gallina out obj "se" "d" ind e;
      output_string out  " with\n" ;
      List.iteri (fun i cls -> output_matchable_clause_gallina out ("    " ^ ind) pure (i::path) cls)  clss;
      output_string out "end)))"
    | ACemit _ ->
       coqgen_warning "'emit' statements are currently ignored by the coq backend.";
       output_string out "CCskip"

    | ACload e ->
      output_string out "(CCload ";
      output_lexpr out obj ind e;
      output_char out ')'
    | ACstore (el, er) ->
      output_string out ("(CCstore\n" ^ ind);
      output_lexpr out obj ("  " ^ ind) el;
      output_string out ("\n" ^ ind);
      output_rexpr out ("  " ^ ind) er;
      output_char out ')'
    | ACconstr (el, er) -> output_constr_command ind el er

    | ACfail ->
      output_string out ("(CCpanic " ^ c.aCmdType.aTypePairIdent ^ ")")
    | ACassert c ->
      output_string out "(CCassert ";
      output ind pure path c;
      output_char out ')'
    | ACdeny c ->
      output_string out "(CCdeny ";
      output ind pure path c;
      output_char out ')'
    | ACghost c ->
      output_string out "(CCghost ";
      output ind pure path c;
      output_char out ')'

    | ACfirst (n_iter, i, e_start, n_end, e_end, n_c, c, c_then, c_else, None) ->
      output_string out ("(CCfirst (* " ^ i ^ " := *) " ^ string_of_ident n_iter ^
        " " ^ string_of_ident n_end ^ " " ^ string_of_ident n_c ^ " ");
      output_rexpr out ("  " ^ ind) e_start;
      output_char out ' ';
      output_rexpr out ("  " ^ ind) e_end;
      output_string out ("\n" ^ ind);
      output ("  " ^ ind) true (1::path) c;
      output_string out ("\n" ^ ind);
      output ("  " ^ ind) pure (2::path) c_then;
      output_string out ("\n" ^ ind);
      output ("  " ^ ind) pure (3::path) c_else;
      output_char out ')'
    | ACfirst (n_iter, i, e_start, n_end, e_end, n_c, _, _, _, Some cc) ->
      let slice_name = method_full_name ^ "_slice_" ^ cc.aCapturedName in
      let args = String.concat "" (List.map (fun (_, (tmp_id, _)) ->
                   " (SpecTree.get " ^ string_of_ident tmp_id ^ " se)"
                 ) cc.aCapturedTemp) in
      let spec_post_matters =
        if pure then ""
                else " _ (fun r => k (ss_mem r, ss_return r))" in
      if pure then
        output_string out ("(CCrespec\n" ^ ind)
      else
        output_string out ("(CCrespec_opt\n" ^ ind);
      output_tmp_env out ind 0 c.aCmdEnv;
      output_string out ("\n" ^ ind ^
        "(CCfirst (* " ^ i ^ " := *) " ^ string_of_ident n_iter ^
        " " ^ string_of_ident n_end ^ " " ^ string_of_ident n_c ^ " ");
      output_rexpr out ("  " ^ ind) e_start;
      output_char out ' ';
      output_rexpr out ("  " ^ ind) e_end;
      output_string out ("\n  " ^ ind ^
        slice_name ^ " " ^ slice_name ^ "_found " ^ slice_name ^ "_notfound)\n" ^ ind ^
        (if pure then
           "(fun se d =>\n"
         else
           "(fun se d r k =>\n") ^ ind ^
        " match " ^ cc.aCapturedName ^ args ^ " ");
      output_rexpr_gallina out "se" ("    " ^ ind) e_start;
      output_char out ' ';
      output_rexpr_gallina out "se" ("    " ^ ind) e_end;
      output_string out (" d with\n" ^ ind ^
        " | inleft (exist n _) => " ^ slice_name ^ "_found_spec" ^ args ^ "\n" ^ ind ^
        "     n d" ^ spec_post_matters ^ "\n" ^ ind ^
        " | inright _ => " ^ slice_name ^ "_notfound_spec" ^ args ^ "\n     " ^ ind);
      output_rexpr_gallina out "se" ("       " ^ ind) e_end;
      output_string out (" d" ^ spec_post_matters ^ "\n" ^ ind ^
        " end))")

    | ACfold (n_iter, i_iter, e_start, n_end, e_end, n_acc, i_acc, e_init, n_c, c, None) ->
      output_string out ("(CCfold (* " ^ i_iter ^ " := *) " ^ string_of_ident n_iter ^
        " " ^ string_of_ident n_end ^
        " (* " ^ i_acc ^ " := *) " ^ string_of_ident n_acc ^
        " " ^ string_of_ident n_c ^ " ");
      output_rexpr out ("  " ^ ind) e_start;
      output_char out ' ';
      output_rexpr out ("  " ^ ind) e_end;
      output_char out ' ';
      output_rexpr out ("  " ^ ind) e_init;
      output_string out ("\n" ^ ind);
      output ("  " ^ ind) true path c;
      output_char out ')'
    | ACfold (n_iter, i_iter, e_start, n_end, e_end, n_acc, i_acc, e_init, n_c, _, Some cc) ->
      output_string out ("(CCrespec\n" ^ ind);
      output_tmp_env out ind 0 c.aCmdEnv;
      output_string out ("\n" ^ ind ^
        method_full_name ^ "_slice_" ^ cc.aCapturedName ^ "\n" ^ ind ^
        "(fun se => " ^ cc.aCapturedName);
      List.iter (fun (_, (tmp_id, _)) ->
        output_string out (" (SpecTree.get " ^ string_of_ident tmp_id ^ " se)")
      ) cc.aCapturedTemp;
      output_string out "))"

    | ACexternal (dest, s, i, []) ->
      output_string out ("(CCrespec_opt\n" ^ ind);
      output_tmp_env out ind 0 c.aCmdEnv;
      output_string out ("\n" ^ ind);
      output_string out ("(CCpanic " ^ c.aCmdType.aTypePairIdent ^ ")");
      output_string out ("\n" ^ ind);
      output_string out ("(fun se => ");
      begin match dest with
      | None -> output_string out ("ret (" ^ s ^ ")")
      | Some el -> output_string out "(@bind _ (@Monad_DS GlobalLayerSpec) _ _ get (fun d =>  put (";
                   output_lexpr_set_gallina out obj "se" s "d" ("    " ^ ind) el; 
                   output_string out ")))"
      end;
      output_string out "))"

    | ACexternal (dest, s, i, args) ->
      let is_partial = Hashtbl.mem env.partial_external_symbols s in
      output_string out ("(CCrespec_opt\n" ^ ind);
      output_tmp_env out ind 0 c.aCmdEnv;
      output_string out ("\n" ^ ind);
      output_string out ("(CCpanic " ^ c.aCmdType.aTypePairIdent ^ ")");
      output_string out ("\n" ^ ind);
      output_string out ("(fun se => @bind _ (@Monad_DS GlobalLayerSpec) _ _ get (fun d =>");
      output_string out ("\n" ^ ind);
      (if is_partial
       then output_string out ("match " ^ s)
       else output_string out ("let a := " ^ s));
      List.iter (function
        | AEXrexer e ->
          output_string out ("\n     " ^ ind);
          output_rexpr_gallina out "se" ("    " ^ ind) e
        | AEXlexpr e ->
          output_string out ("\n     " ^ ind);
          output_lexpr_get_gallina out obj "se" "d" ("    " ^ ind) e
      ) args;
      (if is_partial
       then output_string out (" with\n" ^
	 ind ^ " | None => mzero\n" ^ ind ^ " | Some a => ")
       else output_string out " in\n");
      begin match dest with
      | None -> output_string out "@ret _ (@Monad_DS GlobalLayerSpec) _ a"
      | Some el -> output_string out "put (";
                   output_lexpr_set_gallina out obj "se" "a" "d" ("    " ^ ind) el;
                   output_string out ")"
      end;
      if is_partial
      then output_string out ("\n" ^ ind ^ " end)))")
      else output_string out ("\n" ^ ind ^ " )))")

  in output

(* It would be a good idea to make the "ignore base" user-configurable, right now it's just an ad-hoc mess of things that comes up in different examples.. .*)       
       
let cbv_ignore_base = "Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default \n"
                    
(* This "slices out" a piece of the AST, and defines it as a separate top-level definition
   (together with the corresponding environment type, wellformedness proof, etc).

   It is used for two things: loop body expressions that have been annotated with a name in [[ ]]-brackets,
   and for the bodies of DeepSpec match commands.

   The names of the generated slices and match bodies are derived using a "path" that identifies a particular
   subexpression of a name. Later, in output_command, we will carefully compute the same path, in order to refer
   to the right name.
*)
let prepare_command env out base_layer obj method_full_name =
  let create_name str = method_full_name ^ "_slice_" ^ str in
  (*let serial_number = ref 0 in
    let create_anon_name () =
    let str = string_of_int !serial_number in
    incr serial_number;
    create_name str in *)

  let synth_stmt pure =
    if pure then "synth_stmt_spec_ret"
            else "synth_stmt_spec_opt" in

  let output_init_se tmp_env init_se =
    let ind = ref "\n       " in
    List.iter (fun (tmp_name, (tmp_id, tmp_typ)) ->
      output_string out (!ind ^
        "(SpecTree.set " ^ string_of_ident tmp_id ^ " " ^
        type_pair_to_hyper_pair_name tmp_typ.aTypePairIdent ^ " " ^
        match catch_not_found (Hashtbl.find init_se) tmp_id with
        | Some v -> v ^ " (* " ^ tmp_name ^ " *) "
        | None -> "ht_default" ^ " (* " ^ tmp_name ^ " *) ");
      ind := !ind ^ "  "
    ) tmp_env;
    output_string out (!ind ^ "SpecTree.empty" ^
      String.make (List.length tmp_env) ')') in

  let rec prepare pure path dest c = match c.aCmdDesc with
    | ACskip | ACyield _ | ACcall _ | ACemit _ | ACload _ | ACstore _ | ACconstr _
    | ACfail | ACexternal _ -> ()

    | AClet (tmp_id, _, c1, c2) -> prepare pure (1::path) tmp_id c1; prepare pure (2::path) dest c2
    | ACsequence (c1, c2) -> prepare pure (1::path) dest c1; prepare pure (2::path) dest c2
    | ACcond (_, c1, c2) -> prepare pure (1::path) dest c1; prepare pure (2::path) dest c2
    | ACfor (_, _, _, _, _, c1, None) -> prepare pure path dest c1
    | ACassert c1 -> prepare pure path dest c1
    | ACdeny c1 -> prepare pure path dest c1
    | ACghost c1 -> prepare pure path dest c1
    | ACfirst (_, _, _, _, _, n_c, c1, c2, c3, None) ->
      prepare true (1::path) n_c c1; prepare pure (2::path) dest c2; prepare pure (3::path) dest c3
    | ACfold (_, _, _, _, _, _, _, _, n_c, c1, None) -> prepare true path n_c c1

    | ACfor (n_iter, i, e_start, n_end, e_end, c1, Some cc) ->
      (* FOR (*NUM*)    i     = 0      TO (*HOLDER*) n      DO s.run i *)
      if pure then
        coqgen_fatal_error __LOC__ "prepare_command"
          "for command under pure context";
      prepare pure path dest c1;

      let slice_name = create_name cc.aCapturedName in
      let init_se = Hashtbl.create (List.length c.aCmdEnv) in
      output_string out ("\n  Definition " ^ slice_name ^ " :=\n    ");
      output_command env out base_layer obj method_full_name "      " pure path 
        { c with aCmdDesc = ACfor (n_iter, i, e_start, n_end, e_end, c1, None) };
      output_string out (".

  Lemma " ^ slice_name ^ "_wf
      : synth_stmt_wellformed " ^ slice_name ^ "
          " ^ string_of_ident dest ^ "
          ");
      output_tmp_env out "        " 0 c.aCmdEnv;
      output_string out (".
  Proof. solve_wellformed. Defined.

  Definition " ^ cc.aCapturedName);
      List.iter (fun (tmp, (tmp_id, _)) ->
        output_string out (" " ^ tmp);
        Hashtbl.add init_se tmp_id tmp
      ) cc.aCapturedTemp;
      (* Exactly what to evaluate/not evaluate was decided by trial an error to get small and tidy definitions. *)
      output_string out (" d :=
  Eval cbv -[Int256.repr Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub
             ret bind mzero get put modify
             GetHighData is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set Int256Tree.empty Int256Tree.t          

             " ^ env.folded_external_symbol_string ^ "
             " ^ !(env.folded_symbols) ^ "]
  in synth_stmt_spec_opt _ _ _
       " ^ slice_name ^ "_wf");
       add_folded_symbols env [cc.aCapturedName];
       output_init_se c.aCmdEnv init_se;
       output_string out "
       d _ (fun r => Some (ss_mem r)).\n"

    | ACmatch (e, cls) ->
      (* Other preparation for the embedded commands. *)
      List.iteri (fun i (_, _, cl) -> prepare pure (i::path) dest cl) cls;

      (* Preparation of the match bodies. *)
      List.iteri (fun i clause -> match clause with
		  | (_, tenv, body_cmd) -> 
	            let body_name = method_full_name ^ "_match_body_" ^string_of_path (i::path) in
		    output_string out ("
  Definition " ^ body_name ^ "_env := ");
		    output_tmp_env out "" 0 body_cmd.aCmdEnv;
		    output_string out (".\n");

		    output_string out ("
  Definition " ^ body_name ^ " := ");

		    output_command env out base_layer obj method_full_name  "    " pure (i::path) body_cmd;

		    output_string out (".
  Definition " ^ body_name ^ "_wf : synth_stmt_wellformed " ^ body_name ^" " ^ string_of_int dest ^ " " ^ body_name ^"_env.
  Proof. solve_wellformed. Defined.");
   	                               (* Todo: what is "dest" here?                          ^^^^*)
		                       (* it is given as an argument to prepare, which corresponds to the "current" dest at this point in the AST. *)
	output_string out (" \n");

	(* Match bodies typically have free variables in them, so it's better to not evaluate SpecTree.get.  *)
		    output_string out ("
  Definition " ^ body_name ^ "_spec :=
  Eval cbv -[Int256.repr Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub
             ret bind mzero get put modify
             GetHighData is_true bool_dec ZMap.get ZMap.set  Int256Tree.get Int256Tree.set SpecTree.get  Int256Tree.empty Int256Tree.t 
             " ^ env.folded_external_symbol_string ^ "
             " ^ !(env.folded_symbols) ^ "]
   in synth_stmt_spec_opt
     " ^ body_name ^"
     10
     " ^ body_name ^"_env
     " ^ body_name ^"_wf.\n");

	         ()
		 )
	cls;

      ()

    | ACfirst (n_iter, i, e_start, n_end, e_end, n_c, c1, c_then, c_else, Some cc) ->
      (* FIRST (*NUM*)    i     = 0      TO (*HOLDER*) n       *)
         (* DO (*HOLDER*) s.test i THEN i    ELSE FAIL *)
      prepare true (1::path) n_c c1;
      prepare pure (2::path) dest c_then;
      prepare pure (3::path) dest c_else;

      let slice_name = create_name cc.aCapturedName in
      let args = ref "" in
      let init_se = Hashtbl.create (List.length c.aCmdEnv) in
      List.iter (fun (tmp, (tmp_id, _)) ->
        args := !args ^ " " ^ tmp;
        Hashtbl.add init_se tmp_id tmp
      ) cc.aCapturedTemp;
      Hashtbl.add init_se n_iter i;

      output_string out ("\n  Definition " ^ slice_name ^ " :=\n    ");
      output_command env out base_layer obj method_full_name "      " true (1::path) c1;
      output_string out (".

  Lemma " ^ slice_name ^ "_wf
      : synth_stmt_wellformed " ^ slice_name ^ "
          " ^ string_of_ident n_c ^ "
          ");
      output_tmp_env out "        " 0 c1.aCmdEnv;
      output_string out (".
  Proof. solve_wellformed. Defined.

  Definition " ^ slice_name ^ "_P" ^ !args ^ " " ^ i ^ " d :=
  Eval cbv -[Int256.repr Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub
             ret bind mzero get put modify
             GetHighData is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set Int256Tree.empty Int256Tree.t
             " ^ env.folded_external_symbol_string ^ "
             " ^ !(env.folded_symbols) ^ "]
  in synth_stmt_spec_ret _ _ _
       " ^ slice_name ^ "_wf");
       add_folded_symbols env [cc.aCapturedName];
       output_init_se c1.aCmdEnv init_se;
       output_string out ("
       d.

  Definition " ^ cc.aCapturedName ^ !args ^ " start bound d :=
    let P " ^ i ^ " := is_true (" ^ slice_name ^ "_P" ^ !args ^ " " ^ i ^ " d) in
    let Pdec " ^ i ^ " : {P " ^ i ^ "} + {~ P " ^ i ^ "} :=
      bool_dec _ true in
    LangDef.min_ex P start bound Pdec.

  Definition " ^ slice_name ^ "_found :=\n    ");
      output_command env out base_layer obj method_full_name "      " pure (2::path) c_then;
      output_string out (".

  Lemma " ^ slice_name ^ "_found_wf
      : synth_stmt_wellformed " ^ slice_name ^ "_found
          " ^ string_of_ident dest ^ "
          ");
      output_tmp_env out "        " 0 c_then.aCmdEnv;
      output_string out (".
  Proof. solve_wellformed. Defined.

  Definition " ^ slice_name ^ "_found_spec" ^ !args ^ " " ^ i ^ " d :=
  Eval cbv -[Int256.repr Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub
             ret bind mzero get put modify
             GetHighData is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set Int256Tree.empty Int256Tree.t
             " ^ env.folded_external_symbol_string ^ "
             " ^ !(env.folded_symbols) ^ "]
  in " ^ synth_stmt pure ^ " _ _ _
       " ^ slice_name ^ "_found_wf");
       output_init_se c_then.aCmdEnv init_se;
       output_string out (".

  Definition " ^ slice_name ^ "_notfound :=\n    ");
      output_command env out base_layer obj method_full_name "      " pure (3::path) c_else;
      output_string out (".

  Lemma " ^ slice_name ^ "_notfound_wf
      : synth_stmt_wellformed " ^ slice_name ^ "_notfound
          " ^ string_of_ident dest ^ "
          ");
      output_tmp_env out "        " 0 c_else.aCmdEnv;
      output_string out (".
  Proof. solve_wellformed. Defined.

  Definition " ^ slice_name ^ "_notfound_spec" ^ !args ^ " " ^ i ^ " d :=
  Eval cbv -[Int256.repr Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub
             ret bind mzero get put modify
             GetHighData is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set Int256Tree.empty Int256Tree.t
             " ^ env.folded_external_symbol_string ^ "
             " ^ !(env.folded_symbols) ^ "]
  in " ^ synth_stmt pure ^ " _ _ _
       " ^ slice_name ^ "_notfound_wf");
       output_init_se c_else.aCmdEnv init_se;
       output_string out (".\n")

    | ACfold (n_iter, i_iter, e_start, n_end, e_end, n_acc, i_acc, e_init, n_c, c1, Some cc) ->
      prepare true path n_c c1;

      let slice_name = create_name cc.aCapturedName in
      let init_se = Hashtbl.create (List.length c.aCmdEnv) in
      output_string out ("\n  Definition " ^ slice_name ^ " :=\n    ");
      output_command env out base_layer obj method_full_name "      " true path
        { c with aCmdDesc = ACfold (n_iter, i_iter, e_start, n_end, e_end,
                                    n_acc, i_acc, e_init, n_c, c1, None) };
      output_string out (".

  Lemma " ^ slice_name ^ "_wf
      : synth_stmt_wellformed " ^ slice_name ^ "
          " ^ string_of_ident dest ^ "
          ");
      output_tmp_env out "        " 0 c.aCmdEnv;
      output_string out (".
  Proof. solve_wellformed. Defined.

  Definition " ^ cc.aCapturedName);
      List.iter (fun (tmp, (tmp_id, _)) ->
        output_string out (" " ^ tmp);
        Hashtbl.add init_se tmp_id tmp
      ) cc.aCapturedTemp;
      output_string out (" d :=
  Eval cbv -[Int256.repr Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub
             ret bind mzero get put modify
             GetHighData is_true bool_dec  ZMap.get ZMap.set Int256Tree.get Int256Tree.set Int256Tree.empty Int256Tree.t
             " ^ env.folded_external_symbol_string ^ "
             " ^ !(env.folded_symbols) ^ "]
  in synth_stmt_spec_ret _ _ _
       " ^ slice_name ^ "_wf");
       add_folded_symbols env [cc.aCapturedName];
       output_init_se c.aCmdEnv init_se;
       output_string out "
       d.\n"

  in prepare

let method_classify mt =
  (* is pure *) mt.aMethodKind = MKconst || mt.aMethodKind = MKconstghost,
  (* has return *) mt.aMethodReturnType.aTypeDesc <> ATbuiltin Tunit

let gen_object_definition env out base_layer_name i o =
  let unmingledFieldName f = 
    (* base_layer_name.aLayerName ^ "_" ^  *)
    o.aObjectName ^ "_" ^ f.aObjectFieldName in
  let unmingledMethodName m = 
    (* base_layer_name.aLayerName ^ "_" ^  *)
    o.aObjectName ^ "_" ^ m.aMethodName in 
  let _ = (* Outside of section: identifiers for methods and variables *)
    List.iteri (fun n m ->
      output_global_ident env ("ident_" ^ i ^ "_" ^ m.aMethodName) 
    ) o.aObjectMethods;
    List.iteri (fun n f ->
      if not f.aObjectFieldIsLogical then
        output_global_ident env ("var_" ^ i ^ "_" ^ unmingledFieldName f ^ "_ident")
    ) o.aObjectFields in

  let _ = (* Start of section: context *)
    output_string out ("
Section OBJECT_" ^ i ^ "_DEFINITION.
  Context`{HM : !HyperMem}.\n\n") in

  let _ =
    output_string out "  (* Object variables *)\n";
    List.iter (fun f ->
      let variable_coq_name = i ^ "_" ^ f.aObjectFieldName ^ "_var" in
      output_string out ("  Definition " ^ variable_coq_name ^ " := {|
    ltype_tp_marker := " ^ f.aObjectFieldType.aTypePairIdent ^ ";

    ltype_ident := HighValues.Field HighValues.Global " ^ (
      if f.aObjectFieldIsLogical then
        string_of_ident 99
      else
        "var_" ^ o.aObjectName ^ "_" ^ unmingledFieldName f ^ "_ident") ^ ";
    ltype_ghost := " ^ string_of_bool f.aObjectFieldIsLogical ^ ";

    ltype_get := " ^ unmingledFieldName f ^ ";
    ltype_set := update_" ^ unmingledFieldName f ^ ";

    ltype_set_ocond := otrue1;
    ltype_get_extra_ocond := otrue1
  |}.\n");
      if not f.aObjectFieldIsLogical then
        output_string out
#ifdef REDACTED
        ""
#else
        ("(*TODO: variables.*) (*  Definition " ^ i ^ "_" ^ unmingledFieldName f ^ "_globvar : AST.globvar type :=
    let ty := unpair_ty " ^ f.aObjectFieldType.aTypePairIdent ^ " in
    {| AST.gvar_info := ty;
       AST.gvar_init := AST.Init_space (sizeof ty) :: nil; (* XXX: until we can translate [Cval] to [AST.init_data] *)
       AST.gvar_readonly := false;
       AST.gvar_volatile := false
    |}.*)\n")
#endif
    ) o.aObjectFields in
  add_folded_symbols env @@ List.map (fun f ->
  unmingledFieldName f ^ " update_" ^ unmingledFieldName f
  ) o.aObjectFields;

  let _ = (* Methods *)
    List.iter (fun m ->
      let method_full_name = i ^ "_" ^ m.aMethodName in
      let mt = m.aMethodType in
      prepare_command env out base_layer_name i method_full_name
                      false [] Typecheck.function_start_id_num m.aMethodBody;
      output_string out ("\n  Definition " ^ method_full_name ^ " := {|
    FC_ident_start := BuiltinBase_local_ident_start;
    FC_params := ");
      output_params out m.aMethodArguments mt.aMethodArgumentTypes;
      output_string out (";
    FC_returns := " ^
        type_pair_to_hyper_pair_name mt.aMethodReturnType.aTypePairIdent ^ ";
    FC_body := ");
      output_command env out base_layer_name i method_full_name "      " false [] m.aMethodBody;
      output_string out "\n  |}.\n";

      let nargs, args = match mt.aMethodArgumentTypes with
        | [t] when t.aTypeDesc = ATbuiltin Tunit -> 0, ""
        | ts -> List.length ts,
                String.concat ""
                  (List.mapi (fun n _ -> " a" ^ string_of_int n) ts) in

      let is_pure, has_return = method_classify mt in
      
      let return_pick = match is_pure, has_return with
        | true, _ -> "evalStateT"
        | _, false -> "execStateT"
        | _, _ -> "runStateT" in
      (*let hyper_pair = type_pair_to_hyper_pair_name mt.aMethodReturnType.aTypePairIdent in
        let return_expr = match is_pure, has_return with
        | true, _ -> "(@sf_return _ " ^ hyper_pair ^ " r)"
        | _, false -> "(@sf_mem _ void_unit_pair r)"
        | _, _ -> "(@sf_mem _ " ^ hyper_pair ^ " r, @sf_return _ " ^ hyper_pair ^ " r)" in *)
      output_string out ("  Lemma " ^ method_full_name ^ "_wf
      : synth_func_wellformed " ^ method_full_name ^ ".
  Proof. solve_wellformed. Defined.
  Definition " ^ method_full_name ^ "_opt :") ;
  output_method_type_expr out mt;			 
  output_string out ("  := 
  Eval cbv -[" ^ cbv_ignore_base              
              ^ env.folded_external_symbol_string ^ "
             " ^ !(env.folded_symbols) ^ "]
  in synth_func_spec_opt " ^ method_full_name ^ " " ^ method_full_name ^ "_wf.
  Definition " ^ method_full_name ^ "_spec_hlist_opt args :=
    @apply_param_func " ^ method_full_name ^ ".(FC_params) _
                      (" ^ method_full_name ^ "_opt) args.

  Definition " ^ method_full_name ^ "_prim := {|
    PRIMident := ident_" ^ o.aObjectName ^ "_" ^ m.aMethodName ^ ";
    (* PRIMcc := AST.cc_default; *)
    PRIMghost := " ^ string_of_bool (mt.aMethodKind = MKghost ||
                                     mt.aMethodKind = MKconstghost) ^ ";
    PRIMpure := " ^ string_of_bool is_pure ^ ";
    PRIMargt_marker := " ^ method_full_name ^ ".(FC_params);
    PRIMret_marker := " ^ method_full_name ^ ".(FC_returns);
    PRIMcond := fun _ _ _ => True;
    (* PRIMsem := " ^ method_full_name ^ "_spec_hlist; *)
    PRIMsem_opt := " ^ method_full_name ^ "_spec_hlist_opt
  |}.

  Lemma " ^ method_full_name ^ "_spec_hlist_opt_eq :
    " ^ method_full_name ^ "_spec_hlist_opt =
    fun args => apply_param_func
      (synth_func_spec_opt " ^ method_full_name ^ " " ^ method_full_name ^ "_wf)
      args.
  Proof.\n" ^
"    cbv -[" ^ cbv_ignore_base 
             ^ env.folded_external_symbol_string ^ "
             " ^ !(env.folded_symbols) ^ "]. \n" ^
"     reflexivity.
  Qed.\n");
      (* Declare [*_spec] for concrete layer definition *)
      if mt.aMethodKind <> MKghost && mt.aMethodKind <> MKconstghost then begin
        output_string out ("  Definition " ^ method_full_name ^ "_cfun :=
  Eval cbv in synth_func_func " ^ method_full_name ^ ".

  Definition " ^ method_full_name ^ "_cond "^ args ^ " me d  :=
  Eval cbv -[" ^ cbv_ignore_base 
               ^ env.folded_external_symbol_string ^ "
             " ^ !(env.folded_symbols) ^ "]
    in");
	for i = 0 to nargs - 1 do
          output_string out ("
    ht_ft_cond a" ^ string_of_int i ^
            " -> ht_valid_ft_cond a" ^ string_of_int i ^ " ->")
        done;
        output_string out ("
    high_level_invariant d ->
    synth_func_cond " ^ method_full_name ^ " " ^ method_full_name ^ "_wf
								     " ^ args ^ " me d.\n");

        output_string out ("  
  Lemma " ^ method_full_name ^ "_cond_eq : forall " ^ args ^ " me d, 
    " ^method_full_name^"_cond " ^ args ^ " me d ->");
	for i = 0 to nargs - 1 do
          output_string out ("
    ht_ft_cond a" ^ string_of_int i ^
            " -> ht_valid_ft_cond a" ^ string_of_int i ^ " ->")
        done;
        output_string out ("
    high_level_invariant d ->
    synth_func_cond " ^ method_full_name ^ " " ^ method_full_name ^ "_wf " ^ args ^ " me d.
    Proof.
      intros " ^ args ^ " me d H_cond.
      cbv -[" ^ cbv_ignore_base ^ env.folded_external_symbol_string ^ "
             " ^ !(env.folded_symbols) ^ "].
       exact H_cond.
    Qed.

  Definition " ^ method_full_name ^ "_obligation "^ args ^ " me d  :=
  Eval cbv -[" ^ cbv_ignore_base ^ env.folded_external_symbol_string ^ "
             " ^ !(env.folded_symbols) ^ "]
    in");
	for i = 0 to nargs - 1 do
          output_string out ("
    ht_ft_cond a" ^ string_of_int i ^
            " -> ht_valid_ft_cond a" ^ string_of_int i ^ " ->")
        done;
        output_string out ("
    high_level_invariant d ->
    synth_func_obligation " ^ method_full_name ^ " " ^ method_full_name ^ "_wf
								     " ^ args ^ " me d.\n");

        output_string out ("  
  Lemma " ^ method_full_name ^ "_obligation_eq : forall " ^ args ^ " me d, 
    " ^method_full_name^"_obligation " ^ args ^ " me d ->");
	for i = 0 to nargs - 1 do
          output_string out ("
    ht_ft_cond a" ^ string_of_int i ^
            " -> ht_valid_ft_cond a" ^ string_of_int i ^ " ->")
        done;
        output_string out ("
    high_level_invariant d ->
    synth_func_obligation " ^ method_full_name ^ " " ^ method_full_name ^ "_wf " ^ args ^ " me d.
    Proof.
      intros " ^ args ^ " me d H_cond.
      cbv -[" ^ cbv_ignore_base ^ env.folded_external_symbol_string ^ "
             " ^ !(env.folded_symbols) ^ "].
       exact H_cond.
    Qed.\n");
	
        if m.aMethodSemantics = AStrap_info_get ||
           m.aMethodSemantics = AStrap_info_ret then begin
          output_string out ("
  Definition " ^ method_full_name ^ "_spec :=
  Eval cbv -[" ^ cbv_ignore_base ^ env.folded_external_symbol_string ^ "
             " ^ !(env.folded_symbols) ^ "]
  in apply_param_func (synth_func_spec_ret " ^ method_full_name ^ " " ^ method_full_name ^ "_wf) HNil.\n")
    end else begin (* [if] m.aMethodSemantics = AStrap_info_get || m.aMethodSemantics = AStrap_info_ret *)
            (*let fun_args = if (String.length args > 0) then ("fun " ^ args ^ " => ") else "" in *)
          output_string out ("
  Definition " ^ method_full_name ^ "_spec :=
  Eval cbv [sf_mem sf_return fst snd " ^ method_full_name ^ "_opt] in
    " ^ ("fun " ^ args ^ " me => ") ^
    return_pick ^ " (" ^ method_full_name ^ "_opt" ^ args ^ " me).
  Lemma " ^ method_full_name ^ "_spec_eq :
    " ^ method_full_name ^ "_spec =
    " ^ "fun " ^ args ^ " me => " ^
    return_pick ^ " (synth_func_spec_opt " ^ method_full_name ^ " " ^ method_full_name ^ "_wf" ^ args ^ " me).
  Proof.
    cbv -[" ^ cbv_ignore_base ^ env.folded_external_symbol_string ^ "
          " ^ !(env.folded_symbols) ^ "].
    reflexivity.
  Qed.\n")
        end (* [else] m.aMethodSemantics = AStrap_info_get || m.aMethodSemantics = AStrap_info_ret *)
    end; (* [if] mt.aMethodKind <> MKghost && mt.aMethodKind = MKconst *)

    output_string out ("
Global Opaque " ^ method_full_name ^"_opt.\n");						       
      
    (* Define the method in the link file. *)
    output_string (env.coq_LinkSource) ("
Definition " ^ method_full_name ^"_core := (@"^ method_full_name ^" Memimpl.mem memory_model_ops _ _ make_program_ops make_program_prf).
Definition " ^ method_full_name ^"_func := (synth_func_func " ^method_full_name^"_core).\n");

	      (* And its symbol. *)
    output_string env.coq_Symbols ("  (ident_"^method_full_name ^", \""^ method_full_name ^"\")::\n")
		  
    ) o.aObjectMethods in

  output_string out ("End OBJECT_" ^ i ^ "_DEFINITION.\n")

let generate_preserve_invariant_prop m spec_name context =
  let select_ops, select_HD = match context with
    | None -> "", ""
    | Some (ops, hd) -> "(data_ops := " ^ ops ^ ") ", "(HD := " ^ hd ^ ") " in
  match m.aMethodSemantics with
  | ASdefault ->
    if m.aMethodType.aMethodKind = MKconst then
      None
    else
      Some ("CompatGenSem.PreservesInvariants " ^ select_HD ^ spec_name)
  | ASsetCR3 -> Some ("PrimSemantics.SetCR3Invariants " ^ select_ops ^ "(fun d p => " ^ spec_name ^ " p d)")
  | ASassembly -> Some ("PrimSemantics.PrimInvariants " ^ select_ops ^ spec_name)
  | ASassembly' -> Some ("PrimSemantics.PrimInvariants " ^ select_ops ^ spec_name)
  | AStrap_info_get -> None
  | AStrap_info_ret -> None

let generate_compat_sem m spec_name =
  match m.aMethodSemantics with
  | ASdefault -> "CompatGenSem.gensem " ^ spec_name
  | ASsetCR3 -> "PrimSemantics.setCR3_compatsem (fun d p => "
              ^ spec_name ^ " p d)"
  | ASassembly -> "PrimSemantics.primcall_general_compatsem "
              ^ spec_name
  | ASassembly' -> "PrimSemantics.primcall_general_compatsem' (prim_ident := "
              ^ m.aMethodName ^ ") " ^ spec_name
  | AStrap_info_get -> "PrimSemantics.primcall_trap_info_get_compatsem "
              ^ spec_name
  | AStrap_info_ret -> "PrimSemantics.primcall_trap_info_ret_compatsem "
              ^ spec_name

let output_exists_prop out ind oi_over oi_under m as_lemma with_inv =
  (* if [not as_lemma] then output as an argument *)
  if as_lemma && with_inv then
    print_endline
      ("Warning: output_exists_prop with both as_lemma and with_inv being\n" ^
       "         true will results in compile error in Coq");
  let method_full_name_over = oi_over ^ "_" ^ m.aMethodName in
  let method_full_name_under = oi_under ^ "_" ^ m.aMethodName in
  let mt = m.aMethodType in
  let nargs, args = match mt.aMethodArgumentTypes with
    | [t] when t.aTypeDesc = ATbuiltin Tunit -> 0, ""
    | ts -> List.length ts,
            String.concat ""
              (List.mapi (fun n _ -> " a" ^ string_of_int n) ts) in
  if as_lemma then
    output_string out (ind ^ "Lemma " ^ method_full_name_over ^ "_exists :\n" ^ ind ^ "  ")
  else
    output_string out (ind ^ "  (");
  if m.aMethodSemantics = AStrap_info_get || m.aMethodSemantics = AStrap_info_ret then begin
    output_string out ("forall j d1 d2,\n" ^ ind ^
      "    relate_AbData j d1 d2 ->\n" ^ ind ^
      (if with_inv then
         "    high_level_invariant d1 ->\n" ^ ind ^
         "    high_level_invariant d2 ->\n" ^ ind
       else
         "") ^
      (if m.aMethodSemantics = AStrap_info_get then
         "    " ^ method_full_name_over ^ "_spec d1 = " ^ method_full_name_under ^ "_spec d2"
       else
         "    Values.val_inject j (" ^ method_full_name_over ^ "_spec d1)\n" ^ ind ^
         "                        (" ^ method_full_name_under ^ "_spec d2)"));
    if not as_lemma then begin
      output_char out ')'
    end else begin
      (* Recall that to give the layerlib semantics for a layer we use various semantic combinators. Two of these,
         trap_info_ret and trap_info_get, are slightly special, because they expect a function which does not
         return an option.
         Therefore, the passthrough proofs for functions using these semantics look slightly different from
         other passthrough proofs.
         Currently, we are using these semantics for only two functions, which happens to have particularly trivial
         passthrough proof obligations, so everything works. If we wanted to use the semantics more generally, the
         programmer would have to give manual proofs, so we should write the proof skeleton to a FooProof.v file,
         instead of the current behaviour which writes the proof to an auto-generated file. *)
      output_string out (".\n" ^ ind ^
        "(* XXX: This looks bad but it's temporary--there should be a separate file for these lemmas *)\n" ^ ind ^
        "Lemma " ^ method_full_name_over ^ "_spec_cond d :\n" ^ ind ^
        "    synth_func_spec_cond " ^ method_full_name_over ^ " " ^ method_full_name_over ^ "_wf HNil d.\n" ^ ind ^
        "Proof.\n" ^ ind ^
        "  (* XXX: Only works if no [CCrespec], [CCrespec_opt], or [ECrespec] is used. *)\n" ^ ind ^
        "  compute.\n" ^ ind ^
        "  exact I.\n" ^ ind ^
          "Qed.\n" ^ ind)
       (* not sure what this is about, it doesn't seem to generate a valid file: *)		       
(*
	  ^
        "Proof (fun j d1 d2 rel =>\n" ^ ind ^
        "  synth_func_spec_ret_relate_0\n" ^ ind ^
        "    " ^ method_full_name_over ^ "_passthrough_prf\n" ^ ind ^
        "    " ^ method_full_name_over ^ "_wf\n" ^ ind ^
        "    " ^ method_full_name_over ^ "_passthrough_cond\n" ^ ind ^
        "    j d1 d2 rel\n" ^ ind ^
        "    (" ^ method_full_name_over ^ "_spec_cond d1)).\n" ) *)
    end  (* [else] not as_lemma *)
  end  (* [if] m.aMethodSemantics = AStrap_info_get || m.aMethodSemantics = AStrap_info_ret *)
  else match method_classify mt with
  | true, _ ->   (* is pure *)
    output_string out ("forall j" ^ args ^ " d1 d2 r,\n" ^ ind ^
      "    relate_AbData j d1 d2 ->\n" ^ ind ^
      (if with_inv then
         "    high_level_invariant d1 ->\n" ^ ind ^
         "    high_level_invariant d2 ->\n" ^ ind
       else
         "") ^
      "    " ^ method_full_name_over ^ "_spec" ^ args ^ " d1 = Some r ->\n" ^ ind ^
      "    " ^ method_full_name_under ^ "_spec" ^ args ^ " d2 = Some r");
    if not as_lemma then
      output_char out ')'
    else begin
      output_string out (".\n" ^ ind ^
        "Proof.\n" ^ ind ^
        "  intro j.\n" ^ ind ^
        "  rewrite * " ^ method_full_name_over ^ "_spec_eq.\n" ^ ind ^
        "  exact (synth_func_relate_" ^ string_of_int nargs ^ "_pure\n" ^ ind ^
        "          " ^ method_full_name_over ^ "_passthrough_prf\n" ^ ind ^
        "          " ^ method_full_name_over ^ "_wf\n" ^ ind ^
        "          " ^ method_full_name_over ^ "_passthrough_cond\n" ^ ind ^
        "          j");
        (* [nargs + 1] copies of the trivial proof *)
        for i = 0 to nargs do output_string out " (fun _ _ x => x)" done;
        output_string out (").\n" ^ ind ^ "Qed.\n")
    end  (* [else] not with_proof *)

  | _, true ->  (* has return value *)
    output_string out ("forall j" ^ args ^ " d1 d2 d1' r,\n" ^ ind ^
      "    relate_AbData j d1 d2 ->\n" ^ ind ^
      (if with_inv then
         "    high_level_invariant d1 ->\n" ^ ind ^
         "    high_level_invariant d2 ->\n" ^ ind
       else
         "") ^
      "    " ^ method_full_name_over ^ "_spec" ^ args ^ " d1 = Some (r, d1') ->\n" ^ ind ^
      "    exists d2',\n" ^ ind ^
      "      " ^ method_full_name_under ^ "_spec" ^ args ^ " d2 = Some (r, d2') /\\\n" ^ ind ^
      "      relate_AbData j d1' d2'");
    if not as_lemma then
      output_char out ')'
    else begin
      output_string out (".\n" ^ ind ^
        "Proof.\n" ^ ind ^
        "  intro j.\n" ^ ind ^
        "  rewrite * " ^ method_full_name_over ^ "_spec_eq.\n" ^ ind ^
        "  exact (synth_func_relate_" ^ string_of_int nargs ^ "\n" ^ ind ^
        "          " ^ method_full_name_over ^ "_passthrough_prf\n" ^ ind ^
        "          " ^ method_full_name_over ^ "_wf\n" ^ ind ^
        "          " ^ method_full_name_over ^ "_passthrough_cond\n" ^ ind ^
        "          j");
        (* [nargs + 1] copies of the trivial proofs *)
        for i = 0 to nargs do output_string out " (fun _ _ x => x)" done;
        output_string out (").\n" ^ ind ^ "Qed.\n")
    end  (* [else] not with_proof *)

  | _, false ->  (* has no return value *)
    output_string out ("forall j" ^ args ^ " d1 d2 d1',\n" ^ ind ^
      "    relate_AbData j d1 d2 ->\n" ^ ind ^
      (if with_inv then
         "    high_level_invariant d1 ->\n" ^ ind ^
         "    high_level_invariant d2 ->\n" ^ ind
       else
         "") ^
      "    " ^ method_full_name_over ^ "_spec" ^ args ^ " d1 = Some d1' ->\n" ^ ind ^
      "    exists d2',\n" ^ ind ^
      "      " ^ method_full_name_under ^ "_spec" ^ args ^ " d2 = Some d2' /\\\n" ^ ind ^
      "      relate_AbData j d1' d2'");
    if not as_lemma then
      output_char out ')'
    else begin
      output_string out (".\n" ^ ind ^
        "Proof.\n" ^ ind ^
        "  intro j.\n" ^ ind ^
        "  rewrite * " ^ method_full_name_over ^ "_spec_eq.\n" ^ ind ^
        "  exact (synth_func_relate_" ^ string_of_int nargs ^ "_void\n" ^ ind ^
        "          " ^ method_full_name_over ^ "_passthrough_prf\n" ^ ind ^
        "          " ^ method_full_name_over ^ "_wf\n" ^ ind ^
        "          " ^ method_full_name_over ^ "_passthrough_cond\n" ^ ind ^
        "          j");
        (* [nargs] copies of the trivial proofs *)
        for i = 1 to nargs do output_string out " (fun _ _ x => x)" done;
        output_string out (").\n" ^ ind ^ "Qed.\n")
    end  (* [else] not with_proof *)

let output_match_prop out ind oi m as_lemma =  (* if [not as_lemma] then output as an argument *)
  let method_full_name = oi ^ "_" ^ m.aMethodName in
  let mt = m.aMethodType in
  let nargs, args = match mt.aMethodArgumentTypes with
    | [t] when t.aTypeDesc = ATbuiltin Tunit -> 0, ""
    | ts -> List.length ts,
            String.concat ""
              (List.mapi (fun n _ -> " a" ^ string_of_int n) ts) in
  let is_pure, has_return = method_classify mt in
  if not is_pure && m.aMethodSemantics <> AStrap_info_get &&
                    m.aMethodSemantics <> AStrap_info_ret then begin
    if as_lemma then
      output_string out (ind ^ "Lemma " ^ method_full_name ^ "_match :\n" ^ ind ^ "  ")
    else
      output_string out (ind ^ "  (");
    if has_return then begin
      output_string out ("forall j d d' m" ^ args ^ " r,\n" ^ ind ^
        "    match_AbData d m j ->\n" ^ ind ^
        "    " ^ method_full_name ^ "_spec" ^ args ^ " d = Some (r, d') ->\n" ^ ind ^
        "    match_AbData d' m j");
      if not as_lemma then
        output_string out ") ->\n"
      else
        output_string out (".\n" ^ ind ^
          "Proof.\n" ^ ind ^
          "  rewrite * " ^ method_full_name ^ "_spec_eq.\n" ^ ind ^
          "  exact (synth_func_match_" ^ string_of_int nargs ^ "\n" ^ ind ^
          "          " ^ method_full_name ^ "_passthrough_prf\n" ^ ind ^
          "          " ^ method_full_name ^ "_wf\n" ^ ind ^
          "          " ^ method_full_name ^ "_passthrough_cond).\n" ^ ind ^
          "Qed.\n")
    end else begin  (* [if] has_return *)
      output_string out ("forall j d d' m" ^ args ^ ",\n" ^ ind ^
        "    match_AbData d m j ->\n" ^ ind ^
        "    " ^ method_full_name ^ "_spec" ^ args ^ " d = Some d' ->\n" ^ ind ^
        "    match_AbData d' m j");
      if not as_lemma then
        output_string out ") ->\n"
      else
        output_string out (".\n" ^ ind ^
          "Proof.\n" ^ ind ^
          "  rewrite * " ^ method_full_name ^ "_spec_eq.\n" ^ ind ^
          "  exact (synth_func_match_" ^ string_of_int nargs ^ "_void\n" ^ ind ^
          "          " ^ method_full_name ^ "_passthrough_prf\n" ^ ind ^
          "          " ^ method_full_name ^ "_wf\n" ^ ind ^
          "          " ^ method_full_name ^ "_passthrough_cond).\n" ^ ind ^
          "Qed.\n")
    end;  (* [else] has_return *)
    true
  end else
    false

let gen_layer_linksource env i l  =
  output_string (env.coq_LinkSource) ("\nDefinition "^ i ^ "_impl : res LAsm.module := \n");

  let unmingledFieldName o f = 
    (* l.aLayerName ^ "_" ^  *)
    o.aObjectName ^ "_" ^ f.aObjectFieldName in
  let iter_functions action =
      List.iter (fun (_, o) ->
        if o.aObjectRequireImpl then
          List.iter (fun m -> action o  m)
           (o.aObjectMethods @ o.aObjectProcedures @ o.aObjectFunctions)
	) l.aLayerFreshObjects in

   iter_functions (fun o m ->
      output_string env.coq_LinkSource
       ("  M_" ^ o.aObjectName ^ "_" ^ m.aMethodName ^ " <- CompCertiKOS.transf_module (ident_"^ o.aObjectName ^"_"^ m.aMethodName ^" ↦ "^ o.aObjectName ^ "_" ^ m.aMethodName ^"_func);\n"));

   output_string env.coq_LinkSource ("  ret (");
   
   List.iter (fun (_, o) ->
     if o.aObjectRequireImpl then
       List.iter (fun f ->
	 if not f.aObjectFieldIsLogical then
	   output_string env.coq_LinkSource
			 ("var_"^o.aObjectName^"_"^ unmingledFieldName o f ^"_ident ↦ " ^o.aObjectName^ "_"^ unmingledFieldName o f ^"_globvar ⊕ ");
	   output_string env.coq_Symbols
			 ("  (var_"^o.aObjectName^"_"^ unmingledFieldName o f ^"_ident, \"" ^o.aObjectName^ "_"^ unmingledFieldName o f ^"\")::\n");	 
       ) o.aObjectFields
   ) l.aLayerFreshObjects;

   iter_functions (fun o m ->
      output_string env.coq_LinkSource
       ("  M_" ^ o.aObjectName ^ "_" ^ m.aMethodName ^ "  ⊕ "));   
   output_string env.coq_LinkSource "∅).\n"

let gen_linksource_prelude env fileDeclarations =
  output_string env.coq_LinkSource "
Require Import compcert.lib.Coqlib.
Require Import liblayers.lib.Decision.
Require Import liblayers.compcertx.ErrorMonad.
Require Import liblayers.compcertx.MakeProgram.
Require Import compcertx.common.MemimplX.
Require Import liblayers.compcertx.MakeProgramImpl.
Require Import liblayers.compat.CompatLayers.
Require Import mcertikos.layerlib.LAsmModuleSemDef.
Require Import mcertikos.layerlib.CompCertiKOS.

Local Instance mwd_ops: MemWithData.UseMemWithData Memimpl.mem.\n\n";

    List.iter (function
     | i, ADlayer l ->
	output_string env.coq_LinkSource ("Require Import " ^ env.project_name ^ ".Layer" ^ l.aLayerName ^ ".\n")
     | _, _ -> ()
     ) fileDeclarations;

    output_string env.coq_Symbols "
Open Scope string_scope.

Definition symbols: list (ident * string) :=\n"
		 
let gen_linksource env fileDeclarations =
  output_string env.coq_LinkSource "\nDefinition certikos := \n";
  List.iter (function
     | i, ADlayer l ->
	output_string env.coq_LinkSource ("  M"^i^" <- "^ i ^ "_impl;\n")
     | _, _ -> ()
  ) fileDeclarations;
  output_string env.coq_LinkSource "  ret (";  
  List.iter (function
     | i, ADlayer l ->
	output_string env.coq_LinkSource (" M"^i^" ⊕");
     | _, _ -> ()
  ) fileDeclarations;
  output_string env.coq_LinkSource " ∅).\n\n";
  output_string env.coq_Symbols "  nil.\n"

		
let gen_object_sim env cur_layer_name base_layer i o =
  let out =
#ifdef REDACTED
    open_out "/dev/null" in
#else
    new_file env ("ObjSim" ^ i)
              ("Require Import liblayers.compcertx.MakeProgram.\n" ^
               "Require Import liblayers.compcertx.MemWithData.\n" ^
               "Require Import layerlib.RefinementTactic.\n" ^
               "Require Import layerlib.RefinementTacticAux.\n\n" ^
               "Require Import " ^ env.project_name ^ ".Layer" ^ cur_layer_name ^ ".\n" ^
               if base_layer.aLayerName = builtin_base_layer_name then
                 ""
               else
                 "Require Import " ^ env.project_name ^ ".LSim" ^ base_layer.aLayerName ^ ".\n")
              file_class_ObjAux in
#endif
  let _ = output_string out "\nContext {Hmem: Mem.MemoryModel mem}.
Context`{Hmwd: UseMemWithData mem}.
Context`{make_program_ops: !MakeProgramOps Clight.function Ctypes.type Clight.fundef Ctypes.type}.
Context`{Hmake_program: !MakeProgram Clight.function Ctypes.type Clight.fundef Ctypes.type}.
Instance GlobalLayerSpec : LayerSpecClass := {
  make_program_ops := make_program_ops;
  Hmake_program := Hmake_program;
  GetHighData := global_abstract_data_type
}.
Context`{HM : HyperMem (LayerSpec := GlobalLayerSpec)}.\n\n" in

  let unmingledFieldName o f = 
    (* base_layer.aLayerName ^ "_" ^  *)
    o.aObjectName ^ "_" ^ f.aObjectFieldName in

  let _ = (* Variable passthrough premises *)
    List.iter (fun (_, o) -> List.iter (fun f ->
      output_string out ("  Context {" ^
        o.aObjectName ^ "_" ^ unmingledFieldName o f ^ "_var_pt_prf : variable_passthrough_prf " ^
        o.aObjectName ^ "_" ^ unmingledFieldName o f ^ "_var}.\n")
    ) o.aObjectFields) base_layer.aLayerAllObjects;
    List.iter (fun f ->
      output_string out ("  Context {" ^
        i ^ "_" ^ unmingledFieldName o f ^ "_var_pt_prf : variable_passthrough_prf " ^
        i ^ "_" ^ unmingledFieldName o f ^ "_var}.\n")
    ) o.aObjectFields in

  let _ = (* Methods passthrough lemmas *)
    List.iter (fun m ->
      let method_full_name = i ^ "_" ^ m.aMethodName in
      let mt = m.aMethodType in
      output_string out ("
  Lemma " ^ method_full_name ^ "_passthrough_prf :
      function_constr_passthrough_prf " ^ method_full_name ^ ".
  Proof. solve_passthrough_prf @" ^ method_full_name ^ ". Qed.
  Lemma " ^ method_full_name ^ "_passthrough_cond :
      synth_func_passthrough_cond " ^ method_full_name ^ " " ^ method_full_name ^ "_wf.
  Proof.
    (* XXX: Only works if no [CCrespec], [CCrespec_opt], or [ECrespec] is used. *)
    compute.
    exact I.
  Qed.

  Global Instance " ^ method_full_name ^ "_prim_passthrough
      : primitive_passthrough_prf " ^ method_full_name ^ "_prim.
  Proof. esplit.
    (*
    - unfold PRIMsem, " ^ method_full_name ^ "_prim.
      rewrite " ^ method_full_name ^ "_spec_hlist_eq.
      exact (synth_func_spec_relate
              " ^ method_full_name ^ "_passthrough_prf
              " ^ method_full_name ^ "_wf
              " ^ method_full_name ^ "_passthrough_cond).
    *)
    - unfold PRIMsem_opt, " ^ method_full_name ^ "_prim.
      rewrite " ^ method_full_name ^ "_spec_hlist_opt_eq.
      exact (synth_func_spec_opt_relate
              " ^ method_full_name ^ "_passthrough_prf
              " ^ method_full_name ^ "_wf
              " ^ method_full_name ^ "_passthrough_cond).
    (*
    - unfold PRIMsem, " ^ method_full_name ^ "_prim.
      rewrite " ^ method_full_name ^ "_spec_hlist_eq.
      exact (synth_func_spec_match
              " ^ method_full_name ^ "_passthrough_prf
              " ^ method_full_name ^ "_wf
              " ^ method_full_name ^ "_passthrough_cond).
    *)
    - unfold PRIMsem_opt, " ^ method_full_name ^ "_prim.
      rewrite " ^ method_full_name ^ "_spec_hlist_opt_eq.
      exact (synth_func_spec_opt_match
              " ^ method_full_name ^ "_passthrough_prf
              " ^ method_full_name ^ "_wf
              " ^ method_full_name ^ "_passthrough_cond).
  Qed.\n");
      if mt.aMethodKind <> MKghost && mt.aMethodKind <> MKconstghost then begin
        output_char out '\n';
        output_exists_prop out "  " i i m true false;
        output_char out '\n';
        if output_match_prop out "  " i m true then
          output_char out '\n';
        output_string out ("  Section " ^ m.aMethodName ^ ".\n");
        let spec_name = i ^ "_" ^ m.aMethodName ^ "_spec" in
        begin match generate_preserve_invariant_prop m spec_name (Some ("cdataOpsHigh", "cdataHigh")) with
        | None -> ()
        | Some prop -> output_string out ("    Context`{inv : !" ^ prop ^ "}.\n")
        end;
        begin match generate_preserve_invariant_prop m spec_name (Some ("cdataOpsLow", "cdataLow")) with
        | None -> ()
        | Some prop -> output_string out ("    Context`{inv0 : !" ^ prop ^ "}.\n\n")
        end;
        if m.aMethodSemantics = AStrap_info_ret then
          output_string out "    Context`{low1 : !low_level_invariant_impl (data_ops0 := cdataOpsLow)}.\n\n";
        output_string out (
"    Lemma " ^ i ^ "_" ^ m.aMethodName ^ "_sim :
      forall id,
        sim (crel (CompatRel0 := crel_prf (compatrel := Hcompatrel)) _ _)
            (id ↦ " ^ generate_compat_sem m spec_name ^ ")
            (id ↦ " ^ generate_compat_sem m spec_name ^ ").
    Proof.");
        begin match m.aMethodSemantics with
        | ASassembly | ASassembly' -> output_string out ("
      (* semantics assembly['] *)
      intros. layer_sim_simpl. compatsim_simpl (@match_AbData). intros.
      inv match_extcall_states.
      exploit " ^ i ^ "_" ^ m.aMethodName ^ "_exists; eauto 1; intros (labd' & HP & rel).
      match_external_states_simpl.
      eapply " ^ i ^ "_" ^ m.aMethodName ^ "_match; eauto.\n")

        | ASsetCR3 -> output_string out ("
      (* semantics SetCR3 *)
      intros. layer_sim_simpl. compatsim_simpl (@match_AbData). intros.
      CommonTactic.inv_val_inject.
      assert (H8 := H7).
      eapply AuxLemma.inject_forward_equal' in H8; eauto 1. inv H8.
      exploit " ^ i ^ "_" ^ m.aMethodName ^ "_exists; eauto 1; intros (labd' & HP & rel).
      match_external_states_simpl.
      rewrite Int256.add_zero; eauto.
      eapply " ^ i ^ "_" ^ m.aMethodName ^ "_match; eauto.\n")

        | AStrap_info_get -> output_string out ("
      (* semantics trap_info_get *)
      intros. layer_sim_simpl. compatsim_simpl (@match_AbData). intros.
      inv match_extcall_states.
      match_external_states_simpl.
      erewrite " ^ i ^ "_" ^ m.aMethodName ^ "_exists; eauto.\n")

        | AStrap_info_ret -> output_string out ("
      (* semantics trap_info_ret *)
      intros. layer_sim_simpl. compatsim_simpl (@match_AbData). intros.
      inv match_extcall_states.
      exploit (low_level_invariant_impl_eq (data_ops0 := cdataOpsLow)); eauto; inversion 1.
      match_external_states_simpl.
      eapply " ^ i ^ "_" ^ m.aMethodName ^ "_exists; eauto.\n")

        | ASdefault ->
          if fst (method_classify m.aMethodType) then begin  (* is_pure *)
            output_string out ("
      (* pure method *)
      intros. layer_sim_simpl. compatsim_simpl (@match_AbData). intros.
      inv_semof H0.
      inversion H0; subst; simpl in H0;
      match_external_states_csem; auto;
      erewrite " ^ i ^ "_" ^ m.aMethodName ^ "_exists; eauto; reflexivity.\n")

          end else begin  (* [if] is_pure *)
            output_string out ("
      (* non-pure C-primitives *)
      intros. layer_sim_simpl. compatsim_simpl (@match_AbData). intros.
      try inv_semof H0.
      try (inversion H0; subst; simpl in H0).
      exploit " ^ i ^ "_" ^ m.aMethodName ^ "_exists; eauto 1; intros (labd' & HP & rel).
      match_external_states_csem; auto;
      eapply " ^ i ^ "_" ^ m.aMethodName ^ "_match; eauto.\n")
          end  (* [else] is_pure *)
        end;  (* match m.aMethodSemantics *)

        output_string out (
"    Qed.
  End " ^ m.aMethodName ^ ".\n")
      end  (* if mt.aMethodKind <> MKghost && mt.aMethodKind <> MKconstghost *)
    ) o.aObjectMethods in

  (*
  let _ = (* Unable to generate simulation proofs consistently--prepare a
             skeleton to guide user interventien. *)
    let out, sim_tbl =
      new_incremental_file
        env
        ("Obj" ^ i ^ "Proofs")
        ("Require Import liblayers.compcertx.MakeProgram.\n" ^
         "Require Import liblayers.compcertx.MemWithData.\n" ^
         "Require Import layerlib.RefinementTactic.\n\n" ^
         "Require Import " ^ env.project_name ^ ".Layer" ^ cur_layer_name ^ ".\n")
        (fun out -> output_string out "
Context {Hmem: Mem.MemoryModel mem}.
Context `{Hmwd: UseMemWithData mem}.
Context `{make_program_ops: !MakeProgramOps Clight.function Ctypes.type Clight.fundef Ctypes.type}.
Context `{Hmake_program: !MakeProgram Clight.function Ctypes.type Clight.fundef Ctypes.type}.
Instance GlobalLayerSpec : LayerSpecClass := {
  make_program_ops := make_program_ops;
  Hmake_program := Hmake_program;
  GetHighData := global_abstract_data_type
}.

Context `{HM : HyperMem (LayerSpec := GlobalLayerSpec)}.\n";
         List.iter (fun (_, o) -> List.iter (fun f ->
           output_string out ("Context {" ^
             o.aObjectName ^ "_" ^ f.aObjectFieldName ^ "_var_pt_prf : variable_passthrough_prf " ^
             o.aObjectName ^ "_" ^ f.aObjectFieldName ^ "_var}.\n")
         ) o.aObjectFields) base_layer.aLayerAllObjects;
         List.iter (fun f ->
           output_string out ("Context {" ^
             i ^ "_" ^ f.aObjectFieldName ^ "_var_pt_prf : variable_passthrough_prf " ^
             i ^ "_" ^ f.aObjectFieldName ^ "_var}.\n")
         ) o.aObjectFields)
        (Str.regexp ("\\bLemma +" ^ i ^ "_\\(.+\\)_sim\\b"))
        file_class_ObjAux in
    List.iter (fun m ->
      if m.aMethodType.aMethodKind <> MKghost && m.aMethodType.aMethodKind <> MKconstghost &&
         not (Hashtbl.mem sim_tbl m.aMethodName) then begin
        let spec_name = i ^ "_" ^ m.aMethodName ^ "_spec" in
        output_string out ("\nSection " ^ m.aMethodName ^ ".\n");
        begin match generate_preserve_invariant_prop m spec_name (Some ("cdataOpsHigh", "cdataHigh")) with
        | None -> ()
        | Some prop -> output_string out ("  Context`{inv : !" ^ prop ^ "}.\n")
        end;
        begin match generate_preserve_invariant_prop m spec_name (Some ("cdataOpsLow", "cdataLow")) with
        | None -> ()
        | Some prop -> output_string out ("  Context`{inv0 : !" ^ prop ^ "}.\n\n")
        end;
        if m.aMethodSemantics = AStrap_info_ret then
          output_string out "  Context`{low1 : !low_level_invariant_impl (data_ops0 := cdataOpsLow)}.\n\n";
        output_string out (
"  Lemma " ^ i ^ "_" ^ m.aMethodName ^ "_sim :
    forall id,
      sim (crel (CompatRel0 := crel_prf (compatrel := Hcompatrel)) _ _)
          (id ↦ " ^ generate_compat_sem m spec_name ^ ")
          (id ↦ " ^ generate_compat_sem m spec_name ^ ").
  Proof.");
        begin match m.aMethodSemantics with
        | ASassembly | ASassembly' -> output_string out ("
    (* semantics assembly['] *)
    intros. layer_sim_simpl. compatsim_simpl (@match_AbData). intros.
    inv match_extcall_states.
    exploit " ^ i ^ "_" ^ m.aMethodName ^ "_exists; eauto 1; intros (labd' & HP & rel).
    match_external_states_simpl.
    eapply " ^ i ^ "_" ^ m.aMethodName ^ "_match; eauto.\n")
        | ASsetCR3 -> output_string out ("
    (* semantics SetCR3 *)
    intros. layer_sim_simpl. compatsim_simpl (@match_AbData). intros.
    CommonTactic.inv_val_inject.
    assert (H8 := H7).
    eapply AuxLemma.inject_forward_equal' in H8; eauto 1. inv H8.
    exploit " ^ i ^ "_" ^ m.aMethodName ^ "_exists; eauto 1; intros (labd' & HP & rel).
    match_external_states_simpl.
    rewrite Int256.add_zero; eauto.
    eapply " ^ i ^ "_" ^ m.aMethodName ^ "_match; eauto.\n")
        | AStrap_info_get -> output_string out ("
    (* semantics trap_info_get *)
    intros. layer_sim_simpl. compatsim_simpl (@match_AbData). intros.
    inv match_extcall_states.
    match_external_states_simpl.
    erewrite " ^ i ^ "_" ^ m.aMethodName ^ "_exists; eauto.\n")
        | AStrap_info_ret -> output_string out ("
    (* semantics trap_info_ret *)
    intros. layer_sim_simpl. compatsim_simpl (@match_AbData). intros.
    inv match_extcall_states.
    exploit (low_level_invariant_impl_eq (data_ops0 := cdataOpsLow)); eauto; inversion 1.
    match_external_states_simpl.
    eapply " ^ i ^ "_" ^ m.aMethodName ^ "_exists; eauto.\n")
        | ASdefault ->
          if fst (method_classify m.aMethodType) then begin  (* is_pure *)
            output_string out ("
    (* pure method *)
    intros. layer_sim_simpl. compatsim_simpl (@match_AbData). intros.
    match_external_states_simpl.
    erewrite " ^ i ^ "_" ^ m.aMethodName ^ "_exists; eauto; reflexivity.\n")

            (*
            ; (* XXX: hack for boolean return value *)
            if m.aMethodType.aMethodReturnType.aTypeDesc = ATbuiltin Tbool then
              output_string out "    (* XXX: hack for boolean return value *)
    destruct a; constructor.\n";
            *)

          end else begin  (* [if] is_pure *)
            output_string out ("
    (* non-pure C-primitives *)
    intros. layer_sim_simpl. compatsim_simpl (@match_AbData). intros.
    exploit " ^ i ^ "_" ^ m.aMethodName ^ "_exists; eauto 1; intros (labd' & HP & rel).
    match_external_states_simpl.");

            (*
            (* XXX: hack for boolean return value *)
            if m.aMethodType.aMethodReturnType.aTypeDesc = ATbuiltin Tbool then
              output_string out "
    (* XXX: hack for boolean return value *)
    destruct a; constructor.";
            *)

            output_string out ("
    eapply " ^ i ^ "_" ^ m.aMethodName ^ "_match; eauto.\n")
          end  (* [else] is_pure *)
        end;  (* match m.aMethodSemantics *)
        output_string out (
"  Qed.
End " ^ m.aMethodName ^ ".\n")
      end
    ) o.aObjectMethods;
    *)
  output_string out ("\nEnd EdsgerGen.\n");
  close_out out

let generate_low_level_invariant ind j f t : string option * string option =
  let rec gen_list ind f t lvl : string list * string list = match t.aTypeDesc with
    (*
    | ATbuiltin Tval -> [inj ^ "\n  " ^ ind ^ f ^ "\n  " ^ ind ^ f],
                        ["Val.has_type " ^ f ^ " AST.Tint"]
    *)
    | ATbuiltin _ -> [], []

    (*
    | ATdata (_, ATsingleton c) ->
      output_constr ind (fun fld -> "(" ^ fld ^ " " ^ f ^ ")") c lvl
    | ATdata (_, ATbranches cs) ->
      output_string out ("match " ^ f ^ " with");
      List.iter (fun c ->
        output_string out ("\n" ^ ind ^ "| " ^ c.aTypeConstrName ^ " " ^
          String.concat " " (List.map fst c.aTypeConstrArgs) ^ " => ");
        match c.aTypeConstrImpl with
        | Some { aImplDesc = ACdefault } -> output_string out "False"
        | Some _ -> output_constr ("  " ^ ind) (fun fld -> fld) c lvl
        | None -> coqgen_fatal_error __LOC__ "output_valid_ft_cond"
                    ("Provable data type with constructor " ^
                     c.aTypeConstrName ^ " with no implementation")
      ) cs;
      output_string out ("\n" ^ ind ^ "end")
    *)
  | ATdata (_, ATsingleton c) -> [], [] (* XXX *)
  | ATdata (_, ATbranches cs) -> [], [] (* XXX *)
  | ATlist _                  -> [], [] (* XXX *)
  | ATprod (t1, t2) ->
    let t1inj, t1typed = gen_list ind ("(fst " ^ f ^ ")") t1 (lvl + 1) in
    let t2inj, t2typed = gen_list ind ("(snd " ^ f ^ ")") t2 (lvl + 1)
    in t1inj @ t2inj, t1typed @ t2typed
  | ATarray (n, t') ->
    let var = "n" ^ string_of_int lvl in
    let inj, typed = gen_option ("  " ^ ind) ("(ZMap.get " ^ var ^ " " ^ f ^ ")")
                                t' lvl in
    (match inj with
     | None -> []
     | Some s -> ["(forall " ^ var ^ ", 0 <= " ^ var ^ " < " ^ string_of_int n ^
                  " ->\n  " ^ ind ^ s ^ ")"]),
    (match typed with
     | None -> []
     | Some s -> ["(forall " ^ var ^ ", 0 <= " ^ var ^ " < " ^ string_of_int n ^
                    " ->\n  " ^ ind ^ s ^ ")"])
  | ATmapping _ -> [], []
  | ATexternal { aEXTypeLowLevelInv = None } -> [], []
  | ATexternal { aEXTypeLowLevelInv = Some s } ->
    ["(" ^ s ^ " " ^ j ^ " " ^ f ^ " " ^ f ^ ")"], []
  (*
  and output_constr ind get_field c lvl = match c.aTypeConstrArgs with
    | [] -> output_string out "True"
    | args ->
      let first = ref true in
      List.iter (fun (i, t') ->
        if !first
          then first := false
          else output_string out ("\n" ^ ind ^ "/\\ ");
        output ("  " ^ ind) (get_field i) t' (lvl + 1)
      ) args
  *)
  and gen_option ind f t lvl : string option * string option =
    let inj, typed = gen_list ind f t lvl
    in list_to_option inj, list_to_option typed
  and list_to_option = function
    | [] -> None
    | lst -> Some (String.concat " /\\ " lst)
  in gen_option ind f t 0

let builtin_base_layer =
  { aLayerName = builtin_base_layer_name;
    aLayerType = {
      aLayerBase = {
        aLayerSignatureName = builtin_base_layer_name ^ "_base";
        aLayerSignatureSlots = [];
        aLayerSignatureSuppressError = false
      };
      aLayerSignature = {
        aLayerSignatureName = builtin_base_layer_name ^ "_inter";
        aLayerSignatureSlots = [];
        aLayerSignatureSuppressError = false
      }
    };

    aLayerAccessor = AAnone;
    aLayerInvariant = None;

    aLayerFreshObjects = [];
    aLayerPassthroughObjects = [];
    aLayerAllObjects = [];

    aLayerTipObjectSet = IdentSet.empty;
    aLayerKeelObjectSet = IdentSet.empty;

    aLayerDesc = ALbottom
  }

let gen_layer env i l =
  let _ = print_endline ("This is layer " ^ i ) in

  let has_base_layer, base_layer =
    match l.aLayerDesc with
    | ALbottom ->                false, builtin_base_layer
    | ALontop l' ->              true,  l'
    | ALrefine_bottom (l', p) -> true,  l' in
    (*
    | ALrefine_ontop _ -> false, "**RefinedLayersNotSupported**", l in
    *)
  let base_layer_name = base_layer.aLayerName in
  let accessor_requirement = match l.aLayerAccessor with
    | AAnone -> ""
    | AALoadStoreSem1 -> "Require        mcertikos.flatmem.LoadStoreSem1.\n"
    | AALoadStoreSem2 -> "Require        mcertikos.flatmem.LoadStoreSem2.\n"
    | AALoadStoreSem3 -> "Require        mcertikos.flatmem.LoadStoreSem3.\n" in

  let out = new_file env ("Layer" ^ i)
              (
               "Require Import DeepSpec.lib.Monad.Monad.\n" ^
               "Require Import DeepSpec.lib.Monad.MonadState.\n" ^
               "Require Import DeepSpec.lib.Monad.StateMonad.\n" ^
               "Require Import DeepSpec.lib.Monad.OptionMonad.\n" ^
               "Require Import DeepSpec.lib.Monad.MonadZero.\n" ^
               "Require Import DeepSpec.core.SynthesisStmt.\n" ^
               "Require Import DeepSpec.core.SynthesisFunc.\n" ^
               "Require Import backend.MachineModel.\n" ^
               "Existing Instance MonadState_DS.\n" ^
               "Existing Instance MonadZero_DS.\n" ^
               accessor_requirement ^
               if has_base_layer then
                 "Require Export " ^ env.project_name ^ ".Layer" ^ base_layer_name ^ ".\n"
               else
                 "")
              file_class_Layers in
  let _ = output_string out "\n
Context {memModelOps : MemoryModelOps mem}.
Instance GlobalLayerSpec : LayerSpecClass := {
  memModelOps := memModelOps;
  GetHighData := global_abstract_data_type 
}.
\n" in


  let foreach_field step =
    List.iter (fun (_, o) ->
      List.iter (fun f -> step (o.aObjectName, f)) o.aObjectFields
    ) l.aLayerAllObjects in

  let high_level_invariant_proof, high_level_invariant_name =
    match l.aLayerInvariant with
    | None -> "I", fun _ -> "True"
    | Some s -> i ^ "_init_global_abstract_data_high_level_invariant",
                fun abd -> s ^ " " ^ abd in
                
  let unmingledFieldName o f = 
    (* l.aLayerName ^ "_" ^  *)
    o.aObjectName ^ "_" ^ f.aObjectFieldName in
  let unmingledFieldNameIO io f = 
    (* l.aLayerName ^ "_" ^  *)
    io ^ "_" ^ f.aObjectFieldName in

  let _ = (* invariants *)
    (* kernel_mode: hard coded for CertiKOS only *)
    output_string out ("
Context`{global_abdata : !GlobalAbData init_global_abstract_data global_low_level_invariant}.
Definition " ^ i ^ "_kernel_mode (abd : global_abstract_data_type) :=");
    let have_clause = ref false in
    foreach_field (fun (io, f) ->
      if f.aObjectFieldType.aTypeDesc = ATbuiltin Tbool &&
         (unmingledFieldNameIO io f = "ikern" || unmingledFieldNameIO io f = "ihost")
      then begin
        if !have_clause then output_string out " /\\";
        output_string out (" " ^ unmingledFieldNameIO io f ^ " abd = true");
        have_clause := true
      end);
    if not !have_clause then output_string out " True";
    output_string out (".\nGlobal Arguments " ^ i ^ "_kernel_mode / abd.\n") in

  let _ =  (* Typeclass summarizing proof dependencies *)
    let record_field_leftover = ref "\n  " in
    output_string out ("
Class Layer_" ^ i ^ "_Context_prf  := {
  (* ensuring global empty data matches those in the object definitions *)");
    foreach_field (fun (io, f) ->
      output_string out (!record_field_leftover ^
        i ^ "_init_" ^ unmingledFieldNameIO io f ^ "_eq : " ^
        unmingledFieldNameIO io f ^ " init_global_abstract_data = ");
      output_compile_time_constant out "    " f.aObjectFieldInitial;
      record_field_leftover := ";\n  "
    );
    if high_level_invariant_proof <> "I" then begin
      output_string out (!record_field_leftover ^
        high_level_invariant_proof ^ " :\n    " ^
        high_level_invariant_name "init_global_abstract_data");
      record_field_leftover := ";\n  "
    end;
    record_field_leftover := !record_field_leftover ^
      "(* satisfy all ground base layers' empty data high-level invariant requirements *)\n  ";

    let foreach_ground_base_layer f =
      let rec run l = match l.aLayerDesc with
        | ALbottom -> ()
        | ALontop l' -> f l'; run l'
        | ALrefine_bottom (l', _) -> f l'; run l'
      in run l in
    foreach_ground_base_layer (fun l -> match l.aLayerInvariant with
      | Some s ->
        output_string out (!record_field_leftover ^
          i ^ "_init_global_abstract_data_" ^ l.aLayerName ^
          "_high_level_invariant :\n    " ^
          s ^ " init_global_abstract_data");
        record_field_leftover := ";  "
      | None -> ()
    );
    output_string out ("
}.
Context`{CTXT_prf : !Layer_" ^ i ^ "_Context_prf}.\n") in

  let _ = (* Over/UnderlaySpecClass *)
    output_string out ("
Instance " ^ i ^ "_data_ops : CompatDataOps global_abstract_data_type := {
  empty_data := init_global_abstract_data;
  high_level_invariant d := " ^ high_level_invariant_name "d" ^ ";\n" ^
"}.

Instance " ^ i ^ "_data : CompatData global_abstract_data_type := {\n" ^
  "empty_data_high_level_invariant := " ^ high_level_invariant_proof ^ "
}.

Instance " ^ i ^ "_overlay_spec : OverlaySpecClass := {\n" ^
"}.\n
\n");

    if has_base_layer then begin
      (* Realize base layer's requirements -- [base_layer_name ^ "_Layer"]
         coming soon *)
      output_string out ("
(* (* TODO: add this back in for the Ethereum backend. *)
Global Instance Layer_" ^ i ^ "'" ^ base_layer_name ^ "_Context_prf : Layer_" ^ base_layer_name ^ "_Context_prf.
Proof. esplit; apply CTXT_prf.\n" ^
#ifndef REDACTED
"  (*
  - intros; simpl.
    rewrite " ^ i ^ "_AbData_get_set.
    destruct abd; reflexivity.
  - intros; simpl.
    rewrite " ^ i ^ "_AbData_get_set, " ^ i ^ "_AbData_set_set.
    reflexivity.
  - simpl.
    rewrite " ^ i ^ "_AbData_get_empty_data.
    reflexivity.
  - admit.
  *)" ^
#endif
"Qed.\n");
      output_string out ("Context`{" ^ base_layer_name ^ "_pres_inv : !" ^
                         base_layer_name ^ "_preserves_invariants}.\n*)\n")
    end;  (* if has_base_layer *)

    output_string out ("
Instance " ^ i ^ "_underlay_spec : UnderlaySpecClass := {
  cdataOpsLow := " ^
    (if has_base_layer
     then base_layer_name ^ "_data_ops"
     else "@BuiltinBase_data_ops GlobalLayerSpec init_global_abstract_data")
  ^ ";
  cdataLow := " ^ base_layer_name ^ "_data;\n" ^
#ifndef REDACTED
"  (*GetLowLayer := " ^ base_layer_name ^ "_Layer *)\n" ^
#endif
"}.\n\n") in

  let _ =
    List.iter (fun (_, o) ->
      gen_object_definition env out base_layer o.aObjectName o;
      gen_object_sim env l.aLayerName base_layer o.aObjectName o
    ) l.aLayerFreshObjects;
    let sim_out =
#ifdef REDACTED
    open_out "/dev/null" in
#else
    new_file env ("LSim" ^ i) "" file_class_NoDefaultImports in
#endif
    if has_base_layer then
      output_string sim_out ("Require Export " ^ env.project_name ^
                             ".LSim" ^ base_layer_name ^ ".\n");
    List.iter (fun (_, o) ->
      output_string sim_out ("Require Export " ^ env.project_name ^
                             ".ObjSim" ^ o.aObjectName ^ ".\n")
    ) l.aLayerFreshObjects;
    close_out sim_out in

#ifdef REDACTED
  let old_out = out in
  let out = open_out "/dev/null" in
#endif

  let _ = (* Start of section: context *)
    output_string out ("(* (*Temporarily omitted in the Ethereum version.*)\n\nSection LAYER_" ^ i ^ "_DEFINITION.") in

  let iter_nonghost_methods action = List.iter (fun m ->
    if m.aMethodType.aMethodKind <> MKghost &&
       m.aMethodType.aMethodKind <> MKconstghost
      then action m) in
  let _ = (* We're now ready to declare primitives *)
    (* Instantiate [_prim] to layer (will be used by upper layers when called. *)
    List.iter (fun (s, o) ->
      List.iter (fun m ->
        output_string out ("
  Definition " ^ i ^ "_" ^ s ^ "_" ^ m.aMethodName ^ "_prim := " ^
          o.aObjectName ^ "_" ^ m.aMethodName ^ "_prim.")
      ) o.aObjectMethods
    ) l.aLayerFreshObjects;
    List.iter (fun (s, o) ->
      List.iter (fun m ->
        output_string out ("
  Definition " ^ i ^ "_" ^ s ^ "_" ^ m.aMethodName ^ "_prim := " ^
          base_layer_name ^ "_" ^ s ^ "_" ^ m.aMethodName ^ "_prim.")
      ) o.aObjectMethods
    ) l.aLayerPassthroughObjects;
    output_char out '\n' in

  let _ =
    (* Fulfilling included object methods' requirements *)
    let class_field_leftover = ref "\n    " in
    output_string out ("\n  Class " ^ i ^ "_preserves_invariants := {");
    List.iter (fun (s, o) ->
      iter_nonghost_methods (fun m ->
        match generate_preserve_invariant_prop m (o.aObjectName ^ "_" ^ m.aMethodName ^ "_spec") None with
        | None -> ()
        | Some preserve_invariant_prop ->
          output_string out (!class_field_leftover ^
            i ^ "_" ^ o.aObjectName ^ "_" ^ m.aMethodName ^
            "_preserves_invariants :>\n      " ^ preserve_invariant_prop);
          class_field_leftover := ";\n    "
      ) o.aObjectMethods
    ) (l.aLayerFreshObjects @ l.aLayerPassthroughObjects);
    if l.aLayerAccessor <> AAnone then
      output_string out (!class_field_leftover ^
        i ^ "_trapinfo_set_preserves_invariants :>
      LoadStoreDef.TrapinfoSetInvariant;\n    " ^
        i ^ "_flatmem_store_preserves_invariants :>
      LoadStoreDef.FlatmemStoreInvariant (flatmem_store := " ^
        (if l.aLayerAccessor = AALoadStoreSem1 then
           "FlatMemoryAux.flatmem_store'"
         else
           "FlatMemoryAux.flatmem_store") ^ ")");
    output_string out ("\n  }.
  Context`{" ^ i ^ "_pres_inv : !" ^ i ^ "_preserves_invariants}.\n") in

  (* Finally, produce the [compatlayer]s. *)
  let iter_exporting_methods do_fresh do_passthrough =
    List.iter (fun (s, o) ->
      let underlay_same_slot_object_methods =
        try (List.assoc s l.aLayerType.aLayerBase.aLayerSignatureSlots)
              .aSignatureMethods
        with Not_found -> [] in
      iter_nonghost_methods (fun m ->
        if List.mem_assoc m.aMethodName underlay_same_slot_object_methods then
          do_passthrough s o.aObjectName m
        else
          do_fresh s o.aObjectName m
      ) o.aObjectMethods
    ) l.aLayerFreshObjects;
    List.iter (fun (s, o) ->
      iter_nonghost_methods (fun m ->
        do_passthrough s o.aObjectName m
      ) o.aObjectMethods
    ) l.aLayerPassthroughObjects in

  let output_layer_definition def_name fresh_only accessor =
    begin match accessor with
    | AAnone -> ()
    | AALoadStoreSem1 -> output_string out ("
  Definition " ^ i ^ "_exec_loadex {F V} := LoadStoreSem1.exec_loadex1 (F := F) (V := V).
  Definition " ^ i ^ "_exec_storeex {F V} := LoadStoreSem1.exec_storeex1 (F := F) (V := V) (flatmem_store := FlatMemoryAux.flatmem_store').\n")
    | AALoadStoreSem2 -> output_string out ("
  Definition " ^ i ^ "_exec_loadex {F V} := LoadStoreSem2.exec_loadex2 (F := F) (V := V).
  Definition " ^ i ^ "_exec_storeex {F V} := LoadStoreSem2.exec_storeex2 (F := F) (V := V) (flatmem_store := FlatMemoryAux.flatmem_store).\n")
    | AALoadStoreSem3 -> output_string out ("
  Definition " ^ i ^ "_exec_loadex {F V} := LoadStoreSem3.exec_loadex3 (F := F) (V := V).
  Definition " ^ i ^ "_exec_storeex {F V} := LoadStoreSem3.exec_storeex3 (F := F) (V := V) (flatmem_store := FlatMemoryAux.flatmem_store).\n")
    end;
    let line_leftover = ref "\n    " in
    let output_prim s oi m =
      if m.aMethodSemantics = ASdefault then begin
        List.iter (fun t -> gen_type_arg_ret env t) m.aMethodType.aMethodArgumentTypes;
        gen_type_arg_ret env m.aMethodType.aMethodReturnType;
      end;
      output_string out (!line_leftover ^
        m.aMethodName ^ " ↦ " ^
          generate_compat_sem m (oi ^ "_" ^ m.aMethodName ^ "_spec"));
      line_leftover := "\n      ⊕ " in
    let output_nothing s oi m = () in
    output_string out ("
  Definition " ^ def_name ^ " : CompatLayerDef.compatlayer GetHighDataX :=");
    iter_exporting_methods
      (if fresh_only then output_prim else output_nothing)
      (if fresh_only then output_nothing else output_prim);
    if accessor <> AAnone then
      output_string out (!line_leftover ^
        "CompatLayerDef.accessors ↦ {| CompatLayerDef.exec_load := @" ^ i ^ "_exec_loadex; CompatLayerDef.exec_store := @" ^ i ^ "_exec_storeex |}");
    output_string out ".\n";
    in

  let has_fresh = ref false in
  let has_passthrough = ref false in
  let _ = (* Wrapping everything up *)
(*    iter_exporting_methods (fun _ _ _ -> has_fresh := true)
                           (fun _ _ _ -> has_passthrough := true); *)
    iter_exporting_methods (fun n oname m -> 
			      has_fresh := true)
                           (fun n oname m -> 
			      has_passthrough := true);
    if not !has_fresh || not !has_passthrough then
        output_layer_definition (i ^ "_Layer") !has_fresh l.aLayerAccessor
    else begin
      let layer_fresh = i ^ "_Layer_fresh" in
      let layer_passthrough = i ^ "_Layer_passthrough" in
      output_layer_definition layer_fresh true AAnone;
      output_layer_definition layer_passthrough false l.aLayerAccessor;
      output_string out ("
  Definition " ^ i ^ "_Layer : CompatLayerDef.compatlayer GetHighDataX :=
    " ^ layer_fresh ^ " ⊕ " ^ layer_passthrough ^ ".\n")
    end
  in output_string out ("End LAYER_" ^ i ^ "_DEFINITION.\n*)\nEnd EdsgerGen.\n");
     close_out out;
#ifdef REDACTED
     output_string old_out ("\nEnd EdsgerGen.\n");
     close_out old_out;
#endif
     !has_fresh, !has_passthrough

let gen_layer_refinement env i has_fresh has_passthrough l =
  if l.aLayerDesc <> ALbottom &&
     List.for_all (fun (_, o) -> not o.aObjectIsTrusted) l.aLayerFreshObjects then begin
    let base_layer, is_refine, refine_prop =
      match l.aLayerDesc with
      | ALbottom -> coqgen_fatal_error __LOC__ "gen_layer_refinement" "inconsistent rematch"
      | ALontop l' ->              l', false, "***OnTopLayersNoProp***"
      | ALrefine_bottom (l', p) -> l', true, p in
    let base_layer_name, base_layer_export_objects =
      base_layer.aLayerName,
      base_layer.aLayerFreshObjects @ base_layer.aLayerPassthroughObjects in

    let out =
#ifdef REDACTED
        open_out "/dev/null" in
#else
        new_file env ("Refine" ^ i)
                ("Require Import layerlib.LayerCalculusLemma.\n" ^
                 "Require Import layerlib.RefinementTactic.\n" ^
                 "Require Import layerlib.RefinementTacticAux.\n" ^
                 "Require Import liblayers.compcertx.MakeProgram.\n" ^
                 "Require Import liblayers.compcertx.MemWithData.\n\n" ^
                 "Require Import " ^ env.project_name ^ ".Layer" ^ i ^ ".\n" ^
                 "Require Import " ^ env.project_name ^ ".LSim" ^ base_layer_name ^ ".\n"
                 (*
                 String.concat "" (List.map (fun (_, o) ->
                   "Require Import " ^ env.project_name ^
                   ".ObjSim" ^ o.aObjectName ^ ".\n"
                 ) l.aLayerPassthroughObjects) *))
                file_class_Refinements in
#endif
    let _ = output_string out ("
Context {mem}`{Hmem: Mem.MemoryModel mem}.
Context`{Hmwd: UseMemWithData mem}.
Context`{make_program_ops: !MakeProgramOps Clight.function Ctypes.type Clight.fundef Ctypes.type}.
Context`{Hmake_program: !MakeProgram Clight.function Ctypes.type Clight.fundef Ctypes.type}.
Instance GlobalLayerSpec : LayerSpecClass := {
  make_program_ops := make_program_ops;
  Hmake_program := Hmake_program;
  GetHighData := global_abstract_data_type
}.
Context`{global_abdata : !GlobalAbData init_global_abstract_data global_low_level_invariant}.
Context`{CTXT_prf : !Layer_" ^ i ^ "_Context_prf}.
Context`{" ^ base_layer_name ^ "_pres_inv : !" ^ base_layer_name ^ "_preserves_invariants}.
Context`{" ^ i ^ "_pres_inv : !" ^ i ^ "_preserves_invariants}.

Existing Instances " ^ i ^ "_overlay_spec " ^ i ^ "_underlay_spec.\n") in

    let unmingledFieldName o f = 
      (* l.aLayerName ^ "_" ^  *)
      o.aObjectName ^ "_" ^ f.aObjectFieldName in

    let unmingledFieldNameOI oi f = 
      (* l.aLayerName ^ "_" ^  *)
      oi ^ "_" ^ f.aObjectFieldName in

    let relate_RData_name = (* Toward [HyperMem]: relate_RData *)
      if is_refine then
        refine_prop
      else begin
        let record_field_leftover = ref "\n  " in
        output_string out ("
Record relate_RData (j : meminj) (habd : GetHighData) (labd : GetLowData) : Prop
    := mkrelate_RData {");
        List.iter (fun (_, o) ->
          record_field_leftover := !record_field_leftover ^
            "(* " ^ o.aObjectName ^ " *)\n  ";
          if IdentSet.mem o.aObjectName base_layer.aLayerTipObjectSet then
            List.iter (fun f ->
              output_string out (!record_field_leftover ^
                unmingledFieldName o f ^ "_re : ");
(*              output_ht_inject out "    " ("(" ^ f.aObjectFieldName ^ " habd)")
                                          ("(" ^ f.aObjectFieldName ^ " labd)")
                                          f.aObjectFieldType; *)
              record_field_leftover := ";\n  "
            ) o.aObjectFields
        ) base_layer.aLayerAllObjects;
        output_string out "\n}.\n";
        "relate_RData"
      end in  (* [else] is_refine *)

    let iter_implemented_fields action =
      List.iter (fun (_, o) ->
        if o.aObjectRequireImpl then
          List.iter (fun f ->
            if not f.aObjectFieldIsLogical then
              action o.aObjectName f
          ) o.aObjectFields
      ) l.aLayerFreshObjects in

    let has_implemented_fields = (* Toward [HyperMem]: match_RData *)
      let record_field_leftover = ref (false, "
Record match_RData (habd : GetHighData) (m : mem) (j : meminj) : Prop
    := MATCH_RDATA {\n  ") in
      iter_implemented_fields (fun oi f ->
        output_string out (snd !record_field_leftover ^ unmingledFieldNameOI oi f ^
          "_ma : variable_match " ^ oi ^ "_" ^ unmingledFieldNameOI oi f ^
          "_var habd m");
        record_field_leftover := (true, ";\n  ")
      );
      if fst !record_field_leftover then
        output_string out "\n}.\n"
      else
        output_string out "
Inductive match_RData: GetHighData -> mem -> meminj -> Prop :=
| MATCH_RDATA: forall habd m f, match_RData habd m f.\n";
      output_string out "
Local Hint Resolve MATCH_RDATA.\n";
      fst !record_field_leftover in

    let _ = (* Toward [HyperMem]: CompatRel *)
      output_string out ("
Global Instance rel_ops: CompatRelOps GetHighDataX GetLowDataX :=
{
  relate_AbData f d1 d2 := " ^ relate_RData_name ^ " f d1 d2;
  match_AbData d1 m f := match_RData d1 m f;
  new_glbl := ");
      iter_implemented_fields (fun oi f ->
        output_string out ("var_" ^ oi ^ "_" ^ unmingledFieldNameOI oi f ^ "_ident :: ")
      );
      output_string out "nil
}.\n";
      iter_implemented_fields (fun oi f ->
        output_string out ("
Global Instance " ^ oi ^ "_" ^ unmingledFieldNameOI oi f ^ "_hyper_ltype_static :
    HyperLTypeStatic " ^ oi ^ "_" ^ unmingledFieldNameOI oi f ^ "_var new_glbl.
Proof.
  split; try solve
    [ Decision.decision
    | simpl; auto
    | simpl " ^ oi ^ "_" ^ unmingledFieldNameOI oi f ^ "_var.(ltype_offset);
      rewrite Int256.unsigned_zero; apply Z.divide_0_r ].
Qed.\n")
      );
      if is_refine then
        output_string out "Context`{rel_prf : !CompatRel GetHighDataX GetLowDataX}.\n"
      else begin
        output_string out "
Lemma relate_incr:
  forall abd abd' f f',
    relate_RData f abd abd' ->
    inject_incr f f' ->
    relate_RData f' abd abd'.
Proof.
  inversion 1; subst; intros; simpl in *.
  repeat match goal with
  | H : _ /\\ _ |- _ => destruct H
  end.
  repeat (constructor; simpl; eauto).
Qed.";
        if has_implemented_fields then
          output_string out "
Global Instance rel_prf: CompatRel GetHighDataX GetLowDataX.
Proof.
  constructor; [ destruct 1 .. |]; intros.
  - constructor; eapply inject_match_correct; eauto with typeclass_instances.
  - constructor; eapply store_match_correct; eauto with typeclass_instances.
  - constructor; eapply alloc_match_correct; eauto with typeclass_instances.
  - constructor; eapply free_match_correct; eauto with typeclass_instances.
  - constructor; eapply storebytes_match_correct; eauto with typeclass_instances.
  - eapply relate_incr; eauto.
Qed.\n"
        else
          output_string out "
Global Instance rel_prf: CompatRel GetHighDataX GetLowDataX.
Proof.
  constructor; intros; simpl; trivial.
  eapply relate_incr; eauto.
Qed.\n"
      end  (* [else] is_refine *) in

    let _ = (* Construct [HyperMem] *)
      output_string out ("
(*
Local Instance: ExternalCallsOps (mwd GetLowDataX) := CompatExternalCalls.compatlayer_extcall_ops " ^ base_layer_name ^ "_Layer.
Local Instance: CompilerConfigOps _ := CompatExternalCalls.compatlayer_compiler_config_ops " ^ base_layer_name ^ "_Layer.
*)

Instance " ^ i ^ "_hypermem : MemoryModel.HyperMem
  := { Hcompatrel := {| crel_prf := rel_prf |} }.\n") in

    let iter_nonghost_methods action = List.iter (fun m ->
      if m.aMethodType.aMethodKind <> MKghost &&
         m.aMethodType.aMethodKind <> MKconstghost
        then action m) in
    let iter_passthrough_methods action =
      List.iter (fun (s, o) ->
        let underlay_same_slot_object =
          try List.assoc s base_layer_export_objects
          with Not_found -> Typecheck.dummy_object "***dummy_empty_object***" in
        iter_nonghost_methods (fun m ->
          if List.exists (fun m' -> m'.aMethodName = m.aMethodName)
                         underlay_same_slot_object.aObjectMethods then
            action o.aObjectName underlay_same_slot_object.aObjectName m
        ) o.aObjectMethods
      ) l.aLayerFreshObjects;
      List.iter (fun (s, o) ->
        let underlay_same_slot_object_name =
          try (List.assoc s base_layer_export_objects).aObjectName
          with Not_found -> coqgen_fatal_error __LOC__ "gen_layer_refinement"
                              "Passthrough object not found in base layer exports"
        in iter_nonghost_methods
             (action o.aObjectName underlay_same_slot_object_name)
             o.aObjectMethods
      ) l.aLayerPassthroughObjects in

    let _ = (* Last two implemented instances before the passthrough proof *)
      let class_field_leftover = ref "\n  " in
      output_string out ("
Class " ^ i ^ "_Underlay_preserves_invariants := {");
      List.iter (fun (_, o) ->
        iter_nonghost_methods (fun m ->
          match generate_preserve_invariant_prop m
                  (o.aObjectName ^ "_" ^ m.aMethodName ^ "_spec")
                  (Some ("cdataOpsLow", "cdataLow")) with
          | None -> ()
          | Some preserve_invariant_prop ->
            output_string out (!class_field_leftover ^
              i ^ "_Underlay_" ^ o.aObjectName ^ "_" ^ m.aMethodName ^
              "_preserves_invariants :>\n    " ^ preserve_invariant_prop ^
              " | 5");
            class_field_leftover := ";\n  "
        ) o.aObjectMethods
      ) base_layer_export_objects;
      output_string out ("
}.
Instance " ^ i ^ "'" ^ base_layer_name ^ "_preserves_invariants : " ^ i ^ "_Underlay_preserves_invariants.
Proof. esplit; apply " ^ base_layer_name ^ "_pres_inv. Defined.\n");
      if l.aLayerAccessor <> AAnone then
        output_string out "
(* XXX: only works with LoadStoreSem1, not tested beyond MContainer *)
Global Instance: LoadStoreDef.LoadStoreProp (ops := rel_ops) (hflatmem_store:= FlatMemoryAux.flatmem_store') (lflatmem_store:= FlatMemoryAux.flatmem_store').
Proof.
  accessor_prop_tac.
  eapply ObjFlatMem.flatmem_store'_exists; eauto.
Qed.\n" in

    let _ = (* Last two groups of obligations: refinements (behavior &
               abstraction), and simulations *)
      let class_field_leftover = ref (false, "
Class " ^ i ^ "_refinement_prf : Prop := {\n  ") in
      iter_passthrough_methods (fun oi_over oi_under m ->
        if oi_over <> oi_under then
          if m.aMethodSemantics = AStrap_info_get ||
             m.aMethodSemantics = AStrap_info_ret then begin
          (*
          if fst (method_classify m.aMethodType) then begin  (* is_pure *)
          *)
            output_string out (snd !class_field_leftover ^
              i ^ "_" ^ oi_over ^ "_" ^ m.aMethodName ^ "_sim :\n");
            if not is_refine then begin
              output_exists_prop out "  " oi_under oi_under m false false;
              output_string out " ->\n"
            end;
            output_string out (
"    (forall id,
      sim (crel (CompatRel0 := rel_prf) _ _)
          (id ↦ " ^ generate_compat_sem m (oi_over ^ "_" ^ m.aMethodName ^ "_spec") ^ ")
          (id ↦ " ^ generate_compat_sem m (oi_under ^ "_" ^ m.aMethodName ^ "_spec") ^ "))");
            class_field_leftover := (true, ";\n  ")
          end else begin  (* [if] is_pure *)
            output_string out (snd !class_field_leftover ^
              i ^ "_" ^ oi_over ^ "_" ^ m.aMethodName ^ "_exists :\n");
            if not is_refine then begin
              output_exists_prop out "  " oi_under oi_under m false false;
              output_string out " ->\n"
            end;
            output_exists_prop out "  " oi_over oi_under m false true;
            class_field_leftover := (true, ";\n  ")
          end  (* [else] is_pure *)
      );
      if fst !class_field_leftover then
        output_string out ("\n}.
Context`{" ^ i ^ "_ref_prf : !" ^ i ^ "_refinement_prf}.\n") in

    let _ = (* Wrapping everything up *)
#ifndef REDACTED
      output_string out ("
(*
Lemma passthrough_correct:
  sim (crel (CompatRel0 := rel_prf) _ _) " ^ i ^ "_Layer" ^
    (if has_fresh then "_passthrough " else " ") ^ base_layer_name ^ "_Layer.
Proof.
  Local Opaque simRR mapsto layer_mapsto_primitive.
  unfold GlobalLayerSpec, MemoryModel.GetHighDataX.
  simpl.

  sim_oplus; simpl.

  Local Transparent simRR mapsto layer_mapsto_primitive.\n");
      iter_passthrough_methods (fun oi_over oi_under m ->
        if oi_over = oi_under then begin  (* true passthrough *)
          output_string out ("
  - (* " ^ oi_over ^ "_" ^ m.aMethodName ^ ": true passthrough *)
    exact (" ^ oi_over ^ "_" ^ m.aMethodName ^ "_sim " ^ m.aMethodName);
          if m.aMethodSemantics = ASassembly || m.aMethodSemantics = ASassembly' ||
             m.aMethodSemantics = ASsetCR3 then
            output_string out (" (inv0 := " ^ base_layer.aLayerName ^ "_" ^
              oi_under ^ "_" ^ m.aMethodName ^ "_preserves_invariants)");
          output_string out ").\n"
        end else  (* [if] oi_over = oi_under *)
          match m.aMethodSemantics with
          | ASassembly | ASassembly' -> output_string out ("
  - (* " ^ oi_over ^ "_" ^ m.aMethodName ^ ": semantics assembly['] *)
    layer_sim_simpl; compatsim_simpl (@match_AbData); intros.
    inv match_extcall_states.");
            if is_refine then
              output_string out ("
    exploit " ^ i ^ "_" ^ oi_over ^ "_" ^ m.aMethodName ^ "_exists;")
            else
              output_string out ("
    exploit (" ^ i ^ "_" ^ oi_over ^ "_" ^ m.aMethodName ^ "_exists " ^
                           oi_under ^ "_" ^ m.aMethodName ^ "_exists);");
            output_string out ("
      eauto 1; intros (labd' & HP & HM).
    match_external_states_simpl.\n")
          | ASsetCR3 -> output_string out ("
  - (* " ^ oi_over ^ "_" ^ m.aMethodName ^ ": semantics SetCR3 *)
    layer_sim_simpl; compatsim_simpl (@match_AbData); intros.
    CommonTactic.inv_val_inject.
    assert (H8 := H7).
    eapply AuxLemma.inject_forward_equal' in H8; eauto 1. inv H8.
    exploit (" ^ i ^ "_" ^ oi_over ^ "_" ^ m.aMethodName ^ "_exists " ^
                           oi_under ^ "_" ^ m.aMethodName ^ "_exists);
      eauto 1; intros (labd' & HP & HM).
    match_external_states_simpl.
    rewrite Int256.add_zero; eauto.\n")
          | AStrap_info_get | AStrap_info_ret ->
            output_string out ("
  - (* " ^ oi_over ^ "_" ^ m.aMethodName ^ ": trap_info_get|set *)");
            if is_refine then
              output_string out ("
    apply " ^ i ^ "_" ^ oi_over ^ "_" ^ m.aMethodName ^ "_sim.\n")
            else
              output_string out ("
    apply (" ^ i ^ "_" ^ oi_over ^ "_" ^ m.aMethodName ^ "_sim " ^
                         oi_under ^ "_" ^ m.aMethodName ^ "_exists).\n")
          | ASdefault ->
            if fst (method_classify m.aMethodType) then begin  (* is_pure *)
              output_string out ("
  - (* " ^ oi_over ^ "_" ^ m.aMethodName ^ ": pure method *)
    layer_sim_simpl; compatsim_simpl (@match_AbData); intros.
    inv_semof H0.
    exploit " ^ (if is_refine then
                   i ^ "_" ^ oi_over ^ "_" ^ m.aMethodName ^ "_exists"
                 else
                   "(" ^ i ^ "_" ^ oi_over ^ "_" ^ m.aMethodName ^ "_exists " ^
                                   oi_under ^ "_" ^ m.aMethodName ^ "_exists)")
              ^ ";
      eauto 1; intros HP.
    match_external_states_csem.
    rewrite HP; reflexivity.\n")
            end else begin  (* [if] is_pure *)
              output_string out ("
  - (* " ^ oi_over ^ "_" ^ m.aMethodName ^ ": refinement *)
    layer_sim_simpl; compatsim_simpl (@match_AbData); intros.
    try inv_semof H0.");
              if is_refine then
                output_string out ("
    exploit " ^ i ^ "_" ^ oi_over ^ "_" ^ m.aMethodName ^ "_exists;")
              else
                output_string out ("
    exploit (" ^ i ^ "_" ^ oi_over ^ "_" ^ m.aMethodName ^ "_exists " ^
                           oi_under ^ "_" ^ m.aMethodName ^ "_exists);");
              output_string out ("
      eauto 1; intros (labd' & HP & HM).
    match_external_states_csem.\n")

            end  (* [else] is_pure *)
      );
      begin match l.aLayerAccessor with
      | AAnone -> ()
      | AALoadStoreSem1 ->
        output_string out "
  - layer_sim_simpl.
    + apply LoadStoreSem1.load_correct1.
    + apply LoadStoreSem1.store_correct1.\n"
      | AALoadStoreSem2 ->
        output_string out "
  - layer_sim_simpl.
    + apply LoadStoreSem2.load_correct2.
    + apply LoadStoreSem2.store_correct2.\n"
      | AALoadStoreSem3 ->
        output_string out "
  - layer_sim_simpl.
    + apply LoadStoreSem3.load_correct3.
    + apply LoadStoreSem3.store_correct3.\n"
      end;
      output_string out "Qed.*)\n"
#else
    ()
#endif

    in output_string out ("End EdsgerGen.\n");
       close_out out
  end  (* [if] l.aLayerDesc <> ALbottom && no l.aLayerFreshObjects are trusted *)

let do_gen_layer_code env i l =
  let iter_nonghost_methods action = List.iter (fun m ->
    if m.aMethodType.aMethodKind <> MKghost &&
       m.aMethodType.aMethodKind <> MKconstghost
      then action m) in
  let iter_implemented_methods action =
    List.iter (fun (_, o) ->
      if o.aObjectRequireImpl then
        iter_nonghost_methods (action o.aObjectName) o.aObjectMethods
    ) l.aLayerFreshObjects in
  let iter_implemented_fields action =
    List.iter (fun (_, o) ->
      if o.aObjectRequireImpl then
        List.iter (fun f ->
          if not f.aObjectFieldIsLogical then
            action o.aObjectName f
        ) o.aObjectFields
    ) l.aLayerFreshObjects in
  let unmingledFieldNameOI oi f = 
    (* l.aLayerName ^ "_" ^  *)
    oi ^ "_" ^ f.aObjectFieldName in
  let unmingledFieldName o f = 
    (* l.aLayerName ^ "_" ^  *)
    o.aObjectName ^ "_" ^ f.aObjectFieldName in

  begin  (* Clight source module file--keep away from proofs.
            That is, we want Clight code and proofs to be in separate files, so we 
            can compile the code quickly without having to check the proofs at the same time.
          *)
  let out =
#ifdef REDACTED
    open_out "/dev/null" in
#else
    new_file env ("LSrc" ^ i)
            ("\n\nRequire Import " ^ env.project_name ^ ".Layer" ^ i ^ ".\n\n"^
            "Require Import cclib.Integers.\n"^
            "Require Import cclib.Coqlib.\n"^
            "Require Import cclib.Maps.\n\n"^
            "Require Import backend.Options.\n"^
            "Require Import backend.AST.\n"^
            "Require Import backend.phase.Clike.Language.\n"^
            "Require Import backend.phase.MiniC.Language.\n"^
            "Require Import backend.Cop.\n"^
            "Require Import backend.Ctypes.\n"^
            "Require Import backend.Compiled.\n"^
            "Require Import backend.Compiled.\n"^
            "Require Import backend.Globalenvs.\n"^
            "Require Import backend.Glue.\n\n")
            file_class_ObjAux in
#endif
  
  output_string out "Definition ge : genv := new_genv (";
  iter_implemented_fields (fun oi f ->
  output_string out ("\n\t(var_" ^ oi ^ "_" ^ unmingledFieldNameOI oi f ^ "_ident," ^ 
  " unpair_ty " ^ f.aObjectFieldType.aTypePairIdent ^ ")::"));
  output_string out ("nil)" ^ "\n\tnil" ^ "\n\t(");

  iter_implemented_methods (fun oi m ->
  output_string out ("\n\t(Int.repr " ^string_of_int (function_selector_intval_of_method m) ^ ", " ^ 
  oi ^ "_" ^ m.aMethodName ^ "_cfun" ^ "):: (* " ^ function_selector_of_method m ^ " *)\n"));
  output_string out ("nil)\n");
  output_string out ("\tNone.\n\n\n");

(*f.aObjectFieldType.aTypePairIdent *)
  (* output_string out "      nil;\n    lm_gvar :=\n";
  iter_implemented_fields (fun oi f ->
    output_string out
      ("      lgv var_" ^ oi ^ "_" ^ f.aObjectFieldName ^ "_ident " ^
                  oi ^ "_" ^ f.aObjectFieldName ^ "_globvar ::\n"));
  output_string out "      nil;
    lm_asmfun :=
      nil
  |}." *)

  output_string out "End EdsgerGen.\n\n";
  output_string out ("(*change into extract directory*)\n" ^
		       "Cd \"" ^ Sys.getcwd() ^"/" ^env.project_name^"/extraction\".\n\n" ^ (*go to the extract dir*)
    "(* Avoid name clashes *)\n" ^
    "Extraction Blacklist List String Int.\n\n" ^
    "Separate Extraction
    nat positive global_abstract_data_type  (* This line forces Coq to generate some files even if they are not used, to make the makefile work correctly. *)
    Glue.full_compile_genv
    ge.\n");

  close_out out
  end;  (* Clight source module file *)

  List.iter (fun (_, o) -> if o.aObjectRequireImpl && List.exists (fun m ->
                                m.aMethodType.aMethodKind <> MKghost &&
                                m.aMethodType.aMethodKind <> MKconstghost
                              ) o.aObjectMethods then begin
    let proofs, prf_tbl =
        new_incremental_file env ("Obj" ^ o.aObjectName ^ "CodeProofs")
        (
#ifndef REDACTED
          "Require Import liblayers.compcertx.MakeProgram.\n" ^
         "Require Import liblayers.compcertx.MemWithData.\n\n" ^
#else
         "Require Import " ^ env.project_name ^ ".Layer" ^ l.aLayerName ^ ".\n")
        (fun out -> output_string out (
"Existing Instance GlobalLayerSpec.
Existing Instances " ^ l.aLayerName ^ "_overlay_spec.\n\n" ^
      "Context {memModelOps : MemoryModelOps mem}.\n"))
        (Str.regexp ("\\bLemma +" ^ o.aObjectName ^ "_\\(.+\\)_spec_requires_kernel_mode\\b"))   (* TODO: fix this. *)
        file_class_ObjAux in
#endif
    let code =
#ifdef REDACTED
      open_out "/dev/null" in
#else
      new_file env ("Obj" ^ o.aObjectName ^ "Code")
        ("Require Import liblayers.compcertx.MakeProgram.\n" ^
         "Require Import liblayers.compcertx.MemWithData.\n" ^
         "Require Import layerlib.LinkSourceTemplate.\n\n" ^
         "Require Import " ^ env.project_name ^ ".Layer" ^ l.aLayerName ^ ".\n" ^
         "Require Import " ^ env.project_name ^ ".Refine" ^ l.aLayerName ^ ".\n" ^
         "Require Import " ^ env.project_name ^ ".Obj" ^ o.aObjectName ^ "CodeProofs.\n")
        file_class_Code in
#endif
    output_string code "
Context {mem}`{Hmem: Mem.MemoryModel mem}.
Context`{Hmwd: UseMemWithData mem}.
Context`{make_program_ops: !MakeProgramOps Clight.function Ctypes.type Clight.fundef Ctypes.type}.
Context`{Hmake_program: !MakeProgram Clight.function Ctypes.type Clight.fundef Ctypes.type}.
Instance GlobalLayerSpec : LayerSpecClass := {
  make_program_ops := make_program_ops;
  Hmake_program := Hmake_program;
  GetHighData := global_abstract_data_type
}.
Context`{global_abdata : !GlobalAbData init_global_abstract_data global_low_level_invariant}.";
    begin match l.aLayerDesc with
    | ALontop l' -> output_string code ("
Context`{CTXT_prf : !Layer_" ^ l.aLayerName ^ "_Context_prf}.
Context`{" ^ l'.aLayerName ^ "_pres_inv : !" ^ l'.aLayerName ^ "_preserves_invariants}.")
    | _ -> ()
    end;
    output_string code ("
Existing Instances " ^ l.aLayerName ^ "_overlay_spec " ^ l.aLayerName ^ "_underlay_spec
                   " ^ l.aLayerName ^ "_hypermem.

Lemma relate_AbData_translates_kernel_mode j d1 d2 :
    relate_AbData j d1 d2 -> kernel_mode d1 -> kernel_mode d2.
Proof.
  simpl; intros rel d1_kern.
  (* rewrite <- (ikern_re _ _ _ rel), <- (ihost_re _ _ _ rel). *)
  exact d1_kern.
Qed.\n");

    (* Headers for [code] and [proofs] are ready, start printing the meat. *)
    (* [primitive_constr_prf] for all the exposed primitives from underlay *)
    begin match l.aLayerDesc with
    | ALbottom -> ()
    | ALontop base_layer | ALrefine_bottom (base_layer, _) ->
      List.iter (fun (s, o) ->
        List.iter (fun m ->
          if m.aMethodSemantics = ASdefault then begin
          let method_full_name =
                base_layer.aLayerName ^ "_" ^ s ^ "_" ^ m.aMethodName in
          let method_is_ghost = m.aMethodType.aMethodKind = MKghost ||
                                m.aMethodType.aMethodKind = MKconstghost in
          output_string code ("
Instance " ^ method_full_name ^ "_prim_prf :
    primitive_prf " ^ method_full_name ^ "_prim.
Proof. esplit; ");

          if method_is_ghost then begin
            output_string code "[| | discriminate | |].
  - (* PRIMsem_opt_simulates_sem *) admit.
  - (* PRIMret_cond *) admit.
  - (* PRIMis_ghost *)
    intros _ se j d m mm.
    constructor; apply mm."

          end else begin  (* [if] method_is_ghost *)
            output_string code ("[|
    | intros _;
      set (sem := gencsem " ^ o.aObjectName ^ "_" ^ m.aMethodName ^ "_spec);
      apply mk_prim_exec_prf with sem
    | discriminate |].
  - (* PRIMsem_opt_simulates_sem *) admit.
  - (* PRIMret_cond *) admit.
  - (* PRIMargs_cast *)
    simpl.
    repeat match goal with
      | |- HList _ _ => constructor
      | |- HyperArgRet (tp_type_pair _) => simpl
      | |- HyperArgRet _ => typeclasses eauto
      end.
  - (* PRIMreturns_cast *) simpl; typeclasses eauto || constructor.
  - (* PRIMget_layer_primitive *)
    reflexivity.
  - (* PRIMsextcall_step *)
    admit.
  - (* PRIMprimsem_sig *)
    reflexivity.
  - (* PRIMmake_external *)
    reflexivity.")
          end;  (* [else] method_is_ghost *);
          let method_is_pure = m.aMethodType.aMethodKind = MKconst ||
                               m.aMethodType.aMethodKind = MKconstghost in
          if method_is_pure then
            output_string code "
  - (* PRIMis_pure *)
    simpl. intros.
    repeat match goal with
      | |- context [?X _ d] => unfold X
      | |- ?G => CommonTactic.subdestruct_if G
      | |- _ => reflexivity
      end.\n"
          else
            output_string code "
  - (* PRIMis_pure *) discriminate.\n";

          output_string code "Qed.\n"
          end  (* [if] m.aMethodSemantics = ASdefault *)
        ) o.aObjectMethods
      ) (base_layer.aLayerFreshObjects @ base_layer.aLayerPassthroughObjects)
    end;

    (* [HyperLType], which is used to construct [variable_prf], for all the
       object fields *)
    List.iter (fun f ->
      output_string code ("
Instance " ^ o.aObjectName ^ "_" ^ unmingledFieldName o f ^ "_var_prf :
    HyperLType " ^ o.aObjectName ^ "_" ^ unmingledFieldName o f ^ "_var.
Proof. esplit; ");
      if f.aObjectFieldIsLogical then
        output_string code "[ typeclasses eauto | discriminate |].
  - (* ltype_writable *)
    intros j d m mm; apply mm.
  - (* ltype_ltype_ghost *)
    intros _ f j d m mm.
    constructor; apply mm.\n"
      else  (* [if] f.aObjectFieldIsLogical *)
        output_string code ("[ typeclasses eauto | intros _; esplit | discriminate ].
  - (* ltype_writable *)
    intros j d m mm; apply mm.
  - (* ltype_get_match *)
    intros j d m mm dc; split.
    admit. (* ht_ft_cond (ltype_get " ^ o.aObjectName ^ "_" ^ unmingledFieldName o f ^ "_var d) *)
    apply mm.
  - (* ltype_set_match *)
    intros f j d m fc mm dc m' disjoint_eq match_indirect.
    constructor.
    admit. (* [relate_AbData j (ltype_set ... f d) (snd m')]: premise does not
              bound [snd m'] *)
    constructor.
    split.
    + exact match_indirect.
    + admit. (* [Mem.range_perm (fst m') ...]: premise does not bound the
                permissions of [fst m'] *)\n");

      output_string code "Qed.\n"
    ) o.aObjectFields;

    output_string code ("
(* Do not assume this context until now to avoid above proofs using the wrong one *)
Context`{" ^ l.aLayerName ^ "_pres_inv : !" ^ l.aLayerName ^ "_preserves_invariants}.\n");

    (* Final code proof theorems used by linking theorems *)
    iter_nonghost_methods (fun m ->
      let method_full_name = o.aObjectName ^ "_" ^ m.aMethodName in
      let nargs, args = match m.aMethodType.aMethodArgumentTypes with
        | [t] when t.aTypeDesc = ATbuiltin Tunit -> 0, ""
        | ts -> List.length ts,
                String.concat ""
                  (List.mapi (fun n _ -> " a" ^ string_of_int n) ts) in
      let is_pure, has_return = method_classify m.aMethodType in
      let suffix, retarg, ret =
        if is_pure then
          "_pure", " r", "r"
        else if has_return then
          "", " r d'", "(r, d')"
        else
          "_void", " d'", "d'" in

      if not (Hashtbl.mem prf_tbl m.aMethodName) then begin
          (* verification conditions, [method_full_name ^ "_vc"], aren't
             checked if exist themselves, but latched on requires kernel mode
             proofs currently *)
        output_string proofs ("
Lemma " ^ method_full_name ^ "_vc" ^ args ^ " me d :");
        for i = 0 to nargs - 1 do
          output_string  proofs ("
    ht_ft_cond a" ^ string_of_int i ^
            " -> ht_valid_ft_cond a" ^ string_of_int i ^ " ->")
        done;
        output_string proofs ("
    high_level_invariant d ->
    synth_func_cond " ^ method_full_name ^ " " ^ method_full_name ^ "_wf
                   " ^ args ^ " me d.
Proof.
Admitted.

Lemma " ^ method_full_name ^ "_oblg" ^ args ^ " me d :");
        for i = 0 to nargs - 1 do
          output_string  proofs ("
    ht_ft_cond a" ^ string_of_int i ^
            " -> ht_valid_ft_cond a" ^ string_of_int i ^ " ->")
        done;
        output_string proofs ("
    high_level_invariant d ->
    synth_func_obligation " ^ method_full_name ^ " " ^ method_full_name ^ "_wf
                         " ^ args ^ " me d.
Proof.
Admitted.\n")
      end;  (* [if] requires kernel mode proof not exists  *)

      output_string code ("
Lemma " ^ method_full_name ^ "_prf : function_constr_prf " ^ method_full_name ^ ".
Proof. solve_function_constr_prf @" ^ method_full_name ^ ". Qed.

Theorem " ^ method_full_name ^ "_code_correct:
  simRR GetHighDataX GetLowDataX (path_inj Hcompatrel)
    (ident_" ^ method_full_name ^ " ↦ CompatGenSem.gensem " ^ method_full_name ^ "_spec)
    (clight_DeepSpec_layer GetLowLayer ident_" ^ method_full_name ^ " " ^ method_full_name ^ "_cfun).
Proof.
  assert (cc := cl_sim_sem_code_correct).
  apply cc; clear cc; try reflexivity.
  - rewrite " ^ method_full_name ^ "_spec_eq.
    change " ^ method_full_name ^ "_cfun
      with (synth_func_func " ^ method_full_name ^ ").
    apply synth_correct_" ^ string_of_int nargs ^ suffix ^ ".");
      if is_pure then
        output_string code "
    + exact IndexedMaps.identity_automorphism.";
      if has_return then
        output_string code "
    + reflexivity.";
      output_string code ("
    + exact " ^ method_full_name ^ "_prf.
    + exact " ^ method_full_name ^ "_vc.
    + exact " ^ method_full_name ^ "_oblg.
Qed.\n")
    ) o.aObjectMethods;

    output_string proofs "\nEnd EdsgerGen.\n";
    output_string code "\nEnd EdsgerGen.\n";
    close_out proofs;
    close_out code
    end  (* [if] object has method that's implemented *)
  ) l.aLayerFreshObjects

let gen_layer_code env i l =
(*  if List.exists (fun (_, o) ->
       o.aObjectRequireImpl && List.exists (fun m ->
         m.aMethodType.aMethodKind <> MKghost &&
         m.aMethodType.aMethodKind <> MKconstghost
       ) o.aObjectMethods
     ) l.aLayerFreshObjects then *)
    do_gen_layer_code env i l

let unmingledFieldName l o f = 
  (* l.aLayerName ^ "_" ^   *)
  o.aObjectName ^ "_" ^ f.aObjectFieldName

let gen_global_abstract_data_type env final_layer fileDeclarations = function
  | None ->  (* Collect all fields in [final_layer] for the type *)
    let iter_fields action =
       List.iter (fun (_, o) ->
         List.iter (fun f -> action o f
       ) o.aObjectFields
      ) final_layer.aLayerAllObjects
    in
    let has_fields =
      List.exists (fun (_,o) ->
          List.exists (fun f -> true
            ) o.aObjectFields
        ) final_layer.aLayerAllObjects
    in
    let unmingledFieldName _o f = 
      unmingledFieldName final_layer _o f
    in
     
    let out = env.coq_DataTypeOps in
    let record_field_leftover = ref "\n  " in

    output_string out "Require Import backend.MachineModel.\n";

    List.iter (function
    | i, ADlayer l ->
      List.iter (fun (_, o) ->
        match o.aObjectAddress with
        | Some ad -> 
          output_string out ("Definition " ^ o.aObjectName ^ 
          "_address := " ^ "(Int256.repr " ^  (Backend.BinNumsExt.numstring2decimalstring ad) ^ ").\n")
        | None -> 
          ()
      ) l.aLayerFreshObjects
    | _, _ -> ()
    ) fileDeclarations;

    output_string out "Definition ext_call_me {adata: Type} (me : machine_env adata) (ext_contract : int256) := {|
  me_address := ext_contract;
  me_origin := me_origin me;
  me_caller := me_address me;
  me_callvalue := me_callvalue me; (* FIXME: the callvalue modeling is wrong *)
  me_coinbase := me_coinbase me;
  me_timestamp := me_timestamp me;
  me_number := me_number me;
  me_chainid := me_chainid me;
  me_selfbalance := me_selfbalance me;
  me_balance := me_balance me;
  me_blockhash := me_blockhash me;
  me_transfer := me_transfer me;
  me_callmethod := me_callmethod me;
  me_log := me_log me;
|}.\n";

    output_string out "Record global_abstract_data_type : Type := {";
    iter_fields (fun _o f ->
        (* XXX: option for name mangling.
           Currently, if two object fields have the same name (anywhere in the entire system)
           we will get a name clash when they are put into the global abstract data type.

           So we would like to prefix field names with the object names, etc. However, this has to
           be optional, because when we are reimplementing mcertikos, we want to use exactly the same
           names for everything. *)
        output_string out (!record_field_leftover ^ unmingledFieldName _o f ^ " : ");
        output_type_expr out "    " f.aObjectFieldType;
        record_field_leftover := ";\n  "
    );
    output_string out "\n}.\n";

    iter_fields (fun o f ->
        output_string out ("Definition update_"  ^ unmingledFieldName o f ^ " glabs_b (glabs_a : global_abstract_data_type)\n");
        output_string out ("  := Build_global_abstract_data_type ");	
	iter_fields (fun o' f' ->
                      if (o' = o && f' = f)
		      then output_string out "glabs_b "
		      else output_string out ("(" ^ unmingledFieldName o' f' ^ " glabs_a) ")
                   );
        output_string out ".\n"
    );

    if has_fields then begin
    output_string out "\nDefinition init_global_abstract_data : global_abstract_data_type := {|";
    record_field_leftover := "\n  ";
    iter_fields (fun _o f ->
        (* XXX: option for name mangling *)
        output_string out (!record_field_leftover ^ unmingledFieldName _o f ^ " := ");
        output_compile_time_constant out "      " f.aObjectFieldInitial;
        record_field_leftover := ";\n  "
    );
    output_string out "\n|}.\n"
      end else begin
            output_string out "\nDefinition init_global_abstract_data : global_abstract_data_type := Build_global_abstract_data_type.";
      end;

    (* abstract data type fields that include [val] components need to be
       ensured [val_inject] and [Val.has_type]. *)
    let record_field_leftover = ref (false, "Record global_low_level_invariant " ^
          "(n : block)(abd : global_abstract_data_type) := {\n  ") in
    iter_fields (fun _o f ->
        (* XXX: option for name mangling *)
        let field_name = unmingledFieldName _o f  in
        let inj, typed = generate_low_level_invariant "    "
                "val_inject (Mem.flat_inj n)"
                ("abd.(" ^ field_name ^ ")")
                f.aObjectFieldType in
        begin match inj with
        | None -> ()
        | Some s ->
          output_string out (snd !record_field_leftover ^
            field_name ^ "_INJECT:\n    " ^ s);
          record_field_leftover := (true, ";\n  ")
        end;
      begin match typed with
      | None -> ()
      | Some s ->
        output_string out (snd !record_field_leftover ^
          field_name ^ "_TYPE:\n    " ^ s);
        record_field_leftover := (true, ";\n  ")
      end
    );
    if fst !record_field_leftover
    then output_string out "\n}.\n"
    else
      output_string out (
	"\nDefinition block := positive.\n" ^   (* todo, figure out where the wrong definition of positive comes from. *)
	"Definition global_low_level_invariant " ^
        "(n : block)(abd : global_abstract_data_type) := True.\n");

    output_string out "End EdsgerGen.\n";  (* Hints are local to sections, so we have to do this block outside the section. *)
    iter_fields (fun o f ->
        output_string out "\n";
	iter_fields (fun o' f' ->
          output_string out ("Lemma "  ^ unmingledFieldName o f ^ "_of_update_"^ unmingledFieldName o' f' ^" : forall _x (glabs_a : global_abstract_data_type),\n"
                             ^ "  " ^ unmingledFieldName o f ^ " (update_"^ unmingledFieldName o' f' ^" _x glabs_a) = "  );
          if (o' = o && f' = f)
	   then output_string out "_x.\n"
	   else output_string out (unmingledFieldName o f ^ " glabs_a.\n");
	  output_string out "Proof. intros. destruct glabs_a. reflexivity. Qed.\n";
          output_string out ("Hint Rewrite "^ unmingledFieldName o f ^"_of_update_"^ unmingledFieldName o' f' ^ " : updates.\n\n")
        );
    );

    if has_fields then begin
        output_string out ("Opaque");
        iter_fields (fun o f ->
	    output_string out (" "^ unmingledFieldName o f ^" update_"^ unmingledFieldName o f ));
        output_string out (".\n")
      end;
    
  | Some ({ aEXTypeString = s; aEXTypeDefault = Some (s', _) } as extype) ->
    output_string env.coq_DataTypeOps
      ("Definition global_abstract_data_type : Type := " ^ s ^ ".\n" ^
       "Definition init_global_abstract_data : global_abstract_data_type := " ^
       s' ^ ".\n");
    begin match extype.aEXTypeLowLevelInv with
    | Some lli ->
      output_string env.coq_DataTypeOps
        ("Definition global_low_level_invariant := " ^ lli ^ ".\n" ^
         "Global Arguments global_low_level_invariant / _ _.\n")
    | None ->
      output_string env.coq_DataTypeOps ("Definition global_low_level_invariant " ^
        "(n : block)(abd : global_abstract_data_type) := True.\n")
    end;
    output_string env.coq_DataTypeOps "End EdsgerGen.\n"; 
  | Some _ -> coqgen_fatal_error __LOC__ "gen_global_abstract_data_type"
                "Global abstract data type without empty value"

let gen_coqProj env fileDeclarations = 
  let stream = open_out (env.project_name ^ "/_CoqProject") in
  output_string stream (
    "-R ../result/DeepSEA DeepSpec\n" ^
    "-R . " ^ env.project_name ^ "\n" ^
    "./EdsgerIdents.v\n" ^
    "./DataTypes.v\n" ^
    "./DataTypeOps.v\n" ^
    "./DataTypeProofs.v\n"
  );
  List.iter (function 
  | i, ADlayer l -> output_string stream ("./Layer" ^ i ^ ".v\n")
  | _, _ -> ()
  ) fileDeclarations;
  List.iter (function
  | i, ADlayer l -> List.iter (fun (_, o) ->
      output_string stream ("./Obj" ^ o.aObjectName ^ "CodeProofs.v\n"))
      l.aLayerFreshObjects
  | _, _ -> ()
  ) fileDeclarations;
#ifndef REDACTED
  List.iter (function
  | i, ADlayer l -> output_string stream ("./LSrc" ^ i ^ ".v\n")
  | _, _ -> ()
  ) fileDeclarations;
#endif
  close_out stream

let gen_extract_make env fileDeclarations =
  let stream = open_out (env.project_name ^ "/extraction/Makefile") in
  output_string stream ("lastfiles = HyperType.mli HyperTypeInst.mli DataTypeOps.mli EdsgerIdents.mli");
  List.iter (function 
  | i, ADlayer l -> output_string stream (" Layer" ^ i ^ ".mli LSrc" ^i^".mli ")
  | _, _ -> ()
  ) fileDeclarations;
  close_out stream;
  let stream = open_out (env.project_name ^ "/extraction/Tester.ml") in
  List.iter (function 
  | i, ADlayer l -> output_string stream ("open LSrc" ^ i ^ "\n")
  | _, _ -> ()
  ) fileDeclarations;  
  output_string stream "
(* To build this, copy backend/extraction/Asm.ml and
    backend/extraction/*Ext.* into this directory, then run
      ocamlbuild Tester.byte *)

let usage () = 
  Printf.eprintf \"usage: extract (bytecode | bytecode-runtime | assembly)
\" ;
  exit 1

type mode = BYTECODE | BYTECODE_RUNTIME | ASSEMBLY 
                                                                                 
let mode_flag =
  if Array.length Sys.argv <> 2 then
    usage()
  else match Array.get Sys.argv 1 with
       | \"bytecode\" -> BYTECODE
       | \"bytecode-runtime\" -> BYTECODE_RUNTIME
       | \"assembly\" -> ASSEMBLY
       | _          -> usage ()
                
let _ =
  match Glue.full_compile_genv ge with
  | OptErrMonad.Error msg -> Printf.eprintf (\"error in compilation: %s\n\") (DatatypesExt.caml_string msg) ; exit 1
  | OptErrMonad.Success (Datatypes.Coq_pair (program, entrypoint)) ->
          let (asm, asm_runtime) =
            Asm.transform
              (List.rev (DatatypesExt.caml_list program))
              entrypoint
          in
          let programsize = Asm.size_of_program asm in
          match mode_flag with
	   | BYTECODE -> print_endline (Asm.assemble asm programsize)
	   | BYTECODE_RUNTIME -> print_endline (Asm.assemble asm_runtime programsize)
	   | ASSEMBLY -> print_endline (Asm.mnemonics asm)
";
  close_out stream

let gen_prf env fileDeclarations = 
  let stream = open_out (env.project_name ^ "/prf.v") in
  output_string stream (
    "Require Import " ^ env.project_name ^ ".DataTypes.\n" ^
    "Require Import " ^ env.project_name ^ ".DataTypeOps.\n" ^
    "Require Import lib.Monad.StateMonadOption.\n" ^
    "Require Import cclib.Maps.\n" ^
    "Require Import cclib.Integers.\n" ^
    "Require Import ZArith.\n" ^
    "Require Import core.HyperTypeInst.\n" ^
    "Require Import backend.MachineModel.\n"
  );
  List.iter (function 
    | i, ADlayer l -> output_string stream ("Require Import " ^ env.project_name ^ ".Layer" ^ i ^ ".\n")
    | _, _ -> ()
    ) fileDeclarations;
  output_string stream (
      "\n" ^ 
"Definition state := global_abstract_data_type.

Definition init_state := init_global_abstract_data.

Definition wei := Z.

Definition addr := int256.

Definition blocknumber := int256.

Existing Instance GlobalLayerSpec.

Section step.

  Context (contract_address : addr).

  Section mstep.
  (* These are the parameters which are constant within a given block. *)
  Context (coinbase : int256)
          (timestamp : int256)
          (number : int256)
          (balance : int256 -> int256)
          (blockhash : int256 -> int256)
          (prev_contract_state : state).

  Definition make_machine_env (caller: addr)
                              : machine_env state
    := {| me_address := contract_address;
          me_origin := caller;
          me_caller := caller; (* need update after every control-flow transfer *)
          me_callvalue := Int256.repr (0);
          me_coinbase := coinbase; 
          me_timestamp := timestamp;
          me_number := number;
          me_balance := balance;
          me_blockhash := blockhash;
          (* not implemented *)
          me_transfer _ _ _ _ _ := False;
          me_callmethod _ _ _ _ _ _ _ _ _ _ := False;
          me_log _ _ _ := prev_contract_state;
        |}.

  Import MonadNotation.

  Definition lif {A:Type}
                 (caller : addr)
                 (cmd : machine_env state -> osT global_abstract_data_type A)
    : osT state A :=
    st  <- get;;
    let me := make_machine_env caller in
    match runStateT (cmd me) st with
    | None => mzero
    | Some (v, st') => put st' ;; ret v
    end.

  (* osT state int256 = 
    state transformer with option monad, state is state, and value is int256 *)
  Print osT. (* = fun D : Type => stateT D option *)
  Print stateT. (* (S : Type) (m : Type -> Type) (t : Type) : Type := mkStateT
  { runStateT : S -> m (t * S)%type } *)

  Print runStateT. (* takes monad transformer, state, returns m (t * S) *)\n\n" ^ 

"  (* How the state of the system changes in a single method call made by player p. *)
  Inductive mstep u (st st' : state) : Prop :=\n"
  );

  List.iter (function
  | i, ADlayer l ->
    List.iter (fun (_, o) ->
      List.iter (fun m ->
        let method_full_name = o.aObjectName ^ "_" ^ m.aMethodName in
        let args = if (List.length m.aMethodArguments) = 0 then "" else 
          (if (List.nth m.aMethodArguments 0) = "()" then "" else (String.concat " " m.aMethodArguments)) in 
        output_string stream ("  | " ^ method_full_name ^ "_step : " ^ "forall r " ^ args ^ 
          ", runStateT (" ^ method_full_name ^ "_opt " ^ args ^ 
          " (make_machine_env u)) st = Some (r, st')" ^ 
        " -> mstep u st st' \n")
      ) o.aObjectMethods
    ) l.aLayerFreshObjects
  | _, _ -> ()
  ) fileDeclarations;

  output_string stream ".\n";
  output_string stream
"
  (* We can compute a new block by letting the players call the contract 
     in some arbitrary order. *)
     Inductive multi_mstep : state -> state -> Prop := 
     | multi_mstep_reflexive : forall (st : state), multi_mstep st st
     | multi_mstep_transitive : forall (st st' st'' : state) u,
         multi_mstep st st' -> mstep u st' st'' -> multi_mstep st st''.


     (* A block is sufficiently synchronous if every player got a chance to submit a 
        transaction to to. *)
     (* TODO, I think this definition is fine for now, but it seems little too clever,
        should probably re-state this using some straightforward tracking of the states
        we pass through. *)
     Definition multi_mstep_synchronous st1 st2 :=
       forall u, exists st st',
                   multi_mstep st1 st /\\ mstep u st st' /\\ multi_mstep st' st2.

     (* Here are a bunch of induction principles inspired by linear temporal logic. *)

     (* Prove that some property P holds \"globally\", i.e. for each state along a 
        path.
        You can also specify a property Pprev which is known to hold for the
        prev_contract_state. If not needed, it can just be True.
    *)
     Lemma multi_mstep_Global_ind : forall (Pprev P : state -> Prop),
         (forall u st st', Pprev prev_contract_state -> P st -> mstep u st st' -> P st') ->
          Pprev prev_contract_state -> forall st st', P st -> multi_mstep st st' -> P st'.
     Proof.
       induction 4; eauto.
     Qed.

     (*
     (* Prove that P holds \"until\" Q  along a path. 
        \"Until\" is a liveness assertion, so we need the synchronicity assumption. *)
     Lemma multi_mstep_Until_ind : forall (Pprev P Q : state -> Prop),
         (forall p st st', Pprev prev_contract_state -> P st -> In p players
                           -> mstep p st st' -> (P st' \/ Q st')) ->
                           Pprev prev_contract_state ->
                           forall st,
                             P st -> exists st',  multi_mstep st st' -> (P st' \/ Q st').
     Proof.
       induction 4; eauto *)

     End mstep.


     Definition Int256_incr x := Int256.add x Int256.one.

     Inductive bstep (n : blocknumber) : state -> state -> Prop :=
     | bstep_step : forall coinbase timestamp balance blockhash st st',
         multi_mstep coinbase timestamp n balance blockhash st st st' ->
         bstep n st st'.

     Inductive multi_bstep : blocknumber -> state -> blocknumber -> state -> Prop := 
     | multi_bstep_reflexive : forall n (st : state), multi_bstep n st n st
     | multi_bstep_transitive : forall n n'  (st st' st'' : state),
       multi_bstep n st n' st' -> bstep (Int256_incr n') st' st'' -> multi_bstep n st (Int256_incr n') st''.

     (* multi_bstep is the step relation without any synchronicity assumption.
        This is sufficient to prove some safety properties, but for most interesting 
        theorems we instead need to use this synchronous version: *)

     Inductive bstep_synch (n : blocknumber) : state -> state -> Prop :=
     | bstep_synch_step : forall coinbase timestamp balance blockhash st st',
         multi_mstep_synchronous coinbase timestamp n balance blockhash st st st' ->
         bstep_synch n st st'.

     Inductive multi_bstep_synch : blocknumber -> state -> blocknumber -> state -> Prop := 
     | multi_bstep_synch_reflexive : forall n (st : state), multi_bstep_synch n st n st
     | multi_bstep_synch_transitive : forall n n'  (st st' st'' : state),
       multi_bstep_synch n st n' st' -> bstep_synch (Int256_incr n') st' st'' -> multi_bstep_synch n st (Int256_incr n') st''.

     Lemma multi_bstep_Global_ind : forall (P : state -> Prop),
         (forall coinbase timestamp number balance blockhash prev_block u st st',
             P prev_block
             -> P st
             -> mstep coinbase timestamp number balance blockhash prev_block u st st'
             -> P st')
         -> forall n st n' st',
           P st -> multi_bstep n st n' st' -> P st'.
     Proof.
       induction 3.
       - auto.
       - inversion H2; subst.
         eapply multi_mstep_Global_ind with (st:=st') (prev_contract_state := st').
         + intros.
           refine (H _ _ _ _ _ _ _ _ _ _ _ H6); auto.
         + apply IHmulti_bstep; assumption.
         + apply IHmulti_bstep; assumption.
         + exact H3.
     Qed.
   End step.

   Section DeepSEAGenericProof.

     Lemma Int256Tree_reduce : forall (i: int256) (v: Z) (t: Int256Tree.t Z), Int256Tree.get_default 0%Z i (Int256Tree.set i v t) = v.
     Proof.
       intros.
       unfold Int256Tree.get_default.
       rewrite Int256Tree.gss .
       reflexivity.
     Qed.

     Lemma Int256Tree_mreduce : forall (i j : int256) (v v': Z) (t: Int256Tree.t Z), 
       i <> j ->
       Int256Tree.get_default 0%Z i (Int256Tree.set j v' (Int256Tree.set i v t)) = v.
     Proof.
       intros.
       unfold Int256Tree.get_default.
       rewrite Int256Tree.gso.
       rewrite Int256Tree.gss.
       reflexivity.
       exact H.
     Qed.

     Lemma Int256Tree_mireduce : forall (i j k : int256) (v v': Z) (t: Int256Tree.t Z), 
       i <> j ->
       i <> k ->
       j <> k ->
       Int256Tree.get_default 0%Z i (Int256Tree.set j v' (Int256Tree.set k v t)) = 
       Int256Tree.get_default 0%Z i t.
     Proof.
       intros.
       unfold Int256Tree.get_default.
       rewrite Int256Tree.gso.
       rewrite Int256Tree.gso.
       reflexivity.
       exact H0.
       exact H.
     Qed.

     Lemma add_sub_inv : forall (i j : Z32), (i + j - i)%Z = j.
     Proof.
       intros.
       omega.
     Qed.
   End DeepSEAGenericProof.

   Section Proof.   
     Context (* (strategies : strategy_tuple) *)
             (initial_balances : addr -> Z)
             (contract_address : int256).

     Context (init_bt init_rt : int256)
             (init_coinbase : int256)
             (init_timestamp : int256)
             (init_number : int256)
             (init_blockhash : int256 -> int256)
             (pre_init_state init_state : state).

     (* These are the parameters which are constant within a given block. *)
     Context (coinbase : int256)
             (timestamp : int256)
             (number : int256)
             (balance : int256 -> int256)
             (blockhash : int256 -> int256)
             (prev_contract_state : state).

     Require Import lib.Monad.RunStateTInv.
     Require Import lib.ArithInv.

     Definition make_machine_env_wrapped prev_st user :=
      make_machine_env contract_address coinbase timestamp number balance blockhash prev_st user.

     Lemma make_machine_env_caller_eq : forall st caller, me_caller (make_machine_env_wrapped st caller) = caller.
      Proof. auto. Qed.

     Lemma make_machine_env_address_eq : forall st caller, me_address (make_machine_env_wrapped st caller) = contract_address.
      Proof. auto. Qed.
     \n";

  List.iter (function
  | i, ADlayer l ->
    List.iter (fun (_, o) ->
      List.iter (fun m ->
        let method_full_name = o.aObjectName ^ "_" ^ m.aMethodName in
        output_string stream ("Transparent " ^ method_full_name ^ "_opt.\n")
      ) o.aObjectMethods
    ) l.aLayerFreshObjects
  | _, _ -> ()
  ) fileDeclarations;

  (* List.iter (function
  | i, ADlayer l ->
    List.iter (fun (_, o) ->
      match o.aObjectAddress with
      | Some ad -> 
      output_string stream ("Definition " ^ o.aObjectName ^ 
        "_address := " ^ "(Int256.repr " ^  (Backend.BinNumsExt.numstring2decimalstring ad) ^ ").\n")
      | None -> 
        ()
    ) l.aLayerFreshObjects
  | _, _ -> ()
  ) fileDeclarations; *)

  output_string stream ("\nLtac rds :=\n");

  List.iter (function
    | i, ADlayer l ->
      List.iter (fun (_, o) ->
        List.iter (fun m ->
          let method_full_name = o.aObjectName ^ "_" ^ m.aMethodName in
          output_string stream ("unfold " ^ method_full_name ^ "_opt in *;\n")
        ) o.aObjectMethods
      ) l.aLayerFreshObjects
    | _, _ -> ()
  ) fileDeclarations;

  output_string stream
"inv_runStateT;
subst;
inv_arith;
simpl;
try rewrite make_machine_env_caller_eq in *;
try rewrite make_machine_env_address_eq in *;
try rewrite Int256Tree_reduce in *;
try rewrite Int256Tree_mreduce in *;
try rewrite Int256Tree_mireduce in *;
auto.\n";

  output_string stream ("\nTheorem sample : forall n, n = n.\n");

  output_string stream ("\nEnd Proof.\n")

let coqgen filename ast =
  let final_layer = ref None in
  let env = new_coqgen_env filename ast
  in gen_linksource_prelude env ast.aFileDeclarations;
     List.iter (function
     | i, ADtype t -> gen_type env i t
     | i, ADevent _ -> ()
     (*
     | i, ADobject o -> gen_object env i o
     *)
     | i, ADlayer l ->
       let has_fresh, has_passthrough = gen_layer env i l in
       gen_layer_refinement env i has_fresh has_passthrough l;
       gen_layer_code env i l;
       gen_layer_linksource env i l;
       final_layer := Some l
     (*
     | _, ADexternal_with (s, except) -> gen_external_with env s except
     *)
     ) ast.aFileDeclarations;
     begin match !final_layer with
     | None -> ()
     | Some l -> gen_global_abstract_data_type env l ast.aFileDeclarations ast.aFileGlobalAbstractDataType
     end;
     gen_linksource env ast.aFileDeclarations;
     gen_coqProj env ast.aFileDeclarations; 
#ifndef REDACTED
     gen_extract_make env ast.aFileDeclarations;
#endif
     delete_coqgen_env env

/* file automatically generated by DeepSEA */

module dsmodel {

  type address = integer;

  input me_caller : address;
  input hackaux : address;
  input victim : address;

  const FixedSupplyToken_address : address = 65587;
  const FixedSupplyToken1_address : address = 65586;
  const LiquidityToken_address : address = 65585;
  const AutomatedMarketMaker_address : address = 65584;
  var AutomatedMarketMaker__token0 : address;
  var AutomatedMarketMaker__token1 : address;
  var AutomatedMarketMaker__owner : address;
  var AutomatedMarketMaker__reserve0 : integer;
  var AutomatedMarketMaker__reserve1 : integer;
  var AutomatedMarketMaker_blockTimestampLast : integer;
  var AutomatedMarketMaker_price0CumulativeLast : integer;
  var AutomatedMarketMaker_price1CumulativeLast : integer;
  var AutomatedMarketMaker_kLast : integer;
  var FixedSupplyToken__totalSupply : integer;
  var FixedSupplyToken_balances : [address] integer;
  var FixedSupplyToken_allowances : [address] [address] integer;
  var FixedSupplyToken1__totalSupply : integer;
  var FixedSupplyToken1_balances : [address] integer;
  var FixedSupplyToken1_allowances : [address] [address] integer;
  var LiquidityToken__totalSupply : integer;
  var LiquidityToken_balances : [address] integer;
  var LiquidityToken_allowances : [address] [address] integer;
  var dummy : integer;

  procedure FixedSupplyToken_constructor (msg_caller : address)
    modifies FixedSupplyToken__totalSupply, FixedSupplyToken_balances, dummy;
  {
    FixedSupplyToken__totalSupply = 100000;
    FixedSupplyToken__totalSupply = 100000;
    FixedSupplyToken_balances[msg_caller] = 100000;
  }

  procedure FixedSupplyToken_totalSupply (msg_caller : address)
    returns (r : integer)
  {
    var bal0 : integer;
    var resultU : integer;
    var totalSupply : integer;
    bal0 = FixedSupplyToken_balances[0];
    totalSupply = FixedSupplyToken__totalSupply;
    resultU = (totalSupply - bal0);
    r = resultU;
  }

  procedure FixedSupplyToken_balanceOf (tokenOwner : address, msg_caller : address)
    returns (r : integer)
  {
    var bal : integer;
    var resultU : integer;
    bal = FixedSupplyToken_balances[tokenOwner];
    resultU = bal;
    r = resultU;
  }

  procedure FixedSupplyToken_transfer (toA : address, tokens : integer, msg_caller : address)
    returns (r : boolean)
    modifies FixedSupplyToken_balances, dummy;
  {
    var fromA : address;
    var from_bal : integer;
    var resultU : boolean;
    var to_bal : integer;
    fromA = msg_caller;
    from_bal = FixedSupplyToken_balances[fromA];
    to_bal = FixedSupplyToken_balances[toA];
    assume (((fromA != toA) && (from_bal >= tokens)));
    FixedSupplyToken_balances[fromA] = (from_bal - tokens);
    FixedSupplyToken_balances[toA] = (to_bal + tokens);
    resultU = true;
    r = resultU;
  }

  procedure FixedSupplyToken_approve (spender : address, tokens : integer, msg_caller : address)
    returns (r : boolean)
    modifies FixedSupplyToken_allowances, dummy;
  {
    var resultU : boolean;
    // FixedSupplyToken_allowances[msg_caller][spender] = tokens;
    FixedSupplyToken_allowances[msg_caller] = FixedSupplyToken_allowances[msg_caller][spender -> tokens];
    resultU = true;
    r = resultU;
  }

  procedure FixedSupplyToken_transferFrom (fromA : address, toA : address, tokens : integer, msg_caller : address)
    returns (r : boolean)
    modifies FixedSupplyToken_balances, dummy;
  {
    var allowed : integer;
    var from_bal : integer;
    var resultU : boolean;
    var to_bal : integer;
    from_bal = FixedSupplyToken_balances[fromA];
    to_bal = FixedSupplyToken_balances[toA];
    allowed = FixedSupplyToken_allowances[fromA][toA];
    assume (((fromA != toA) && ((from_bal >= tokens) && (allowed >= tokens))));
    FixedSupplyToken_balances[fromA] = (from_bal - tokens);
    FixedSupplyToken_balances[toA] = (to_bal + tokens);
    resultU = true;
    r = resultU;
  }

  procedure FixedSupplyToken1_constructor (msg_caller : address)
    modifies FixedSupplyToken1__totalSupply, FixedSupplyToken1_balances, dummy;
  {
    FixedSupplyToken1__totalSupply = 100000;
    FixedSupplyToken1__totalSupply = 100000;
    FixedSupplyToken1_balances[msg_caller] = 100000;

  }

  procedure FixedSupplyToken1_totalSupply (msg_caller : address)
    returns (r : integer)
  {
    var bal0 : integer;
    var resultU : integer;
    var totalSupply : integer;
    bal0 = FixedSupplyToken1_balances[0];
    totalSupply = FixedSupplyToken1__totalSupply;
    resultU = (totalSupply - bal0);
    r = resultU;
  }

  procedure FixedSupplyToken1_balanceOf (tokenOwner : address, msg_caller : address)
    returns (r : integer)
  {
    var bal : integer;
    var resultU : integer;
    bal = FixedSupplyToken1_balances[tokenOwner];
    resultU = bal;
    r = resultU;
  }

  procedure FixedSupplyToken1_transfer (toA : address, tokens : integer, msg_caller : address)
    returns (r : boolean)
    modifies FixedSupplyToken1_balances, dummy;
  {
    var fromA : address;
    var from_bal : integer;
    var resultU : boolean;
    var to_bal : integer;
    fromA = msg_caller;
    from_bal = FixedSupplyToken1_balances[fromA];
    to_bal = FixedSupplyToken1_balances[toA];
    assume (((fromA != toA) && (from_bal >= tokens)));
    FixedSupplyToken1_balances[fromA] = (from_bal - tokens);
    FixedSupplyToken1_balances[toA] = (to_bal + tokens);
    resultU = true;
    r = resultU;
  }

  procedure FixedSupplyToken1_approve (spender : address, tokens : integer, msg_caller : address)
    returns (r : boolean)
    modifies FixedSupplyToken1_allowances, dummy;
  {
    var resultU : boolean;
    FixedSupplyToken1_allowances[msg_caller] = FixedSupplyToken1_allowances[msg_caller][spender -> tokens];
    resultU = true;
    r = resultU;
  }

  procedure FixedSupplyToken1_transferFrom (fromA : address, toA : address, tokens : integer, msg_caller : address)
    returns (r : boolean)
    modifies FixedSupplyToken1_balances, dummy;
  {
    var allowed : integer;
    var from_bal : integer;
    var resultU : boolean;
    var to_bal : integer;
    from_bal = FixedSupplyToken1_balances[fromA];
    to_bal = FixedSupplyToken1_balances[toA];
    allowed = FixedSupplyToken1_allowances[fromA][toA];
    assume (((fromA != toA) && ((from_bal >= tokens) && (allowed >= tokens))));
    FixedSupplyToken1_balances[fromA] = (from_bal - tokens);
    FixedSupplyToken1_balances[toA] = (to_bal + tokens);
    resultU = true;
    r = resultU;
  }

  procedure LiquidityToken_constructor (msg_caller : address)
    modifies LiquidityToken__totalSupply, LiquidityToken_balances, dummy;
  {
    LiquidityToken__totalSupply = 0;
    LiquidityToken_balances[msg_caller] = 100000;

  }

  procedure LiquidityToken_mint (toA : address, value : integer, msg_caller : address)
    modifies LiquidityToken__totalSupply, LiquidityToken_balances, dummy;
  {
    var to_bal : integer;
    var totalSupply : integer;
    totalSupply = LiquidityToken__totalSupply;
    LiquidityToken__totalSupply = (totalSupply + value);
    to_bal = LiquidityToken_balances[toA];
    LiquidityToken_balances[toA] = (to_bal + value);

  }

  procedure LiquidityToken_burn (fromA : address, value : integer, msg_caller : address)
    modifies LiquidityToken__totalSupply, LiquidityToken_balances, dummy;
  {
    var from_bal : integer;
    var totalSupply : integer;
    totalSupply = LiquidityToken__totalSupply;
    LiquidityToken__totalSupply = (totalSupply - value);
    from_bal = LiquidityToken_balances[fromA];
    LiquidityToken_balances[fromA] = (from_bal - value);

  }

  procedure LiquidityToken_totalSupply (msg_caller : address)
    returns (r : integer)
  {
    var bal0 : integer;
    var resultU : integer;
    var totalSupply : integer;
    bal0 = LiquidityToken_balances[0];
    totalSupply = LiquidityToken__totalSupply;
    resultU = (totalSupply - bal0);
    r = resultU;
  }

  procedure LiquidityToken_balanceOf (tokenOwner : address, msg_caller : address)
    returns (r : integer)
  {
    var bal : integer;
    var resultU : integer;
    bal = LiquidityToken_balances[tokenOwner];
    resultU = bal;
    r = resultU;
  }

  procedure LiquidityToken_transfer (toA : address, tokens : integer, msg_caller : address)
    returns (r : boolean)
    modifies LiquidityToken_balances, dummy;
  {
    var fromA : address;
    var from_bal : integer;
    var resultU : boolean;
    var to_bal : integer;
    fromA = msg_caller;
    from_bal = LiquidityToken_balances[fromA];
    to_bal = LiquidityToken_balances[toA];
    assume (((fromA != toA) && (from_bal >= tokens)));
    LiquidityToken_balances[fromA] = (from_bal - tokens);
    LiquidityToken_balances[toA] = (to_bal + tokens);
    resultU = true;
    r = resultU;
  }

  procedure LiquidityToken_approve (spender : address, tokens : integer, msg_caller : address)
    returns (r : boolean)
    modifies LiquidityToken_allowances, dummy;
  {
    var resultU : boolean;
    LiquidityToken_allowances[msg_caller] = LiquidityToken_allowances[msg_caller][spender -> tokens];
    resultU = true;
    r = resultU;
  }

  procedure LiquidityToken_transferFrom (fromA : address, toA : address, tokens : integer, msg_caller : address)
    returns (r : boolean)
    modifies LiquidityToken_balances, dummy;
  {
    var allowed : integer;
    var from_bal : integer;
    var resultU : boolean;
    var to_bal : integer;
    from_bal = LiquidityToken_balances[fromA];
    to_bal = LiquidityToken_balances[toA];
    allowed = LiquidityToken_allowances[fromA][toA];
    assume (((fromA != toA) && ((from_bal >= tokens) && (allowed >= tokens))));
    LiquidityToken_balances[fromA] = (from_bal - tokens);
    LiquidityToken_balances[toA] = (to_bal + tokens);
    resultU = true;
    r = resultU;
  }

  procedure AutomatedMarketMakerLib_constructor (msg_caller : address)
  {

  }

  procedure AutomatedMarketMakerLib_getAmountIn (balance : integer, amountOut : integer, reserve : integer, msg_caller : address)
    returns (r : integer)
  {
    var amountIn : integer;
    var netLended : integer;
    var resultU : integer;
    netLended = (reserve - amountOut);
    if ((balance > netLended))
    {
      resultU = (balance - netLended);
    }
    else
    {
      resultU = 0;
    }
    resultU = amountIn;
    r = resultU;
  }

  procedure AutomatedMarketMakerLib_getBalanceAdjusted (balance : integer, amountIn : integer, msg_caller : address)
    returns (r : integer)
  {
    var resultU : integer;
    resultU = ((balance * 1000) - (amountIn * 3));
    r = resultU;
  }

  procedure AutomatedMarketMakerLib_min (x : integer, y : integer, msg_caller : address)
    returns (r : integer)
  {
    var resultU : integer;
    if ((x < y))
    {
      resultU = x;
    }
    else
    {
      resultU = y;
    }
    r = resultU;
  }

  procedure AutomatedMarketMaker_constructor (msg_caller : address)
    modifies AutomatedMarketMaker__owner, AutomatedMarketMaker__reserve0, AutomatedMarketMaker__reserve1, AutomatedMarketMaker__token0, AutomatedMarketMaker__token1, AutomatedMarketMaker_blockTimestampLast, AutomatedMarketMaker_kLast, AutomatedMarketMaker_price0CumulativeLast, AutomatedMarketMaker_price1CumulativeLast, dummy;
  {
    AutomatedMarketMaker__token0 = 1248875146012964071876423320777688075155124985543;
    AutomatedMarketMaker__token1 = 611382286831621467233887798921843936019654057231;
    AutomatedMarketMaker__owner = 0;
    AutomatedMarketMaker__reserve0 = 0;
    AutomatedMarketMaker__reserve1 = 0;
    AutomatedMarketMaker_blockTimestampLast = 0;
    AutomatedMarketMaker_price0CumulativeLast = 0;
    AutomatedMarketMaker_price1CumulativeLast = 0;
    AutomatedMarketMaker_kLast = 0;
    AutomatedMarketMaker__owner = msg_caller;

  }

  procedure div (x : integer, y : integer) 
        returns (r : integer)
    {
        assume(y == r * x);
    }

  procedure AutomatedMarketMaker_mint (toA : address, msg_caller : address)
    modifies AutomatedMarketMaker__reserve0, AutomatedMarketMaker__reserve1, LiquidityToken__totalSupply, LiquidityToken_balances, dummy;
  {
    var amount0 : integer;
    var amount1 : integer;
    var balance0 : integer;
    var balance1 : integer;
    var liquidity : integer;
    var reserve0 : integer;
    var reserve1 : integer;
    var totalSupply : integer;
    var xx : integer;
    var xxx : integer;
    reserve0 = AutomatedMarketMaker__reserve0;
    reserve1 = AutomatedMarketMaker__reserve1;
    call (balance0) = FixedSupplyToken_balanceOf (AutomatedMarketMaker_address, AutomatedMarketMaker_address);
    call (balance1) = FixedSupplyToken1_balanceOf (AutomatedMarketMaker_address, AutomatedMarketMaker_address);
    amount0 = (balance0 - reserve0);
    amount1 = (balance1 - reserve1);
    call (totalSupply) = LiquidityToken_totalSupply (AutomatedMarketMaker_address);
    
    if ((totalSupply == 0))
    {
      call () = LiquidityToken_mint (0, 1000, AutomatedMarketMaker_address);
      liquidity = ((amount0 * amount1) - 1000);
    }
    else
    {
      call (xx) = div ((amount0 * totalSupply), reserve0);
      call (xxx) = div ((amount1 * totalSupply), reserve1);
      call (liquidity) = AutomatedMarketMakerLib_min (xx, xxx, AutomatedMarketMaker_address);
    }
    assume ((liquidity > 0));
    call () = LiquidityToken_mint (toA, liquidity, AutomatedMarketMaker_address);
    AutomatedMarketMaker__reserve0 = balance0;
    AutomatedMarketMaker__reserve1 = balance1;

  }

  procedure AutomatedMarketMaker_burn (toA : address, msg_caller : address)
    modifies AutomatedMarketMaker__reserve0, AutomatedMarketMaker__reserve1, FixedSupplyToken1_balances, FixedSupplyToken_balances, LiquidityToken__totalSupply, LiquidityToken_balances, dummy;
  {
    var amount0 : integer;
    var amount1 : integer;
    var balance0 : integer;
    var balance1 : integer;
    var liquidity : integer;
    var reserve0 : integer;
    var reserve1 : integer;
    var success : boolean;
    var totalSupply : integer;
    reserve0 = AutomatedMarketMaker__reserve0;
    reserve1 = AutomatedMarketMaker__reserve1;
    call (balance0) = FixedSupplyToken_balanceOf (AutomatedMarketMaker_address, AutomatedMarketMaker_address);
    call (balance1) = FixedSupplyToken1_balanceOf (AutomatedMarketMaker_address, AutomatedMarketMaker_address);
    call (liquidity) = LiquidityToken_balanceOf (AutomatedMarketMaker_address, AutomatedMarketMaker_address);
    call (totalSupply) = LiquidityToken_totalSupply (AutomatedMarketMaker_address);
    call (amount0) = div ((liquidity * balance0), totalSupply);
    call (amount1) = div ((liquidity * balance1), totalSupply);
    assume (((amount0 > 0) && (amount1 > 0)));
    call () = LiquidityToken_burn (AutomatedMarketMaker_address, liquidity, AutomatedMarketMaker_address);
    call (success) = FixedSupplyToken_transfer (toA, amount0, AutomatedMarketMaker_address);
    assume (success);
    call (success) = FixedSupplyToken1_transfer (toA, amount1, AutomatedMarketMaker_address);
    assume (success);
    call (balance0) = FixedSupplyToken_balanceOf (AutomatedMarketMaker_address, AutomatedMarketMaker_address);
    call (balance1) = FixedSupplyToken1_balanceOf (AutomatedMarketMaker_address, AutomatedMarketMaker_address);
    AutomatedMarketMaker__reserve0 = balance0;
    AutomatedMarketMaker__reserve1 = balance1;

  }

  procedure AutomatedMarketMaker_simpleSwap0 (toA : address, msg_caller : address)
    returns (r : integer)
    modifies AutomatedMarketMaker__reserve0, AutomatedMarketMaker__reserve1, FixedSupplyToken1_balances, dummy;
  {
    var amount0In : integer;
    var amountInWithFee : integer;
    var balance0 : integer;
    var balance1 : integer;
    var denominator : integer;
    var numerator : integer;
    var reserve0 : integer;
    var reserve1 : integer;
    var result : integer;
    var resultU : integer;
    var success : boolean;
    var token0 : address;
    var token1 : address;
    reserve0 = AutomatedMarketMaker__reserve0;
    reserve1 = AutomatedMarketMaker__reserve1;
    call (balance0) = FixedSupplyToken_balanceOf (AutomatedMarketMaker_address, AutomatedMarketMaker_address);
    call (balance1) = FixedSupplyToken1_balanceOf (AutomatedMarketMaker_address, AutomatedMarketMaker_address);
    amount0In = (balance0 - reserve0);
    token0 = AutomatedMarketMaker__token0;
    token1 = AutomatedMarketMaker__token1;
    assume (((toA != token0) && (toA != token1)));
    assume ((amount0In > 0));
    assume (((reserve0 > 0) && (reserve1 > 0)));
    amountInWithFee = (amount0In * 997);
    numerator = (amountInWithFee * reserve1);
    denominator = ((reserve0 * 1000) + amountInWithFee);
    call (result) = div (numerator, denominator);
    call (success) = FixedSupplyToken1_transfer (toA, result, AutomatedMarketMaker_address);
    assume (success);
    call (balance0) = FixedSupplyToken_balanceOf (AutomatedMarketMaker_address, AutomatedMarketMaker_address);
    call (balance1) = FixedSupplyToken1_balanceOf (AutomatedMarketMaker_address, AutomatedMarketMaker_address);
    AutomatedMarketMaker__reserve0 = balance0;
    AutomatedMarketMaker__reserve1 = balance1;
    resultU = result;
    r = resultU;
  }

  procedure AutomatedMarketMaker_swap (amount0Out : integer, amount1Out : integer, toA : address, msg_caller : address)
    modifies AutomatedMarketMaker__reserve0, AutomatedMarketMaker__reserve1, FixedSupplyToken1_balances, FixedSupplyToken_balances, dummy;
  {
    var amount0In : integer;
    var amount1In : integer;
    var balance0 : integer;
    var balance0Adjusted : integer;
    var balance1 : integer;
    var balance1Adjusted : integer;
    var reserve0 : integer;
    var reserve1 : integer;
    var success : boolean;
    var token0 : address;
    var token1 : address;
    assume (((amount0Out > 0) || (amount1Out > 0)));
    reserve0 = AutomatedMarketMaker__reserve0;
    reserve1 = AutomatedMarketMaker__reserve1;
    token0 = AutomatedMarketMaker__token0;
    token1 = AutomatedMarketMaker__token1;
    assume (((amount0Out < reserve0) && (amount1Out < reserve1)));
    assume (((toA != token0) && (toA != token1)));
    call (balance0) = FixedSupplyToken_balanceOf (AutomatedMarketMaker_address, AutomatedMarketMaker_address);
    call (balance1) = FixedSupplyToken1_balanceOf (AutomatedMarketMaker_address, AutomatedMarketMaker_address);
    call (amount0In) = AutomatedMarketMakerLib_getAmountIn (balance0, 0, reserve0, AutomatedMarketMaker_address);
    call (amount1In) = AutomatedMarketMakerLib_getAmountIn (balance1, 0, reserve1, AutomatedMarketMaker_address);
    assume (((amount0In > 0) || (amount1In > 0)));
    call (balance0Adjusted) = AutomatedMarketMakerLib_getBalanceAdjusted ((balance0 - amount0Out), amount0In, AutomatedMarketMaker_address);
    call (balance1Adjusted) = AutomatedMarketMakerLib_getBalanceAdjusted ((balance1 - amount1Out), amount1In, AutomatedMarketMaker_address);
    assume (((balance0Adjusted * balance1Adjusted) > (((reserve0 * reserve1) * 1000) * 1000)));
    if ((amount0Out > 0))
    {
      call (success) = FixedSupplyToken_transfer (toA, amount0Out, AutomatedMarketMaker_address);
      assume (success);
    }
    else
    {
    
    }
    if ((amount1Out > 0))
    {
          call (success) = FixedSupplyToken1_transfer (toA, amount1Out, AutomatedMarketMaker_address);
      assume (success);
    }
    else
    {

    }
    AutomatedMarketMaker__reserve0 = balance0;
    AutomatedMarketMaker__reserve1 = balance1;

  }

  procedure AutomatedMarketMaker_skim (toA : address, msg_caller : address)
    modifies FixedSupplyToken1_balances, FixedSupplyToken_balances, dummy;
  {
    var balance0 : integer;
    var balance1 : integer;
    var reserve0 : integer;
    var reserve1 : integer;
    var skim0 : integer;
    var skim1 : integer;
    var success : boolean;
    reserve0 = AutomatedMarketMaker__reserve0;
    reserve1 = AutomatedMarketMaker__reserve1;
    call (balance0) = FixedSupplyToken_balanceOf (AutomatedMarketMaker_address, AutomatedMarketMaker_address);
    call (balance1) = FixedSupplyToken1_balanceOf (AutomatedMarketMaker_address, AutomatedMarketMaker_address);
    skim0 = (balance0 - reserve0);
    skim1 = (balance1 - reserve1);
    call (success) = FixedSupplyToken_transfer (toA, skim0, AutomatedMarketMaker_address);
    assume (success);
    call (success) = FixedSupplyToken1_transfer (toA, skim1, AutomatedMarketMaker_address);
    assume (success);

  }

  procedure AutomatedMarketMaker_sync (msg_caller : address)
    modifies AutomatedMarketMaker__reserve0, AutomatedMarketMaker__reserve1, dummy;
  {
    var balance0 : integer;
    var balance1 : integer;
    call (balance0) = FixedSupplyToken_balanceOf (AutomatedMarketMaker_address, AutomatedMarketMaker_address);
    call (balance1) = FixedSupplyToken1_balanceOf (AutomatedMarketMaker_address, AutomatedMarketMaker_address);
    AutomatedMarketMaker__reserve0 = balance0;
    AutomatedMarketMaker__reserve1 = balance1;

  }

  procedure AutomatedMarketMaker_k (msg_caller : address)
    returns (r : integer)
  {
    var reserve0 : integer;
    var reserve1 : integer;
    var resultU : integer;
    reserve0 = AutomatedMarketMaker__reserve0;
    reserve1 = AutomatedMarketMaker__reserve1;
    resultU = (reserve0 * reserve1);
    r = resultU;
  }

  procedure AutomatedMarketMaker_quote0 (amount0 : integer, msg_caller : address)
    returns (r : integer)
  {
    var reserve0 : integer;
    var reserve1 : integer;
    var resultU : integer;
    assume ((amount0 > 0));
    reserve0 = AutomatedMarketMaker__reserve0;
    reserve1 = AutomatedMarketMaker__reserve1;
    assume (((reserve0 > 0) && (reserve1 > 0)));
    call (resultU) = div ((amount0 * reserve1), reserve0);
    r = resultU;
  }

  procedure AutomatedMarketMaker_getAmountOut0 (amount0In : integer, msg_caller : address)
    returns (r : integer)
  {
    var amountInWithFee : integer;
    var denominator : integer;
    var numerator : integer;
    var reserve0 : integer;
    var reserve1 : integer;
    var resultU : integer;
    assume ((amount0In > 0));
    reserve0 = AutomatedMarketMaker__reserve0;
    reserve1 = AutomatedMarketMaker__reserve1;
    assume (((reserve0 > 0) && (reserve1 > 0)));
    amountInWithFee = (amount0In * 997);
    numerator = (amountInWithFee * reserve1);
    denominator = ((reserve0 * 1000) + amountInWithFee);
    call (resultU) = div (numerator, denominator);
    r = resultU;
  }

  procedure AutomatedMarketMaker_getAmountIn0 (amount0Out : integer, msg_caller : address)
    returns (r : integer)
  {
    var denominator : integer;
    var xx : integer;
    var numerator : integer;
    var reserve0 : integer;
    var reserve1 : integer;
    var resultU : integer;
    assume ((amount0Out > 0));
    reserve0 = AutomatedMarketMaker__reserve0;
    reserve1 = AutomatedMarketMaker__reserve1;
    assume (((reserve0 > 0) && (reserve1 > 0)));
    numerator = ((reserve1 * amount0Out) * 1000);
    denominator = ((reserve0 - amount0Out) * 997);
    call (xx) = div (numerator, denominator);
    resultU = (xx + 1);
    r = resultU;
  }

  init {
    AutomatedMarketMaker__token0 = 1248875146012964071876423320777688075155124985543;
    AutomatedMarketMaker__token1 = 611382286831621467233887798921843936019654057231;
    AutomatedMarketMaker__owner = 0;
    AutomatedMarketMaker__reserve0 = 0;
    AutomatedMarketMaker__reserve1 = 0;
    AutomatedMarketMaker_blockTimestampLast = 0;
    AutomatedMarketMaker_price0CumulativeLast = 0;
    AutomatedMarketMaker_price1CumulativeLast = 0;
    AutomatedMarketMaker_kLast = 0;
    FixedSupplyToken__totalSupply = 100000;
    assume (forall (i : address) :: FixedSupplyToken_balances[i] == 0);
    // assume (forall (i j : address) :: FixedSupplyToken_allowances[i][j] == 0);
    FixedSupplyToken1__totalSupply = 100000;
    assume (forall (i : address) :: FixedSupplyToken1_balances[i] == 0);
    // assume (forall (i : address) :: FixedSupplyToken1_allowances[i] == 0);
    LiquidityToken__totalSupply = 0;
    assume (forall (i : address) :: LiquidityToken_balances[i] == 0);
    // assume (forall (i : address) :: LiquidityToken_allowances[i] == 0);
  }

  next {
    var i : integer;
    assume (i >= 1 && i <= 5);

    case 
    (i == 1) : {
      call () = AutomatedMarketMaker_sync(me_caller);
    }
    (i == 2) : {
      var toA : address;
      // assume can be deleted !!!
      assume ((toA == AutomatedMarketMaker_address) || (toA == LiquidityToken_address) || (toA == FixedSupplyToken1_address) || (toA == FixedSupplyToken_address) || (toA == hackaux));
      call () = AutomatedMarketMaker_skim (toA, me_caller);
    }
    (i == 3) : {
      var r : integer;
      var toA : address;
      assume ((toA == AutomatedMarketMaker_address) || (toA == LiquidityToken_address) || (toA == FixedSupplyToken1_address) || (toA == FixedSupplyToken_address) || (toA == hackaux));
      call (r) = AutomatedMarketMaker_simpleSwap0 (toA, me_caller);
    }
    (i == 4) : {
      var toA : address;
      assume ((toA == AutomatedMarketMaker_address) || (toA == LiquidityToken_address) || (toA == FixedSupplyToken1_address) || (toA == FixedSupplyToken_address) || (toA == hackaux));
      call () = AutomatedMarketMaker_burn (toA, me_caller);
    }
    (i == 5) : {
      var toA : address;
      assume ((toA == AutomatedMarketMaker_address) || (toA == LiquidityToken_address) || (toA == FixedSupplyToken1_address) || (toA == FixedSupplyToken_address) || (toA == hackaux));
      call () = AutomatedMarketMaker_mint (toA, me_caller);
    }
    esac
  } 

}

module main {
 
  type address = integer;

  // MANUAL : set the actual hacker address
  const me_caller : address = 1;
  const hackaux : address = 2;
  const victim : address = 3;

  instance m : dsmodel (me_caller : (me_caller), hackaux : (hackaux), victim : (victim));

  init {
    // give initial values
    // init (m);

    // MANUAL :  set initial capital, need manual input
    assume (m.FixedSupplyToken_balances[me_caller] == 1000);
    assume (m.FixedSupplyToken1_balances[me_caller] == 1000);
  }

  next {
    next (m);
  }

  // does not exist a state where after that state the hacker's money is more than before
  // this models a flashloan attack, where everything happens in one single moment
  // we should also add an axiom saying that no simple arbitrage exists, that CEX price is same as DEX
  // CANNOT 10x in 5 steps
  // invariant no_arb : m.FixedSupplyToken_balances[me_caller] < (1000 * 10);
  property[LTL] no_arbitrage : !F(m.FixedSupplyToken_balances[me_caller] > (1000 * 10)); // G is F's dual

  control {
    v = bmc(6); // bmc have LTL
    // bmc(n) is the complexity of the hack
    unroll (5); // hyper-property --> invariant only ---> symbolically check
    induction;
    // bmc and havoc
    // havoc a ---> every time a is used it is a new value

    check;
    print_results;
  }

}

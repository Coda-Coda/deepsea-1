(*WARNING: This file is generated by Edsger, the DeepSEA compiler.
          All modification will be lost when regenerating.

This file contains lemmas demonstrating and checking that transferEth is called at most once in any invocation of any function. *)

Require Import contract.DataTypes.
Require Import contract.DataTypeOps.
Require Import lib.Monad.StateMonadOption.
Require Import cclib.Maps.
Require Import cclib.Integers.
Require Import ZArith.
Require Import core.HyperTypeInst.
Require Import backend.MachineModel.
Require Import core.MemoryModel.
Require Import DeepSpec.lib.Monad.RunStateTInv.
Require Import Lia.
Require Import contract.GenericMachineEnv.
Require Import contract.LayerETH_layer.
Require Import contract.LayerCONTRACT.

Module SingleTransferCheck.

Transparent ETH_constructor_opt.
Transparent Contract_constructor_opt.
Transparent Contract_ceip_example_ok_opt.
Transparent Contract_ceip_example_not_ok_opt.

Ltac unfold_all :=
unfold ETH_constructor_opt in *;
unfold Contract_constructor_opt in *;
unfold Contract_ceip_example_ok_opt in *;
unfold Contract_ceip_example_not_ok_opt in *;
simpl.





Section Block_Context. (* like bstep *)
(* 'Forall Blocks:' *)
Context
  (coinbase : int256)
  (timestamp : int256)
  (number : int256)
  (blockhash : int256 -> int256)
  (chainid : int256).

Section Nested_Calls_Context.
(* 'Forall calls from EoA:' *)
Context
  (origin: addr).

Section Individual_Call_Context. (* like mstep *)
(* 'Forall function calls: '*)
Context 
  (contract_address : addr)
  (caller: addr)
  (callvalue : int256)
  (initial_balances : addr -> int256)
  (address_always_accepts_funds : addr -> bool).

  Context {HmemOps: MemoryModelOps mem}.
  Context {memModelOps : MemoryModelOps mem}.
  Instance GlobalLayerSpec : LayerSpecClass := {
    memModelOps := memModelOps;
    GetHighData := global_abstract_data_type 
  }.
  

  Definition me := 
    GenericMachineEnv.generic_machine_env coinbase timestamp number blockhash chainid origin contract_address caller callvalue initial_balances address_always_accepts_funds.


    
(* The following tactic will also destruct goals that include an me_transfer
     that checks if the contract has sufficient funds.
     IMPORTANT: Note that this may only be valid in cases where it is correct to
     assume that at most one transfer per function call is done. If more than
     one transfer is allowed it would need to be checked that me_transfer
     correctly accounts for the reductions in the contract's balance. Changes
     to me_transfer would likely cause related changes to be necessary in this
     tactic. *)
     Ltac inv_runStateT_branching_with_me_transfer_cases :=
      repeat (
        try inv_runStateT_branching;
        let Case := fresh "SufficientFundsToTransferCase" in
        try match goal with
          | H : context[me_transfer _  _ _] |- _ => 
          unfold me_transfer, me, GenericMachineEnv.generic_machine_env in H;
          destruct (GenericMachineEnv.successful_transfer _ _ _ _) eqn:Case
        end
      ).
    
    (* This tactic solves goals relating to transfer only being called once,
        it automatically expands all branches. Note that this means it may fail
        in particular cases where the validity of the associated lemmas depends
        on the interactions between 'if statements' (for example). In such
        (probably unlikely) cases interactive proof could be undertaken instead
        of relying on this tactic. *)
    Ltac solve_single_transfer :=
      intros;
      repeat unfold_all;
      repeat inv_runStateT_branching_with_me_transfer_cases;
      subst;
      solve [
        match goal with
        | H : ETH_successful_transfers _ = nil |- _ => rewrite H; simpl; lia
        end
        |
        match goal with
        | H : Int256.eq Int256.zero Int256.one = true |- _ => 
            apply ArithInv.Int256eq_true in H;
            inversion H
        end
        |
        match goal with
          | H : Int256.eq Int256.one Int256.one = false |- _ => 
            apply ArithInv.Int256eq_false in H;
           contradiction
        end
        |
        match goal with
          | H : runStateT mzero _ = ret _ |- _ => 
            simpl in H; inversion H    
        end
        |
        simpl;
        match goal with
          | H : ETH_successful_transfers ?X = nil |- context[ETH_successful_transfers ?X] => 
            rewrite H; simpl; lia
        end
      ].


(* Lemmas *)



Lemma ETH_constructor_opt_single_transfer : forall d d'  result,
(ETH_successful_transfers d = nil) -> runStateT (ETH_constructor_opt  me) d = Some (result, d') -> 
(length (ETH_successful_transfers d') <= 1)%nat.
Proof.
solve_single_transfer. (* If this tactic fails it indicates that the ETH_constructor_opt function either calls transferEth twice (which is considered a bad pattern) or doesn't call transferEth twice but has complex logic such as two interrelated if statements that make the tactic fail. *)
Qed.


Lemma Contract_constructor_opt_single_transfer : forall d d'  result,
(ETH_successful_transfers d = nil) -> runStateT (Contract_constructor_opt  me) d = Some (result, d') -> 
(length (ETH_successful_transfers d') <= 1)%nat.
Proof.
solve_single_transfer. (* If this tactic fails it indicates that the Contract_constructor_opt function either calls transferEth twice (which is considered a bad pattern) or doesn't call transferEth twice but has complex logic such as two interrelated if statements that make the tactic fail. *)
Qed.


Lemma Contract_ceip_example_ok_opt_single_transfer : forall d d'  result,
(ETH_successful_transfers d = nil) -> runStateT (Contract_ceip_example_ok_opt  me) d = Some (result, d') -> 
(length (ETH_successful_transfers d') <= 1)%nat.
Proof.
solve_single_transfer. (* If this tactic fails it indicates that the Contract_ceip_example_ok_opt function either calls transferEth twice (which is considered a bad pattern) or doesn't call transferEth twice but has complex logic such as two interrelated if statements that make the tactic fail. *)
Qed.


Lemma Contract_ceip_example_not_ok_opt_single_transfer : forall d d'  result,
(ETH_successful_transfers d = nil) -> runStateT (Contract_ceip_example_not_ok_opt  me) d = Some (result, d') -> 
(length (ETH_successful_transfers d') <= 1)%nat.
Proof.
solve_single_transfer. (* If this tactic fails it indicates that the Contract_ceip_example_not_ok_opt function either calls transferEth twice (which is considered a bad pattern) or doesn't call transferEth twice but has complex logic such as two interrelated if statements that make the tactic fail. *)
Qed.


End Individual_Call_Context.

End Nested_Calls_Context.

End Block_Context.

End SingleTransferCheck.
  
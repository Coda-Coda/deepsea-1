(* WARNING: This file is generated by Edsger, the DeepSEA compiler.
            All modification will be lost when regenerating. *)
(* Module contract.LayerCONTRACT for contract.ds *)
Require Import BinPos.
Require Import DeepSpec.Runtime.
Require Import contract.EdsgerIdents.
Require Import contract.DataTypes.
Require Import contract.DataTypeOps.
Require Import contract.DataTypeProofs.
Require Import DeepSpec.lib.Monad.Monad.
Require Import DeepSpec.lib.Monad.MonadState.
Require Import DeepSpec.lib.Monad.StateMonad.
Require Import DeepSpec.lib.Monad.OptionMonad.
Require Import DeepSpec.lib.Monad.MonadZero.
Require Import DeepSpec.core.SynthesisStmt.
Require Import DeepSpec.core.SynthesisFunc.
Require Import backend.MachineModel.
Existing Instance MonadState_DS.
Existing Instance MonadZero_DS.
Require Export contract.LayerETH_layer.

Section EdsgerGen.



Context {memModelOps : MemoryModelOps mem}.
Instance GlobalLayerSpec : LayerSpecClass := {
  memModelOps := memModelOps;
  GetHighData := global_abstract_data_type 
}.


Context`{global_abdata : !GlobalAbData init_global_abstract_data global_low_level_invariant}.
Definition CONTRACT_kernel_mode (abd : global_abstract_data_type) := True.
Global Arguments CONTRACT_kernel_mode / abd.

Class Layer_CONTRACT_Context_prf  := {
  (* ensuring global empty data matches those in the object definitions *)
  CONTRACT_init_Contract_transferSuccessful_eq : Contract_transferSuccessful init_global_abstract_data = false;
  CONTRACT_init_ETH_successful_transfers_eq : ETH_successful_transfers init_global_abstract_data = nil
}.
Context`{CTXT_prf : !Layer_CONTRACT_Context_prf}.

Instance CONTRACT_data_ops : CompatDataOps global_abstract_data_type := {
  empty_data := init_global_abstract_data;
  high_level_invariant d := True;
}.

Instance CONTRACT_data : CompatData global_abstract_data_type := {
empty_data_high_level_invariant := I
}.

Instance CONTRACT_overlay_spec : OverlaySpecClass := {
}.



(* (* TODO: add this back in for the Ethereum backend. *)
Global Instance Layer_CONTRACT'ETH_layer_Context_prf : Layer_ETH_layer_Context_prf.
Proof. esplit; apply CTXT_prf.
Qed.
Context`{ETH_layer_pres_inv : !ETH_layer_preserves_invariants}.
*)

Instance CONTRACT_underlay_spec : UnderlaySpecClass := {
  cdataOpsLow := ETH_layer_data_ops;
  cdataLow := ETH_layer_data;
}.


Section OBJECT_Contract_DEFINITION.
  Context`{HM : !HyperMem}.

  (* Object variables *)
  Definition Contract_transferSuccessful_var := {|
    ltype_tp_marker := tint_bool;

    ltype_ident := HighValues.Field HighValues.Global var_Contract_Contract_transferSuccessful_ident;
    ltype_ghost := false;

    ltype_get := Contract_transferSuccessful;
    ltype_set := update_Contract_transferSuccessful;

    ltype_set_ocond := otrue1;
    ltype_get_extra_ocond := otrue1
  |}.

  Definition Contract_constructor := {|
    FC_ident_start := BuiltinBase_local_ident_start;
    FC_params := nil;
    FC_returns := void_unit_pair;
    FC_body := (CCsequence
      (CCsequence
        (CCstore
          (LCvar Contract_transferSuccessful_var)
          (ECconst_int256 tint_bool false Int256.zero))
        CCskip)
      CCskip)
  |}.
  Lemma Contract_constructor_wf
      : synth_func_wellformed Contract_constructor.
  Proof. solve_wellformed. Defined.
  Definition Contract_constructor_opt : machine_env GetHighData -> DS unit  := 
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             Contract_transferSuccessful update_Contract_transferSuccessful ETH_successful_transfers update_ETH_successful_transfers]
  in synth_func_spec_opt Contract_constructor Contract_constructor_wf.
  Definition Contract_constructor_spec_hlist_opt args :=
    @apply_param_func Contract_constructor.(FC_params) _
                      (Contract_constructor_opt) args.


(* CEI stands for Checks Effects Interactions (pattern) and the definitions below are used
    to keep track of the safe situations in which a primitive can be called. See also
    cmd_constr_CEI_pattern_prf in Syntax.v and for the tactic definitions see Runtime.v *)
    
Lemma Contract_constructor_CEI_AB : { rsts | function_constr_CEI_pattern_prf (fst rsts) Contract_constructor (snd rsts)}.
Proof.
  unfold Contract_constructor.
  CEI_auto_AB. (* If this tactic fails then it indicates that a strict version of the Checks-Effects-Interactions pattern was not followed in the function: Contract_constructor. *)
Defined.

Lemma Contract_constructor_CEI_BA : { rsts | function_constr_CEI_pattern_prf (fst rsts) Contract_constructor (snd rsts)}.
Proof.
  unfold Contract_constructor.
  CEI_auto_BA.
Defined.

Definition Contract_constructor_CEI_rsts_before_A := fst (proj1_sig Contract_constructor_CEI_AB).
Definition Contract_constructor_CEI_rsts_after_A := snd (proj1_sig Contract_constructor_CEI_AB).
Definition Contract_constructor_CEI_rsts_before_B := fst (proj1_sig Contract_constructor_CEI_BA).
Definition Contract_constructor_CEI_rsts_after_B := snd (proj1_sig Contract_constructor_CEI_BA).

  Definition Contract_constructor_prim := {|
    PRIMident := ident_Contract_constructor;
    (* PRIMcc := AST.cc_default; *)
    PRIMghost := false;
    PRIMpure := false;
    PRIMargt_marker := Contract_constructor.(FC_params);
    PRIMret_marker := Contract_constructor.(FC_returns);
    PRIMrst_before_A := Contract_constructor_CEI_rsts_before_A;
    PRIMrst_after_A := Contract_constructor_CEI_rsts_after_A;
    PRIMrst_before_B := Contract_constructor_CEI_rsts_before_B;
    PRIMrst_after_B := Contract_constructor_CEI_rsts_after_B;
    PRIMcond := fun _ _ _ => True;
    (* PRIMsem := Contract_constructor_spec_hlist; *)
    PRIMsem_opt := Contract_constructor_spec_hlist_opt
  |}.

  Lemma Contract_constructor_spec_hlist_opt_eq :
    Contract_constructor_spec_hlist_opt =
    fun args => apply_param_func
      (synth_func_spec_opt Contract_constructor Contract_constructor_wf)
      args.
  Proof.
    cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             Contract_transferSuccessful update_Contract_transferSuccessful ETH_successful_transfers update_ETH_successful_transfers]. 
     reflexivity.
  Qed.
  Definition Contract_constructor_cfun :=
  Eval cbv in synth_func_func Contract_constructor.

  Definition Contract_constructor_cond  me d  :=
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             Contract_transferSuccessful update_Contract_transferSuccessful ETH_successful_transfers update_ETH_successful_transfers]
    in
    high_level_invariant d ->
    synth_func_cond Contract_constructor Contract_constructor_wf
								      me d.
  
  Lemma Contract_constructor_cond_eq : forall  me d, 
    Contract_constructor_cond  me d ->
    high_level_invariant d ->
    synth_func_cond Contract_constructor Contract_constructor_wf  me d.
    Proof.
      intros  me d H_cond.
      cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             Contract_transferSuccessful update_Contract_transferSuccessful ETH_successful_transfers update_ETH_successful_transfers].
       exact H_cond.
    Qed.

  Definition Contract_constructor_obligation  me d  :=
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             Contract_transferSuccessful update_Contract_transferSuccessful ETH_successful_transfers update_ETH_successful_transfers]
    in
    high_level_invariant d ->
    synth_func_obligation Contract_constructor Contract_constructor_wf
								      me d.
  
  Lemma Contract_constructor_obligation_eq : forall  me d, 
    Contract_constructor_obligation  me d ->
    high_level_invariant d ->
    synth_func_obligation Contract_constructor Contract_constructor_wf  me d.
    Proof.
      intros  me d H_cond.
      cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             Contract_transferSuccessful update_Contract_transferSuccessful ETH_successful_transfers update_ETH_successful_transfers].
       exact H_cond.
    Qed.

  Definition Contract_constructor_spec :=
  Eval cbv [sf_mem sf_return fst snd Contract_constructor_opt] in
    fun  me => execStateT (Contract_constructor_opt me).
  Lemma Contract_constructor_spec_eq :
    Contract_constructor_spec =
    fun  me => execStateT (synth_func_spec_opt Contract_constructor Contract_constructor_wf me).
  Proof.
    cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

          Contract_transferSuccessful update_Contract_transferSuccessful ETH_successful_transfers update_ETH_successful_transfers].
    reflexivity.
  Qed.

Global Opaque Contract_constructor_opt.

  Definition Contract_safeExample := {|
    FC_ident_start := BuiltinBase_local_ident_start;
    FC_params := nil;
    FC_returns := void_unit_pair;
    FC_body := (CCsequence
      (CCstore
        (LCvar Contract_transferSuccessful_var)
        (ECconst_int256 tint_bool true Int256.one))
      (CCtransfer (@ECbuiltin0 _ _  _ builtin0_caller_impl)(ECconst_int256 tint_U (Int256.repr 42) (Int256.repr 42))))
  |}.
  Lemma Contract_safeExample_wf
      : synth_func_wellformed Contract_safeExample.
  Proof. solve_wellformed. Defined.
  Definition Contract_safeExample_opt : machine_env GetHighData -> DS unit  := 
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             Contract_transferSuccessful update_Contract_transferSuccessful ETH_successful_transfers update_ETH_successful_transfers]
  in synth_func_spec_opt Contract_safeExample Contract_safeExample_wf.
  Definition Contract_safeExample_spec_hlist_opt args :=
    @apply_param_func Contract_safeExample.(FC_params) _
                      (Contract_safeExample_opt) args.


(* CEI stands for Checks Effects Interactions (pattern) and the definitions below are used
    to keep track of the safe situations in which a primitive can be called. See also
    cmd_constr_CEI_pattern_prf in Syntax.v and for the tactic definitions see Runtime.v *)
    
Lemma Contract_safeExample_CEI_AB : { rsts | function_constr_CEI_pattern_prf (fst rsts) Contract_safeExample (snd rsts)}.
Proof.
  unfold Contract_safeExample.
  CEI_auto_AB. (* If this tactic fails then it indicates that a strict version of the Checks-Effects-Interactions pattern was not followed in the function: Contract_safeExample. *)
Defined.

Lemma Contract_safeExample_CEI_BA : { rsts | function_constr_CEI_pattern_prf (fst rsts) Contract_safeExample (snd rsts)}.
Proof.
  unfold Contract_safeExample.
  CEI_auto_BA.
Defined.

Definition Contract_safeExample_CEI_rsts_before_A := fst (proj1_sig Contract_safeExample_CEI_AB).
Definition Contract_safeExample_CEI_rsts_after_A := snd (proj1_sig Contract_safeExample_CEI_AB).
Definition Contract_safeExample_CEI_rsts_before_B := fst (proj1_sig Contract_safeExample_CEI_BA).
Definition Contract_safeExample_CEI_rsts_after_B := snd (proj1_sig Contract_safeExample_CEI_BA).

  Definition Contract_safeExample_prim := {|
    PRIMident := ident_Contract_safeExample;
    (* PRIMcc := AST.cc_default; *)
    PRIMghost := false;
    PRIMpure := false;
    PRIMargt_marker := Contract_safeExample.(FC_params);
    PRIMret_marker := Contract_safeExample.(FC_returns);
    PRIMrst_before_A := Contract_safeExample_CEI_rsts_before_A;
    PRIMrst_after_A := Contract_safeExample_CEI_rsts_after_A;
    PRIMrst_before_B := Contract_safeExample_CEI_rsts_before_B;
    PRIMrst_after_B := Contract_safeExample_CEI_rsts_after_B;
    PRIMcond := fun _ _ _ => True;
    (* PRIMsem := Contract_safeExample_spec_hlist; *)
    PRIMsem_opt := Contract_safeExample_spec_hlist_opt
  |}.

  Lemma Contract_safeExample_spec_hlist_opt_eq :
    Contract_safeExample_spec_hlist_opt =
    fun args => apply_param_func
      (synth_func_spec_opt Contract_safeExample Contract_safeExample_wf)
      args.
  Proof.
    cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             Contract_transferSuccessful update_Contract_transferSuccessful ETH_successful_transfers update_ETH_successful_transfers]. 
     reflexivity.
  Qed.
  Definition Contract_safeExample_cfun :=
  Eval cbv in synth_func_func Contract_safeExample.

  Definition Contract_safeExample_cond  me d  :=
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             Contract_transferSuccessful update_Contract_transferSuccessful ETH_successful_transfers update_ETH_successful_transfers]
    in
    high_level_invariant d ->
    synth_func_cond Contract_safeExample Contract_safeExample_wf
								      me d.
  
  Lemma Contract_safeExample_cond_eq : forall  me d, 
    Contract_safeExample_cond  me d ->
    high_level_invariant d ->
    synth_func_cond Contract_safeExample Contract_safeExample_wf  me d.
    Proof.
      intros  me d H_cond.
      cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             Contract_transferSuccessful update_Contract_transferSuccessful ETH_successful_transfers update_ETH_successful_transfers].
       exact H_cond.
    Qed.

  Definition Contract_safeExample_obligation  me d  :=
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             Contract_transferSuccessful update_Contract_transferSuccessful ETH_successful_transfers update_ETH_successful_transfers]
    in
    high_level_invariant d ->
    synth_func_obligation Contract_safeExample Contract_safeExample_wf
								      me d.
  
  Lemma Contract_safeExample_obligation_eq : forall  me d, 
    Contract_safeExample_obligation  me d ->
    high_level_invariant d ->
    synth_func_obligation Contract_safeExample Contract_safeExample_wf  me d.
    Proof.
      intros  me d H_cond.
      cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             Contract_transferSuccessful update_Contract_transferSuccessful ETH_successful_transfers update_ETH_successful_transfers].
       exact H_cond.
    Qed.

  Definition Contract_safeExample_spec :=
  Eval cbv [sf_mem sf_return fst snd Contract_safeExample_opt] in
    fun  me => execStateT (Contract_safeExample_opt me).
  Lemma Contract_safeExample_spec_eq :
    Contract_safeExample_spec =
    fun  me => execStateT (synth_func_spec_opt Contract_safeExample Contract_safeExample_wf me).
  Proof.
    cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

          Contract_transferSuccessful update_Contract_transferSuccessful ETH_successful_transfers update_ETH_successful_transfers].
    reflexivity.
  Qed.

Global Opaque Contract_safeExample_opt.

  Definition Contract_unsafeExample := {|
    FC_ident_start := BuiltinBase_local_ident_start;
    FC_params := nil;
    FC_returns := void_unit_pair;
    FC_body := (CCstore
      (LCvar Contract_transferSuccessful_var)
      (ECconst_int256 tint_bool true Int256.one))
  |}.
  Lemma Contract_unsafeExample_wf
      : synth_func_wellformed Contract_unsafeExample.
  Proof. solve_wellformed. Defined.
  Definition Contract_unsafeExample_opt : machine_env GetHighData -> DS unit  := 
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             Contract_transferSuccessful update_Contract_transferSuccessful ETH_successful_transfers update_ETH_successful_transfers]
  in synth_func_spec_opt Contract_unsafeExample Contract_unsafeExample_wf.
  Definition Contract_unsafeExample_spec_hlist_opt args :=
    @apply_param_func Contract_unsafeExample.(FC_params) _
                      (Contract_unsafeExample_opt) args.


(* CEI stands for Checks Effects Interactions (pattern) and the definitions below are used
    to keep track of the safe situations in which a primitive can be called. See also
    cmd_constr_CEI_pattern_prf in Syntax.v and for the tactic definitions see Runtime.v *)
    
Lemma Contract_unsafeExample_CEI_AB : { rsts | function_constr_CEI_pattern_prf (fst rsts) Contract_unsafeExample (snd rsts)}.
Proof.
  unfold Contract_unsafeExample.
  CEI_auto_AB. (* If this tactic fails then it indicates that a strict version of the Checks-Effects-Interactions pattern was not followed in the function: Contract_unsafeExample. *)
Defined.

Lemma Contract_unsafeExample_CEI_BA : { rsts | function_constr_CEI_pattern_prf (fst rsts) Contract_unsafeExample (snd rsts)}.
Proof.
  unfold Contract_unsafeExample.
  CEI_auto_BA.
Defined.

Definition Contract_unsafeExample_CEI_rsts_before_A := fst (proj1_sig Contract_unsafeExample_CEI_AB).
Definition Contract_unsafeExample_CEI_rsts_after_A := snd (proj1_sig Contract_unsafeExample_CEI_AB).
Definition Contract_unsafeExample_CEI_rsts_before_B := fst (proj1_sig Contract_unsafeExample_CEI_BA).
Definition Contract_unsafeExample_CEI_rsts_after_B := snd (proj1_sig Contract_unsafeExample_CEI_BA).

  Definition Contract_unsafeExample_prim := {|
    PRIMident := ident_Contract_unsafeExample;
    (* PRIMcc := AST.cc_default; *)
    PRIMghost := false;
    PRIMpure := false;
    PRIMargt_marker := Contract_unsafeExample.(FC_params);
    PRIMret_marker := Contract_unsafeExample.(FC_returns);
    PRIMrst_before_A := Contract_unsafeExample_CEI_rsts_before_A;
    PRIMrst_after_A := Contract_unsafeExample_CEI_rsts_after_A;
    PRIMrst_before_B := Contract_unsafeExample_CEI_rsts_before_B;
    PRIMrst_after_B := Contract_unsafeExample_CEI_rsts_after_B;
    PRIMcond := fun _ _ _ => True;
    (* PRIMsem := Contract_unsafeExample_spec_hlist; *)
    PRIMsem_opt := Contract_unsafeExample_spec_hlist_opt
  |}.

  Lemma Contract_unsafeExample_spec_hlist_opt_eq :
    Contract_unsafeExample_spec_hlist_opt =
    fun args => apply_param_func
      (synth_func_spec_opt Contract_unsafeExample Contract_unsafeExample_wf)
      args.
  Proof.
    cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             Contract_transferSuccessful update_Contract_transferSuccessful ETH_successful_transfers update_ETH_successful_transfers]. 
     reflexivity.
  Qed.
  Definition Contract_unsafeExample_cfun :=
  Eval cbv in synth_func_func Contract_unsafeExample.

  Definition Contract_unsafeExample_cond  me d  :=
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             Contract_transferSuccessful update_Contract_transferSuccessful ETH_successful_transfers update_ETH_successful_transfers]
    in
    high_level_invariant d ->
    synth_func_cond Contract_unsafeExample Contract_unsafeExample_wf
								      me d.
  
  Lemma Contract_unsafeExample_cond_eq : forall  me d, 
    Contract_unsafeExample_cond  me d ->
    high_level_invariant d ->
    synth_func_cond Contract_unsafeExample Contract_unsafeExample_wf  me d.
    Proof.
      intros  me d H_cond.
      cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             Contract_transferSuccessful update_Contract_transferSuccessful ETH_successful_transfers update_ETH_successful_transfers].
       exact H_cond.
    Qed.

  Definition Contract_unsafeExample_obligation  me d  :=
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             Contract_transferSuccessful update_Contract_transferSuccessful ETH_successful_transfers update_ETH_successful_transfers]
    in
    high_level_invariant d ->
    synth_func_obligation Contract_unsafeExample Contract_unsafeExample_wf
								      me d.
  
  Lemma Contract_unsafeExample_obligation_eq : forall  me d, 
    Contract_unsafeExample_obligation  me d ->
    high_level_invariant d ->
    synth_func_obligation Contract_unsafeExample Contract_unsafeExample_wf  me d.
    Proof.
      intros  me d H_cond.
      cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             Contract_transferSuccessful update_Contract_transferSuccessful ETH_successful_transfers update_ETH_successful_transfers].
       exact H_cond.
    Qed.

  Definition Contract_unsafeExample_spec :=
  Eval cbv [sf_mem sf_return fst snd Contract_unsafeExample_opt] in
    fun  me => execStateT (Contract_unsafeExample_opt me).
  Lemma Contract_unsafeExample_spec_eq :
    Contract_unsafeExample_spec =
    fun  me => execStateT (synth_func_spec_opt Contract_unsafeExample Contract_unsafeExample_wf me).
  Proof.
    cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

          Contract_transferSuccessful update_Contract_transferSuccessful ETH_successful_transfers update_ETH_successful_transfers].
    reflexivity.
  Qed.

Global Opaque Contract_unsafeExample_opt.
End OBJECT_Contract_DEFINITION.

End EdsgerGen.

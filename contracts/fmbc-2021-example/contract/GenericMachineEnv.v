(*WARNING: This file is generated by Edsger, the DeepSEA compiler.
          All modification will be lost when regenerating.

This file defines a function `generic_machine_env` that can be used to build machine environments. *)

Require Import contract.DataTypes.
Require Import contract.DataTypeOps.
Require Import lib.Monad.StateMonadOption.
Require Import cclib.Maps.
Require Import cclib.Integers.
Require Import ZArith.
Require Import core.HyperTypeInst.
Require Import backend.MachineModel.
Require Import core.MemoryModel.
Require Import DeepSpec.lib.Monad.RunStateTInv.
Require Import Lia.
Require Import contract.LayerETH_layer.
Require Import contract.LayerCONTRACT.

Module GenericMachineEnv.



Definition d_with_transfer adr amount (d : global_abstract_data_type) : global_abstract_data_type :=
{|
  ETH_successful_transfers := ({| DataTypes.recipient := adr; DataTypes.amount := amount |}) :: (ETH_successful_transfers d);
  Contract_successfully_transferred := Contract_successfully_transferred d; 
|}.

Section Block_Context. (* like bstep *)
(* 'Forall Blocks:' *)
Context
  (coinbase : int256)
  (timestamp : int256)
  (number : int256)
  (blockhash : int256 -> int256)
  (chainid : int256).

Section Nested_Calls_Context.
(* 'Forall calls from EoA:' *)
Context
  (origin: addr).

Section Individual_Call_Context. (* like mstep *)
(* 'Forall function calls: '*)
Context 
  (contract_address : addr)
  (caller: addr)
  (callvalue : int256)
  (initial_balances : addr -> int256)
  (address_always_accepts_funds : addr -> bool).

  Context {HmemOps: MemoryModelOps mem}.
  Context {memModelOps : MemoryModelOps mem}.
  Instance GlobalLayerSpec : LayerSpecClass := {
    memModelOps := memModelOps;
    GetHighData := global_abstract_data_type 
  }.

Definition debits_from_contract
(successful_transfers: list Transfer) :=
List.fold_left (fun z t => (Int256.intval (amount t) - z)%Z)
successful_transfers 0%Z.

Definition credits_to_address (a : addr)
(successful_transfers: list Transfer) :=
List.fold_left (fun z t =>
if Int256.eq (recipient t) a
then (Int256.intval (amount t) + z)%Z
else z)
successful_transfers 0%Z.

Definition current_balances_Z (initial_balances : addr -> int256)
                              (successful_transfers : list Transfer)
                              (a : addr) : Z :=
    if Int256.eq a contract_address
    then
      Int256.intval (initial_balances a)
    - debits_from_contract successful_transfers
    + credits_to_address a successful_transfers (*Just in case the contract transfers to itself. *)
    else 
      Int256.intval (initial_balances a)
    + credits_to_address a successful_transfers.

Definition current_balances (initial_balances : addr -> int256)
    (successful_transfers : list Transfer)
    (a : addr) : int256 :=
    Int256.repr (current_balances_Z initial_balances successful_transfers a).

Definition successful_transfer initial_balances current_successful_transfers recipient amount : bool := 
  let balance := current_balances initial_balances current_successful_transfers in    
        ((Int256.intval (balance contract_address)) - (Int256.intval amount) >=? 0)%Z
    && ((Int256.intval (balance recipient)) + (Int256.intval amount) <=? Int256.max_unsigned)%Z
    && (address_always_accepts_funds recipient).



Definition generic_machine_env 
                            : machine_env global_abstract_data_type
  := {| me_address := contract_address;
        me_origin := origin;
        me_caller := caller; (* need update after every control-flow transfer *)
        me_callvalue := callvalue;
        me_coinbase := coinbase; 
        me_timestamp := timestamp;
        me_number := number;
        me_balance d a := current_balances initial_balances (ETH_successful_transfers d) a;
        me_blockhash := blockhash;
        me_transfer recipient amount d := if successful_transfer initial_balances (ETH_successful_transfers d) recipient amount then (Int256.one, d_with_transfer recipient amount d) else (Int256.zero, d);
        (* Note that the way me_transfer has been defined above will only add a transaction to the ETH_successful_transfers list if the contract has sufficient balance to send the transaction,
           the recipient isn't so rich such that their balance being added to would cause an overflow, and if the `address_always_accepts_funds` function indicates they would accept the funds.
           
           The function from the context `address_always_accepts_funds` defines which addresses are assumed to always accept funds.
           Currently, the Axiom `All_Addresses_Always_Accept_Funds` assumes that all addresses always accept funds. This axiom should be changed if it is not a reasonable assumption,
           for example if an address rejecting funds is part of a model of what an attacker might do.
           It is possible that the recipient might reject the funds (e.g. if the recipient is a 'smart contract' and the processing of receiving the transfer runs out of gas).
        *)
        me_callmethod _ _ _ _ _ _ _ _ _ _ := False;
        me_log _ _ d := d; (* TODO-Daniel what is the purpose of me_log? Is this a sufficient definition for now? *)
        me_chainid := chainid;
        me_selfbalance d := current_balances initial_balances (ETH_successful_transfers d) contract_address (* Note that this form of getting selfbalance is also used in me_transfer's definition. *)
      |}.


End Individual_Call_Context.

End Nested_Calls_Context.

End Block_Context.

  

End GenericMachineEnv.